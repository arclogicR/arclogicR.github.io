{"meta":{"title":"Arclogic's Blog","subtitle":"subtitleA","description":"descriptionA","author":"Arclogic","url":"https://arclogicr.github.io","root":"/"},"pages":[{"title":"categories","date":"2022-10-19T10:33:01.000Z","updated":"2022-10-19T10:34:34.050Z","comments":true,"path":"categories/index.html","permalink":"https://arclogicr.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-10-19T10:09:51.154Z","updated":"2022-10-19T10:09:51.139Z","comments":true,"path":"tags/index.html","permalink":"https://arclogicr.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"kvm如何禁止虚拟机之间通信","slug":"kvmq1","date":"2023-01-04T07:37:05.000Z","updated":"2023-01-04T07:42:35.568Z","comments":true,"path":"2023/01/04/kvmq1/","link":"","permalink":"https://arclogicr.github.io/2023/01/04/kvmq1/","excerpt":"","text":"一般来说，使用KVM创建虚拟机，都会有虚拟机之间通信的需求，KVM的四种网络模式也都默认允许同一网段的虚拟机之间互通。如果有特殊需求，需要禁止虚拟机之间的通信，该如何配置？ KVM四种网络模式 首先隔离模式，相当于Vmware&#x2F;Vbox 仅主机模式，VM之间可通信，VM与宿主可通信，VM与外部不可通信 NAT模式，VM之间可通信，VM与宿主可通信，VM可访问外部，外部访问VM需要做端口转发 桥接模式，VM之间可通信，VM与宿主可通信，VM可访问外部，外部可访问VM。一般桥接模式下VM网段与宿主机同段。 路由模式，VM之间可通信，VM与宿主可通信，VM可访问外部，外部可访问VM。路由模式下VM网段可以与宿主机不同端，外部需要配置路由才能访问VM iptables解决方案搜了资料，有人说可以用iptables实现，原理如下 NAT模式下，宿主机有一块网卡virbr0。针对virbr0，在iptables中FORWARD链限制同网段互访 1-A FORWARD -i virbr0 -s 192.168.1.0/24 -d 192.168.1.0/24 -j DROP 我尝试了下，不知为何不生效，也许因为虚拟机互访实际流量并不经过virbr0？尝试将FORWARD链改为INPUT链也是不生效。后来放弃iptables，改用nwfilter。 nwfilter解决方案nwfilter是kvm自带的网络流量工具，可以精确控制每一块vm网卡。上面iptables的方案是在宿主机上做策略，而nwfilter是对每一个vm做策略，nwfilter的策略可以应用在多个vm上。 总的来说nwfilter的用法就是，定义nwfilter策略，生效策略，应用策略。下面以NAT模式下禁止虚拟机之间互通为例介绍nwfilter解决方案 定义策略在&#x2F;etc&#x2F;libvirt&#x2F;nwfilter下建立xml文件 1vi /etc/libvir/nwfilter/deny-inter.xml 写入规则 123456789&lt;filter name=&#x27;deny-inter&#x27; chain=&#x27;ipv4&#x27; priority=&#x27;-700&#x27;&gt; &lt;uuid&gt;ab4b9613-3442-41af-a4b3-0a3bdaae7111&lt;/uuid&gt; &lt;rule action=&#x27;accept&#x27; direction=&#x27;in&#x27; priority=&#x27;200&#x27;&gt; &lt;ip srcipaddr=&#x27;192.168.122.1&#x27; srcipmask=&#x27;32&#x27;/&gt; &lt;/rule&gt; &lt;rule action=&#x27;drop&#x27; direction=&#x27;in&#x27; priority=&#x27;201&#x27;&gt; &lt;ip srcipaddr=&#x27;192.168.122.0&#x27; srcipmask=&#x27;24&#x27;/&gt; &lt;/rule&gt;&lt;/filter&gt; 其中， 这里只采用了ipv4的链，只需要对ip包进行过滤 注意uuid不要与现有的相同 每条规则后的优先级越小越优，如果优先级相同优先匹配前面的规则 这里的规则将来是应用在虚拟机上，所以in&#x2F;out是针对虚拟机网卡的 第一条规则是为了保证dhcp正常工作，这里用in方向策略会方便一点，因为dhcp discover包发出去是广播，dhcp offer包回来是单播，in方向只需要允许宿主机的单播包就可以了 更多nwfilter的详细用法可以参考VirtualNetworking - Libvirt Wiki 生效策略12virsh nwfilter-define deny-inter.xml #生效策略virsh nwfilter-list #查看是否生效 应用策略编辑虚拟机配置文件 1virsh edit vm01 找到添加定义过的策略 123456&lt;interface type=&#x27;network&#x27;&gt; &lt;mac address=&#x27;52:54:00:ec:f5:4e&#x27;/&gt; &lt;source network=&#x27;default&#x27;/&gt; &lt;model type=&#x27;e1000&#x27;/&gt; &lt;filterref filter=&#x27;deny-inter&#x27;/&gt; #ADD POLICY &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x03&#x27; function=&#x27;0x0&#x27;/&gt; 最后重启虚拟机，VM之间无法ping通，VM与宿主机可通，VM ping 外面可通。","categories":[{"name":"日积月累","slug":"日积月累","permalink":"https://arclogicr.github.io/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"}],"tags":[{"name":"network","slug":"network","permalink":"https://arclogicr.github.io/tags/network/"},{"name":"kvm","slug":"kvm","permalink":"https://arclogicr.github.io/tags/kvm/"}]},{"title":"OSPF经典问题汇总","slug":"OSPF-QA","date":"2022-03-28T08:13:52.000Z","updated":"2022-10-28T09:48:55.079Z","comments":true,"path":"2022/03/28/OSPF-QA/","link":"","permalink":"https://arclogicr.github.io/2022/03/28/OSPF-QA/","excerpt":"","text":"OSPF采用分区域设计有什么好处？ 可以在ABR做路由汇总，减少其它区域路由表条目，减轻路由器压力 减少1，2类LSA泛洪 减少路由收敛的范围，一个区域的问题不会影响其它区域 影响OSPF邻接的原因有哪些？1、ROUTER ID不能相同；2、HELLO时间必须一致；3、DEAD时间必须一致；4、区域ID必须相同；5、认证必须相同；6、STUB标志位必须相同（hello包中域外路由重分布能力位）；7、MTU不匹配无法形成邻接关系8、OSPF版本号不同（目前版本为2）；9、当OSPF网络类型是MA时，要求掩码一定一致（两个邻居）。因为会出现DR和LSA-2，无法描述网段 如果OSPF双方路由器MTU不一致，会发生什么情况无法建立邻接关系 假设R1 MTU &lt; R2 MTU 首先，双方都可以进入exstart状态。然后双方开始单播发送第一个DBD，此时若R2的RID&gt;R1的RID 对于R1：收到R2第一个DBD发现MTU比自己大，无法接受；所以维持发送第一个DBD的状态，即维持exstart状态 对于R2: 正常收到R1的第一个DBD然后可以计算出自己是master，然后等待对方发送LSA摘要；但是发现R1只会发第一个DBD不发LSA摘要，（猜测：可能以为通讯有问题），于是维持发送第一个DBD，即维持exstart状态 若R2的RID&lt;RI的RID 对于R1：收到R2第一个DBD发现MTU比自己大，无法接受；所以维持发送第一个DBD的状态，即维持exstart状态 对于R2: 正常收到R1的第一个DBD然后可以计算出对方是master而自己是slave，然后会发送LSA摘要，即进入exchange状态，但对方没有回复LSA摘要，所以会支持卡在exchange这个状态 总结：当双方mtu不一致时若DBD从的mtu小，则双方都卡在exstart若DBD从的mtu大，则mtu大的进入exchange，mtu小的维持exstart 总之，mtu小的一定卡在exstart，mtu大的有可能进入exchange（取决于是否是DBD从角色） OSPF何时用组播，何时用单播？ HELLO包，不手动指定邻居的话都是发送到组播224.0.0.5 DBD，只是两个路由器之间建邻居互传DB摘要，采用单播 LSR，请求LSA，直接向DR请求，单播 LSU 回复LSR时是单播 触发更新时是组播 DR-Other 采用组播224.0.0.6告知DR&#x2F;BDR，由DR发送224.0.0.5告知其它所有路由器 p2p类型网络都是发送到组播224.0.0.5 LSAck，组播224.0.05 OSPF邻居表发现2-way是否正常MA网络中正常在MA网络中，DR和BDR分别与DROther建立full邻接关系，DROther之间只是2-way关系 如何判断一条LSA的新旧当一台路由器收到相同的LSA的多个实例时，将通过以下算法决定将哪一条放入数据库： 1、比较LSA实例的序列号，大的优先2、序列号相同，再比校验和，大的优先3、校验和也相同，再比老化时间，如果有一条LSA拥有大小为最大生存时间（3600S）的老化时间，则最优4、如果LSA的老化时间之间的差别多于15分钟，则老化时间小的优先5、如果以上条件都比不出来，则认为这些LSA相同 如果不相邻的两台OSPF路由器RID相同会发生什么若这些路由器在同一区域R1-R2-R3连接，且都属于同一区域假设R2-R3先正常建立邻居后，R1配置R3的RID接入。此时R1与R2可以建立full邻接关系，R1会收到R2发来的较新的1类LSA，这里的1类LSA应该有两条第一条ADV Router是R3第二条ADV Router是R1 这里R1会接受R2独有的路由（即ADV Router为R2且R3 没通告的路由，如lo 0的路由），收到R3路由发现和自己RID一样，会报RID dup的错，同时也会发送自己的最新的LSA。R3同理。最后结果就是R1,R3可以学到R2的loopback 路由但R1,R3互相的路由不稳定会翻动 若这些路由器在不通区域R1-R2-R3连接，R1-R2属于区域1，R2-R3属于区域0假设R2-R3先正常建立邻居后，R1配置R3的RID接入。此时R1与R2可以建立full邻接关系。这里R2是ABR，R2会吧R3通告的1类LSA转为3类，在发给区域1的时候ADV Router字段会变为自己（即R2的RID），但不会重新处理5类LSA。所以对区域1的内部路由器R1来说，收到的R3路由会当做普通的三类LSA处理，并不知道这些OIA路由来自哪里；同理，R3也能学到R1的域内路由。最后结果就是R1,R3可以互相学到域内路由","categories":[{"name":"网络基础","slug":"网络基础","permalink":"https://arclogicr.github.io/categories/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"network","slug":"network","permalink":"https://arclogicr.github.io/tags/network/"},{"name":"routing","slug":"routing","permalink":"https://arclogicr.github.io/tags/routing/"},{"name":"ospf","slug":"ospf","permalink":"https://arclogicr.github.io/tags/ospf/"}]},{"title":"OSPF学习笔记","slug":"ospf-notes","date":"2022-03-27T10:12:04.000Z","updated":"2022-10-28T09:49:21.030Z","comments":true,"path":"2022/03/27/ospf-notes/","link":"","permalink":"https://arclogicr.github.io/2022/03/27/ospf-notes/","excerpt":"","text":"概述OSPF全称开放最短路径优先（Open Shortest Path First）是一种链路状态路由协议。v2版本的OSPF基于IPv4，v3版本的OSPF基于IPv6。在IPv4网络中OSPF应该是被使用最广泛的IGP了。 基本特点 OSPF属于IGP，是链路状态协议，基于IP协议号89 采用分区域的设计，所有区域需要和骨干区域ar0相连 区域内采用SPF(Dijkstra算法)计算最佳路径 可以快速响应网络拓扑变化（触发更新） 支持等价路径负载 三张表OSPF的运行涉及三张表 邻居表用于记录与opsf邻居之间的状态、参数等； 拓扑表本质是LSDB,通过LSA来更新数据。用于记录接收的LSA信息，在区域内和ma网络中保持一致 路由表通过DJ算法将最佳路由提交到路由表 OSPF路由器类型 路由器类型 功能 内部路由器 在一个普通区域内部的路由器 骨干路由器 在区域0的内部路由器 ABR 区域边界路由器，连接两个不通区域的路由器 ASBR 自治系统边界路由器，连接OSPF到另一个自治系统的路由器 OSPF报文类型 类型 内容 HELLO hello包，用于建立&#x2F;维护邻居 DBD 数据库描述，用于同步自身LSDB摘要 LSR 链路状态请求，用于请求LSA LSU 链路状态更新，用于传播LSA详细，可单播可组播 LSAck 用于确认收到LSU OSPF邻居OSPF通过hello报文来建立和维护邻居 ospf邻居建立过程down：周期性发送hello包；收到不带自己RID的hello包时进入initinit：继续正常周期性发送hello包；收到带自己RID的hello包进入2way2way：通过hello包携带的DR&#x2F;BDR信息（如有）选举DR&#x2F;BDR;然后进入exstartexstart: 双法开始单播发送第一个DBD；根据对方的第一个DBD选取主从；然后进入exchangeexchange: 开始交换DBD，以master序列号为基准，slave先发DBD，通过序列号隐式确认；发送完毕后进入Loadingloading: 双方开始根据DBD的LSA摘要，单播发送LSR请求详细的LSU，同步完成后进入fullfull: 邻接完成 OSPF LSA内容一个LSA可由{Type,LS ID,ADV Router}唯一描述 Type，LSA类型，常见有1，2，3，4，5，7 LS ID，链路状态ID，可理解为一个LSA的名称，每类LSA的该字段有不通含义 ADV Router，通告路由器 Age，老化时间，一般为3600s，每1800s会无触发更新 Seq，序列号，0x80000001开始计数，越大表示LSA越新 Checksum，校验和 Do Not Age Flag，不老化标识，虚链路LSA该位为1 OSPF LSA类型 类型 传播范围 产生与功能 LS ID字段 ADV字段 1类Router 区域内 每台路由器都会产生，传输本地链路状态 Router ID Router ID 2类Network 区域内，广播域内 DR产生，标识本MA网络中掩码和路由器 DR接口IP DR RouterID 3类Router Summary 泛洪整个AS（除totally stub区域） 由ABR重新产生（根据1、2类或其它3类），用于传递区域间路由 域间路由（网络号） ABR的Router ID，经过一个ABR就会变为该ABR的RID 4类ASBR Summary 除ASBR外的非stub区域 由ASBR所在区域的ABR产生并发出，用于告知ASBR的位置 ASBR的Router ID ABR的Router ID，经过一个ABR就会变为该ABR的RID 5类AS-External 全域泛洪，stub区域除外 ASBR产生，保持ADV不变，传递域外路由 域外路由（网络号） ASBR的Router ID 7类NSSA-External 只存在于NSSA区域内,NSSA的ABR会做7转5 由NSSA区域内ASBR产生，传递域外路由 域外路由（网络号） ASBR的Router ID OSPF区域类型ospf采用层次设计，用区域分割路由器；区域中路由器保存该区域中所有链路和路由器详细信息，但只保存其它区域路由器和链路的摘要信息 骨干区域主要为高速快速传递数据，通常不接用户 常规区域主要连接用户。所有数据需经过骨干区域中转。 非骨干区域主要包含以下几种类型 区域 特点 普通区域 区域内泛洪1、2类LSA，也会传递3，4，5类LSA Stub 不能配置外部重分发，阻止4，5类路由，ABR自动下发OIA默认路由 Totally Stub 不能外部重分发，不会传3，4，5类LSA，会传递1，2类和3类默认LSA，ABR自动下发OIA默认 NSSA 可以重分发外部路由作为7类LSA在ABR转成5类。允许1，2，3，7类LSA，ABR不会自动下发OIA默认 Totally NSSA 阻止3，4，5类LSA，允许1，2，7和3类默认LSA，ABR自动下发OIA默认 OSPF路由类型OSPF的LSA类型较多，不同LSA传递的路由类型也不一样，共有一下几种类型 O路由区域内路由，由1类LSA和2类LSA通过DJ算法计算得出 O IA路由区域间路由，由3类LSA习得 O E1&#x2F;N1路由1类外部路由&#x2F;1类NSSA外部路由，由4&#x2F;5&#x2F;7类LSA习得； O E2&#x2F;N2路由2类外部路由&#x2F;1类NSSA外部路由，由4&#x2F;5&#x2F;7类LSA习得； OSPF选路度量OSPF路由管理距离（AD）默认是110 （CISCO）， 度量单位是cost cost&#x3D;reference&#x2F;interface bandwidth reference默认是100000000 （10^8），其中每台路由器可以配置不一样，但建议全局一致。另外cost是分方向的，因为ospf区域内收敛算法（dj）需要画有向权重图，cost即为单向权重。 外部路由度量 &#x2F;Forward AddressForward Address 字段用于优化外部MA网络路由下一跳的问题。在ASBR产生LSA5时填充FA，若该外部路由下一跳接口是MA、且是有效ospf接口则FA填充为改路由实际下一跳地址。 Forward Metric 是本地到Forward Address 的cost，当forwardaddress&#x3D;0.0.0.0时，forward metric是本路由器到ASBR的metric OSPF外部路由type2（默认），默认种子metric为20，且metric不变OSPF外部路由type1，metric是种子metric+forward metric 另外，在 NSSA 区域，协议规定不能发送为0的FA；当把直连重分布进来，Forward Address：1、加入 ospf 最新的回环口作为 Forward Address；2、如果没有回环口，那么加入 ospf 最新的激活的接口地址； 如果把外部路由重分布进来，Forward Address：1、外部接口没有运行 ospf，Forward Address 同上；2、外部接口运行了 ospf，Forward Address 是外部路由的下一跳地址。 O 路由选路 依次比较AD Metric 小的优先 当收到来自不同的AR的1 2类LSA，计算的O路由，AD与Metric，先到的优先，不会负载 当收到来自相同AR的LSA1 2类，计算的O路由，AD与Metric相同，负载 O IA 路由选路 O&gt;OIA，不考虑AD、Metric 当收到来自Area 0的3类LSA时，不考虑其它区域的3类LSA，优选Area 0的，不考虑AD、Metric。若均来自Area0，一次比较AD、Metric，若相同，则负载； 当收到来自非Area0的3类LSA时，依次比较AD、Metric，小的有限，若相同，则负载 O E 选路 OIA&gt;OE，不考虑AD、metric OE1&gt;OE2，不考虑AD、meitric OE1路由，比较AD与Metric，相同则负载 OSPF路由汇总3类LSA汇总1area 2 range 100.1.0.0 255.255.252.0 含义：把区域2的1,2类转为3类时做汇总，即area 后面跟的区域。不能把本来就是OIA的路由做汇总； 5类LSA汇总1Summary-address 100.1.0.0 255.255.252.0 含义：5类LSA的汇总，只能在ASBR上做，即对自己产生的5类路由汇总，对于别的路由器产生的5类路由，没有汇总能力 OSPF网络类型网络物理连接可分为三种 POINT_TO_POINT BROADCAST NBMA 根据物理网络连接类型，OSPF网络类型分为以下几种： 类型 二层 Hello&#x2F;Dead DR&#x2F;BDR 手动邻居 &#x2F;32路由 P2P HDLC\\PPP\\FRp2p 10&#x2F;40 NO NO NO BROADCAST Eth、令牌环、FDDI 10&#x2F;40 YES NO NO NBMA FR&#x2F;X.25&#x2F;ATM 30&#x2F;120 YES YES NO P2MP(Multi) HUB-SPOKE 30&#x2F;120 NO NO YES P2MP(NB) CISCO私有 30&#x2F;120 NO YES YES Loopback loopback 当作host处理 OSPF建立邻接关系与网络类型无关，与hello&#x2F;dead有关，但不同的网络类型建立邻居后有可能学不到路由。 如果参与建邻的路由器都需要选举或都不需要选举DR&#x2F;BDR，则可以学习到路由，否则学不到，具体关系如下： p2p broadcast NBMA p2mp p2mp NB p2p NO NO YES YES broadcast YES NO NO NBMA NO NO p2mp YES p2mp NB OSPF虚链路OSPF虚链路用于解决OSPF区域设计上的问题。 假设R0-R1-R2-R3互联，R0-R1之间，R1-R2之间，R2-R2之间区域分别为0，1，2。R3由于现实原因无法与R0互联，那么可以采用虚链路。在ABR R1和中转区域R2上配置虚链路，相当于R2与区域0相连。 虚链路在使用上有一些限制： 虚链路只在建立邻居的时候发送hello包，邻居建立后不再发送 虚链路的LSA只会触发更新，并且不会老化 虚拟链路cost继承物理链路 虚链路不能跨区域建立（只能在‘被分割的’中转区域建立） 不能建立再STUB区域 OSPF认证OSPF认证是指在发送hello包时添加认证字段达到认证邻居的效果，可以保护自己的路由传给通过认证的邻居。 OSPF认证分接口认证和区域认证，区域认证本质就是所有属于该区域的接口都参与认证。同时配置接口认证和区域认证，以接口认证配置优先。 接口认证接口明文认证123int s1/1ip ospf authenticationip ospf authentication-key cisco 接口md5认证123int s1/1ip ospf authentication message-digestip ospf message-digest-key **1** md5 **cisco** 其中1是key-id，cisco是md5原文 区域认证区域明文12router ospf 1ar 0 authentication 区域md512router ospf 1ar 0 authentication message-digest 多 key md5 认证规则：当配置了最新的 key，将最新 key 与旧 key 都发送到对端： 若最新的 key，到对端没有找到对应的 key-id，则两端采用旧 key 完成认证。 若最新的 key，到对端找到相同的key-id，比较密钥，密钥不一致，认证失败；密钥一致，则认证通","categories":[{"name":"网络基础","slug":"网络基础","permalink":"https://arclogicr.github.io/categories/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"network","slug":"network","permalink":"https://arclogicr.github.io/tags/network/"},{"name":"routing","slug":"routing","permalink":"https://arclogicr.github.io/tags/routing/"},{"name":"ospf","slug":"ospf","permalink":"https://arclogicr.github.io/tags/ospf/"}]},{"title":"IPv4地址","slug":"ipv4","date":"2022-03-17T10:16:23.000Z","updated":"2022-10-28T09:47:39.067Z","comments":true,"path":"2022/03/17/ipv4/","link":"","permalink":"https://arclogicr.github.io/2022/03/17/ipv4/","excerpt":"","text":"概述IPv4，全称Internet Protocol version 4，网际互联协议第四版。“the Internet”专指的互联网，而这里感觉internet翻译成“网络之间”、“网际”比较好，而不是“互联网”。 IP地址IP地址是IP协议中重要的一个逻辑概念，它用来去定位、寻找网络的组成部分中的一个（单播）或一些（多播、组播） IP地址的组成一个IP地址由4组8位的二进制数组成，中间用“.”分隔，如： 111000000.10101000.00000001.00000010 二进制位数太多，为了记忆、表达方便，一般采用十进制方式表达，每一段取值区间为[0,255]，上述IP地址可表示为 1192.168.1.2 掩码（Mask）一个IP地址共有4×8&#x3D;32位组成，按照位来划分，可人为定义主机号和网络号，比如 1192.168.1.2 我们定义前24位是网络位，后面8位是主机位。如此一来，我们可以很方便地根据前24位IP来定位一个网络，后8位来定位一台主机。其中192.168.1.0表示一个网络号，192.168.1.2表示192.168.1.0这个网络中的一台主机，24是192.168.1.0这个网络的掩码长度。 很容易发现192.168.1.0这个网络可用前24位唯一标识，而后8位主机位不能影响我们识别一个网络。那么我们将192.168.1.2化为二进制11000000.10101000.00000001.00000010，将它和由24个1和8个0组成的“IP”地址11111111.11111111.11111111.00000000进行’与’操作，得到的恰好就是它的网络号11000000.10101000.00000001.00000000(192.168.1.0)。把这个特殊的“IP”化为二进制得到255.255.255.0，这就是子网掩码。 IP地址分类、私有地址有类划分早期IP地址有一套有类划分方式，即根据一定则将IP地址根据子网掩码&#x2F;8，&#x2F;16，&#x2F;24分为不同类。但是这种分类方案显然并不十分合理，浪费IP资源。比如一个固定20台终端的部门被分配了&#x2F;24掩码的网段，那么有230多个地址没有被使用。 无类划分后来有了VLSM（可变长子网掩码）的概念，即可任意指定子网掩码。早期的路由协议如ripv1，igrp等都是只支持有类路由的；而CIDR(无类域间路由)，是基于VLSM的。 私有IP地址IP地址是一个逻辑概念，用于定位互联的网络中一台终端。理论上一个网络中所有IP地址不能有重复，但是由于IPv4地址耗尽，必须复用一些IP地址。一些不接入互联网的组织、单位、机构等，只需内部网络IP地址保持唯一即可。私有IP就是为这种场景设计的，在IP地址的有类划分中，每一类都有一个私有地址段。当然这种场景下，如果有访问互联网的需求，在公网地址有限的情况下，可以通过NAT技术实现私有网络与互联网互通。 IPv4地址有类划分A类地址IP地址第一段首位固定为0，即 10xxxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx 由于第一位固定是0，第一段取值范围为0-127 A类私有地址为10.0.0.0&#x2F;8A类地址占总地址1&#x2F;2 B类地址首位固定10， 110xxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx 第一段取值范围是128-191 私有地址172.16.16.0&#x2F;12 (16-31) 16个B C类地址首位固定110 1110xxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx 第一段取值范围192-223 私有地址192.168.0.0&#x2F;16 256个C C类地址占总地址1&#x2F;8 D类地址（组播，没有网络号和主机号）首位固定1110 11110xxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx 首段取值224-239 私有地址239.0.0.0&#x2F;8 D类地址占总地址1&#x2F;16 E类地址为实验地址，为除ABCD类之外的地址","categories":[{"name":"网络基础","slug":"网络基础","permalink":"https://arclogicr.github.io/categories/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"network","slug":"network","permalink":"https://arclogicr.github.io/tags/network/"},{"name":"tcp/ip","slug":"tcp-ip","permalink":"https://arclogicr.github.io/tags/tcp-ip/"}]}],"categories":[{"name":"日积月累","slug":"日积月累","permalink":"https://arclogicr.github.io/categories/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"},{"name":"网络基础","slug":"网络基础","permalink":"https://arclogicr.github.io/categories/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"network","slug":"network","permalink":"https://arclogicr.github.io/tags/network/"},{"name":"kvm","slug":"kvm","permalink":"https://arclogicr.github.io/tags/kvm/"},{"name":"routing","slug":"routing","permalink":"https://arclogicr.github.io/tags/routing/"},{"name":"ospf","slug":"ospf","permalink":"https://arclogicr.github.io/tags/ospf/"},{"name":"tcp/ip","slug":"tcp-ip","permalink":"https://arclogicr.github.io/tags/tcp-ip/"}]}