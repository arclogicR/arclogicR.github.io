<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Arclogic&#39;s Blog</title>
  
  <subtitle>subtitleA</subtitle>
  <link href="https://arclogicr.github.io/atom.xml" rel="self"/>
  
  <link href="https://arclogicr.github.io/"/>
  <updated>2023-01-27T05:48:44.703Z</updated>
  <id>https://arclogicr.github.io/</id>
  
  <author>
    <name>Arclogic</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>虚拟机部署OpenWrt外部无法访问问题</title>
    <link href="https://arclogicr.github.io/2023/01/16/openwrt-ts/"/>
    <id>https://arclogicr.github.io/2023/01/16/openwrt-ts/</id>
    <published>2023-01-16T14:10:58.000Z</published>
    <updated>2023-01-27T05:48:44.703Z</updated>
    
    <content type="html"><![CDATA[<p>前几天心血来潮，想尝试下<a href="https://arclogicr.github.io/2023/01/14/openwrt-ply/">使用VirtualBox部署OpenWrt充当旁路由</a>。在配完OpenWrt后，手机的流量死活没有办法被旁路由转发。当时以为是OpenWrt设置问题，详细查阅了OpenWrt官网有关接口和防火墙的设置，折腾半天并没有解决。作为一个网工老司机，应用功能可以没有实现，网络绝不能不通。绝对无法忍受在我面前发生网络不通。于是又折腾两天，终于找到原因了。下面是排错（pò àn）过程</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>物理拓扑如下，手机可正常通过无线路由器上网，笔记本无线连接至无线路由器。</p><p><img src="/2023/01/16/openwrt-ts/topo_physical.png" alt="OPENWRT PHY"></p><p>其中，</p><ul><li><p>手机为iphone，无线连接至主路由器，自动获得来自主路由分配的IP为192.168.3.101&#x2F;24，GW192.168.3.1</p></li><li><p>主路由器为某普通家用无线路由器，LAN口地址192.168.3.1&#x2F;24</p></li><li><p>笔记本电脑内运行VirtualBox虚拟机桥接到无线网卡，开启混杂模式，虚拟机运行OpenWrt22.03.3；OpenWrt关键配置如下：</p><ul><li><p>网卡数：1张</p></li><li><p>接口配置：静态地址，IP 192.168.3.2&#x2F;24，GW 192.168.3.1；</p></li><li><p>防火墙：INPUT,OUTPUT,FORWARD全通，开启MASQ（PAT）</p></li></ul></li></ul><h2 id="预期结果"><a href="#预期结果" class="headerlink" title="预期结果"></a>预期结果</h2><p>按照如上环境配置后，将手机网络设置为手动，GW改为192.168.3.2，DNS改为223.5.5.5。理论上来说手机应该可以正常上网，预想中的逻辑拓扑如下</p><p><img src="/2023/01/16/openwrt-ts/topo_logical.png" alt="OPENWRT LOG"></p><p>各终端IP参数如下</p><table><thead><tr><th></th><th>MAC</th><th>IP DHCP自动获取</th><th>IP手动配置</th></tr></thead><tbody><tr><td>笔记本电脑</td><td>AAAA.AAAA.AAAA</td><td>192.168.3.102</td><td>192.168.3.102</td></tr><tr><td>手机</td><td>BBBB.BBBB.BBBB</td><td>192.168.3.101</td><td></td></tr><tr><td>OpenWrt虚拟机</td><td>CCCC.CCCC.CCCC</td><td></td><td>192.168.3.2</td></tr><tr><td>无线路由器</td><td>DDDD.DDDD.DDDD</td><td></td><td>192.168.3.1</td></tr><tr><td>win10虚拟机</td><td>EEEE.EEEE.EEEE</td><td></td><td>192.168.168.3.103</td></tr></tbody></table><p>OpenWrt虚拟机，笔记本电脑和手机应当可以视作在同一二层局域网。预想中的通信过程如下:</p><p>首先，当手机连接WIFI后，发送ARP广播请求192.168.3.2（OpenWrt）的mac地址；OpenWrt回复ARP。</p><p>然后手机开始通信，假设ping 223.5.5.5，即发送icmp，源目地址如下</p><table><thead><tr><th>SMAC</th><th>DMAC</th><th>SIP</th><th>DIP</th></tr></thead><tbody><tr><td>BBBB.BBBB.BBBB</td><td>CCCC.CCCC.CCCC</td><td>192.168.3.101</td><td>223.5.5.5</td></tr></tbody></table><p>OpenWrt收到报文后做PAT转发，转发报文的源目地址如下：</p><table><thead><tr><th>SMAC</th><th>DMAC</th><th>SIP</th><th>DIP</th></tr></thead><tbody><tr><td>CCCC.CCCC.CCCC</td><td>DDDD.DDDD.DDDD</td><td>192.168.3.2</td><td>223.5.5.5</td></tr></tbody></table><p>然后无线路由器将OpenWrt的包当做某个终端正常的包进行转发，收到223.5.5.5的回复后转发给OpenWrt，OpenWrt再根据PAT转发表转发回给手机</p><h2 id="故障排查"><a href="#故障排查" class="headerlink" title="故障排查"></a>故障排查</h2><p>事实上安装上述环境配置后，手机无法上网。随后开始故障排查</p><h3 id="确认OpenWrt收到来自手机的数据包"><a href="#确认OpenWrt收到来自手机的数据包" class="headerlink" title="确认OpenWrt收到来自手机的数据包"></a>确认OpenWrt收到来自手机的数据包</h3><p>首先，怀疑OpenWrt没有收到手机的包，于是在OpenWrt上安装tcpdump，使用如下命令抓包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 icmp</span><br></pre></td></tr></table></figure><p>发现OpenWrt有收到手机192.168.3.101的包，但是没有转发出去的包</p><h3 id="确认OpenWrt配置"><a href="#确认OpenWrt配置" class="headerlink" title="确认OpenWrt配置"></a>确认OpenWrt配置</h3><p>然后怀疑OpenWrt配置有问题，反复确认OpenWrt接口配置，防火墙配置。发现并没有问题，而且可以肯定：<strong>接口可以是桥接的接口，也可以是单独的接口</strong>；<strong>防火墙转发设置可以配置MASQ IP地址伪装，也可以不配置，不影响ping结果</strong>。</p><h3 id="新建测试机"><a href="#新建测试机" class="headerlink" title="新建测试机"></a>新建测试机</h3><p>这就很奇怪了，明明OpenWrt配置正确，也受到了包，死活不转发。这样排除了OpenWrt的问题，只能怀疑是VirtualBox的问题。</p><p>后来，我尝试新建一台win 10虚拟机，网络也是桥接模式，使用这台win10配置OpenWrt作为网关居然可以正常上网。在OpenWrt上抓包，也能抓到全部过程。</p><h3 id="比较win10和手机的包"><a href="#比较win10和手机的包" class="headerlink" title="比较win10和手机的包"></a>比较win10和手机的包</h3><p>按照之前的逻辑拓扑，如果添加了win10虚拟机，win10虚拟机 应该也是属于同一二层，不应该和手机有什么不一样的地方。但事实显示确实win10可以正常上网，手机不能。于是准备在OpenWrt上比较两个包，在OpenWrt上使用以下命令抓包并保存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 -w cap.cap</span><br></pre></td></tr></table></figure><p>在抓包期间，用手机和win10都发起对223.5.5.5的ping包。终于得到了很有趣的结果：</p><p>手机包</p><table><thead><tr><th>SMAC</th><th>DMAC</th><th>SIP</th><th>DIP</th></tr></thead><tbody><tr><td>BBBB.BBBB.BBBB</td><td><strong>AAAA.AAAA.AAAA</strong></td><td>192.168.3.101</td><td>223.5.5.5</td></tr></tbody></table><p>win10 ping包</p><table><thead><tr><th>SMAC</th><th>DMAC</th><th>SIP</th><th>DIP</th></tr></thead><tbody><tr><td>EEEE.EEEE.EEEE</td><td>CCCC.CCCC.CCCC</td><td>192.168.3.103</td><td>223.5.5.5</td></tr></tbody></table><p>很明显，win10的包是符合预期的；手机包源目ip符合预期，但MAC居然是笔记本的MAC。这有点搞糊涂了，颠覆了我对桥接的认知；这说明，<strong>手机请求OpenWrt 即192.168.3.2的MAC地址，收到的回复确是笔记本的MAC</strong>（后来使用另一台电脑做客户端验证了这一点，arp表项确实是这样显示的）。但这个现象确实反应了手机无法上网的本质原因，由于之前tcpdump抓包默认只显示ip地址，忽略了二层mac地址；看来问题就出在这里：<strong>手机包发过来的目的MAC是笔记本即宿主机，而win10虚拟机则为OpenWrt的MAC</strong></p><h3 id="手机ping-OpenWrt"><a href="#手机ping-OpenWrt" class="headerlink" title="手机ping OpenWrt"></a>手机ping OpenWrt</h3><p>既然是这样，那是不是手机ping OpenWrt 192.168.3.2也不通呢，尝试了一下，发现是通的。而手机ping OpenWrt时，OpenWrt收到的MAC却是自己并不是笔记本的MAC。这十有八九是VirtualBox如何处理桥接包的问题了。</p><h3 id="坑爹的VirualBox桥接机制"><a href="#坑爹的VirualBox桥接机制" class="headerlink" title="坑爹的VirualBox桥接机制"></a>坑爹的VirualBox桥接机制</h3><p>一切矛头指向VirutualBox，最后去查看VirutualBox文档，找到了<a href="https://www.virtualbox.org/manual/UserManual.html#network_bridged">官方对桥接的解释</a></p><p>原文是：</p><p>Note</p><p>Bridging to a wireless interface is done differently from bridging to a wired interface, because most wireless adapters do not support promiscuous mode. All traffic has to use the MAC address of the host’s wireless adapter, and therefore Oracle VM VirtualBox needs to replace the source MAC address in the Ethernet header of an outgoing packet to make sure the reply will be sent to the host interface. When Oracle VM VirtualBox sees an incoming packet with a destination IP address that belongs to one of the virtual machine adapters it replaces the destination MAC address in the Ethernet header with the VM adapter’s MAC address and passes it on. Oracle VM VirtualBox examines ARP and DHCP packets in order to learn the IP addresses of virtual machines.</p><p>翻译过来意思大概是</p><p>注意</p><p>桥接到一个无线网会和桥接到有线网卡有些不同，因为大多数无线适配器不支持混杂模式。所有流量都要使用主机的无线适配器的MAC地址，所以Oracle VirutualBox需要替换出去的以太头的源MAC地址来确保回复会被送到主机接口。<strong>当Oracle VirtualBox看到一个进来的包目的IP属于某个虚拟机的适配器时，它替换目的以太头MAC地址为VM虚拟机的适配器MAC地址并传到改虚拟机适配器</strong>。Oracle VirutualBox检查ARP和DHCP包以用来学习虚拟机的IP地址</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们一开始的预期在有线网卡的情况下都是对的，无线网卡不支持混杂模式，即不接受目的MAC不为自己的报文，所以就有上述官方文档转换MAC的机制。但这种机制<strong>只是转换目的IP为虚拟机的报文</strong>，我们由于使用虚拟机做转发，所以目的IP并不是虚拟机的IP，导致不通。<br>最后我们对目的地址不为自己时的处理方式做个总结：</p><p>对于一台主机（不运行虚拟机）来说：</p><ul><li><p>收到mac地址不为自己的包，都会直接丢弃；</p></li><li><p>收到IP地址不为自己但mac为自己的包，如果系统开启了ip转发功能则会转发此包，否则丢弃</p></li></ul><p>对于宿主机（桥接模式）来说</p><ul><li><p>收到mac或IP不为自己的包，交由虚拟机管理程序处理<br>无线网卡：</p><ul><li><p>若mac不为宿主机，则丢弃（无线网卡不支持混杂模式）</p></li><li><p>若IP不是任何一台虚拟机的IP，mac为宿主机IP，交由宿主机处理（但是抓包看的到，因为混杂模式可以监听到宿主机物理网卡的数据包）</p></li><li><p>若IP是其中某台虚拟机IP，mac为宿主机IP，转发到此虚拟机</p></li></ul><p>有线网卡（开启混杂模式）：</p><ul><li><p>若mac是宿主机，交由宿主机处理；</p></li><li><p>若mac不是任何一台虚拟机的mac，也不是宿主机mac，丢弃；</p></li><li><p>若mac是其中一台虚拟机的mac，转发到此虚拟机</p></li></ul></li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>将无线改为有线，完美解决。。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前几天心血来潮，想尝试下&lt;a href=&quot;https://arclogicr.github.io/2023/01/14/openwrt-ply/&quot;&gt;使用VirtualBox部署OpenWrt充当旁路由&lt;/a&gt;。在配完OpenWrt后，手机的流量死活没有办法被旁路由转发。当时</summary>
      
    
    
    
    <category term="疑难杂症" scheme="https://arclogicr.github.io/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    
    
    <category term="network" scheme="https://arclogicr.github.io/tags/network/"/>
    
    <category term="openwrt" scheme="https://arclogicr.github.io/tags/openwrt/"/>
    
    <category term="virtualbox" scheme="https://arclogicr.github.io/tags/virtualbox/"/>
    
  </entry>
  
  <entry>
    <title>使用VirtualBox部署OpenWrt充当旁路由</title>
    <link href="https://arclogicr.github.io/2023/01/14/openwrt-ply/"/>
    <id>https://arclogicr.github.io/2023/01/14/openwrt-ply/</id>
    <published>2023-01-14T13:17:08.000Z</published>
    <updated>2023-01-28T02:59:04.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景知识简介"><a href="#背景知识简介" class="headerlink" title="背景知识简介"></a>背景知识简介</h1><h2 id="Openwrt简介"><a href="#Openwrt简介" class="headerlink" title="Openwrt简介"></a>Openwrt简介</h2><h3 id="什么是Openwrt"><a href="#什么是Openwrt" class="headerlink" title="什么是Openwrt"></a>什么是Openwrt</h3><p>OpenWrt是一个嵌入式系统，为不同的嵌入式设备（通常是无线路由器）开发的可扩展的GNU&#x2F;Linux发行版。Openwrt最早是由Linksys公司的WRT-54G系统开源而来，后有DD-WRT，HyperWRT等发行版。Openwrt基于Linux内核，可以轻松的扩展所需要的功能。</p><h3 id="为什么使用Openwrt"><a href="#为什么使用Openwrt" class="headerlink" title="为什么使用Openwrt"></a>为什么使用Openwrt</h3><p>传统家用无线路由器自带的官方固件一般比较封闭，功能固定；OpenWrt系统相比之下比较开放，支持大量的Openwrt官方和非官方的软件包，也可自行开发功能。你甚至可以在OpenWrt上运行docker，极大地提升网络的可玩性和访问体验。另外，OpenWrt是开源的嵌入式Linux系统，支持多种设备和平台，如各式无线路由器、x86、ARM等。你可以自行定义OpenWrt运行的设备的平台和配置，而无需受限于传统路由器固有硬件。</p><h3 id="旁路网关简介"><a href="#旁路网关简介" class="headerlink" title="旁路网关简介"></a>旁路网关简介</h3><h4 id="什么是旁路网关"><a href="#什么是旁路网关" class="headerlink" title="什么是旁路网关"></a>什么是旁路网关</h4><p>旁路网关，俗称旁路由。顾名思义，旁路网关是在主路网关旁边的路由设备，起到辅助的路由和包处理的一些功能，通常旁路网关本身不具备直接访问Internet的能力。正常情况下，局域网内的终端通过主路由器访问Internet，主路由器的LAN口也是属于这个局域网的接口。当局域网中出现另一台路由器（比如OpenWrt）时，可以将其看作是旁路网关。在不对主路网关、旁路网关和终端设备做特殊操作的情况下，终端并不知道旁路网关的存在，流量还是正常走主路网关。可以通过配置让全部&#x2F;部分终端设备的全部&#x2F;部分流量经过旁路由。</p><p><img src="/2023/01/14/openwrt-ply/ply1.png" alt="OPWRT PLY1"></p><h4 id="为什么使用旁路网关"><a href="#为什么使用旁路网关" class="headerlink" title="为什么使用旁路网关"></a>为什么使用旁路网关</h4><p>旁路网关的本质是让终端设备的网络流量在转发到主路网关前经过自己，同时可以对这些流量进行一些特殊的处理。旁路网关的存在是为了弥补主路网关缺失的一些功能，同时又不想对网络拓扑结构做大的改动，或者根本无法改动。下面列举两个使用旁路网关的常见场景：</p><ul><li><p>我想在路由器上部署一些特殊的转发策略，只想让自己的终端设备可以按照这些策略转发，不想影响其它的终端设备</p></li><li><p>我想使用一些开源的服务，但有不想中断现有的网络而影响其他人</p></li></ul><h2 id="使用VirtualBox部署OpenWrt充当旁路网关"><a href="#使用VirtualBox部署OpenWrt充当旁路网关" class="headerlink" title="使用VirtualBox部署OpenWrt充当旁路网关"></a>使用VirtualBox部署OpenWrt充当旁路网关</h2><p>本次部署的目的是使用VBox虚拟机部署OpenWrt充当旁路由，然后再局域网内使用手机可以通过旁路由上网。网络拓扑如下：</p><p><img src="/2023/01/14/openwrt-ply/topo.png" alt="OPWRT TOPO"></p><h3 id="获取OpenWrt官方镜像"><a href="#获取OpenWrt官方镜像" class="headerlink" title="获取OpenWrt官方镜像"></a>获取OpenWrt官方镜像</h3><p>由于采用的是VBox虚拟机，我们需要x86架构64位的镜像文件。可以从官网下载<a href="https://downloads.openwrt.org/releases/22.03.3/targets/x86/64/">Index of &#x2F;releases&#x2F;22.03.3&#x2F;targets&#x2F;x86&#x2F;64&#x2F;</a></p><p>这里有很多包，其中包含squashfs字样的是可以通过命令恢复成初始配置的镜像，适合于不喜欢折腾的童鞋。这里我选择了generic-ext4-combined.img.gz这个镜像，版本为22.03.3，解压后获得openwrt22.03.3-x86-64-generic-ext4-combined.img这个文件。</p><h3 id="将img转换为VirtualBox支持的虚拟硬盘格式"><a href="#将img转换为VirtualBox支持的虚拟硬盘格式" class="headerlink" title="将img转换为VirtualBox支持的虚拟硬盘格式"></a>将img转换为VirtualBox支持的虚拟硬盘格式</h3><p>如果你想要安装在硬件软路由上，你需要用img文件通过启动盘制作工具制作启动U盘；这里由于是虚拟机运行，只需转换为VBox支持的虚拟硬盘格式。可以使用VBox自带工具，在cmd控制台VBox安装目录中，使用如下命令转换：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VBoxManage convertdd openwrt22.03.3-x86-64-generic-ext4-combined.img openwrt.vdi</span><br></pre></td></tr></table></figure><h3 id="创建VirtualBox虚拟机"><a href="#创建VirtualBox虚拟机" class="headerlink" title="创建VirtualBox虚拟机"></a>创建VirtualBox虚拟机</h3><p>在VBox中创建虚拟机。</p><p><img src="/2023/01/14/openwrt-ply/vm1.png" alt="OPWRT VM1"></p><p><img src="/2023/01/14/openwrt-ply/vm2.png" alt="OPWRT VM2"></p><p>其中，</p><p>操作系统可以选择Linux，Other Linux 64bits</p><p>CPU和内存分配为1C 1G即可</p><p>硬盘需要选择我们刚刚转换好的vdi格式的虚拟硬盘</p><h3 id="配置VirtualBox虚拟机网络"><a href="#配置VirtualBox虚拟机网络" class="headerlink" title="配置VirtualBox虚拟机网络"></a>配置VirtualBox虚拟机网络</h3><p>由于我们将OpenWrt用作旁路由，我们只需要一个接口即可。在刚生成的虚拟机中选择设置网络，网络模式选择桥接，<strong>并且必须桥接到有线网卡，宿主机（电脑）也必须有线连接路由器</strong>（因为VBox的桥接机制问题），开启混杂模式。开启混杂模式的原因是让宿主机（电脑）的网卡接受目的地址不为宿主机（而是虚拟机）的数据包。</p><p><img src="/2023/01/14/openwrt-ply/vm3.png" alt="OPWRT VM3"></p><h3 id="配置OpenWrt"><a href="#配置OpenWrt" class="headerlink" title="配置OpenWrt"></a>配置OpenWrt</h3><p>配置完网络之后，我们可以开启虚拟机了。但开启虚拟机之前最好在虚拟机网络设置中去掉“接入网线”选项，勾掉这个选项虚拟机暂时不会连接到任何网路，这样的目的是为了阻止OpenWrt回应终端的DHCP请求而分配了192.168.1.0的地址。</p><h4 id="修改OpenWrt管理地址"><a href="#修改OpenWrt管理地址" class="headerlink" title="修改OpenWrt管理地址"></a>修改OpenWrt管理地址</h4><p>开机后，在虚拟机控制按下回车就可以输入命令了。Openwrt默认lan口是192.168.1.1&#x2F;24的地址，默认网卡名为br-lan我们先把lan口地址改为当前局域网的空地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig br-lan 192.168.3.100</span><br></pre></td></tr></table></figure><p>不需要输入掩码，掩码默认24位</p><p>修改ip地址后就可以通过192.168.3.100来访问web界面了（如果取消了接入网线，需要把哪个勾勾起来）</p><h4 id="关闭OpenWrt的DHCP功能"><a href="#关闭OpenWrt的DHCP功能" class="headerlink" title="关闭OpenWrt的DHCP功能"></a>关闭OpenWrt的DHCP功能</h4><p>进入web界面后第一步先把LAN口的dhcp关了，我们不需要旁路网关分配ip地址。</p><p>在Network-Interface下找到br-lan这个网卡，在edit-DHCP server里面选择ignore this interface。记得点save &amp; apply生效。</p><p><img src="/2023/01/14/openwrt-ply/op1.png" alt="OPWRT OP1"></p><p>然后可以修改个root密码，新版本OpenWrt不改默认密码会有提示。</p><h4 id="配置新接口"><a href="#配置新接口" class="headerlink" title="配置新接口"></a>配置新接口</h4><p>由于OpenWrt默认接口时桥接接口，我们不需要桥接（当然使用桥接也可以）。删除原有br-lan接口，然后新建接口add new interface，协议为static address，物理接口选择eth0。</p><p><img src="/2023/01/14/openwrt-ply/op2.png" alt="OPWRT OP2"></p><p>然后配置IP和子网掩码配置为和原来一样192.168.3.100，网关配置为主路由器地址，比如192.168.3.1</p><h4 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h4><p>新街口配置完成后，此时OpenWrt和一般的终端一样应该可以访问Internet了。在System-Software中更新lists。更新后可以在filter搜索官方软件包们这里可以安装中文包luci-i18n-base-zh-cn 和tcpdump抓包。其它官方包都可以在这个界面安装，非官方包需要下载ipk文件手动opkg install来安装</p><h4 id="配置OpenWrt防火墙"><a href="#配置OpenWrt防火墙" class="headerlink" title="配置OpenWrt防火墙"></a>配置OpenWrt防火墙</h4><p>防火墙的策略应该是仅有的LAN口出、入、转发应当全部放通，最好使用IP地址动态装（MASQUERADING）</p><p>首先删除其它区域的策略，只留下Lan区域，然后修改Lan区域配置如下，</p><p><img src="/2023/01/14/openwrt-ply/op3.png" alt="OPWRT OP3"></p><p>注意需要绑定接口eth0，另外上面默认的FORWARD策略是reject，无需修改。</p><p>然后将Lan的出、入、转发全部放通，勾选MASQUERADING</p><p><img src="/2023/01/14/openwrt-ply/op4.png" alt="OPWRT OP4"></p><p>其中，</p><p>需要勾选FOWARD策略</p><p>勾选MASQUERADING后，旁路网关会将终端的IP以PAT的形式转换为旁路网关的IP，这样可以保证上下行路径一致，避免未知问题。如果不勾选，旁路网关只做转发不做PAT，那么终端流量上行走的是旁路网关，下行主路由直接回复。</p><h3 id="修改终端设备网关"><a href="#修改终端设备网关" class="headerlink" title="修改终端设备网关"></a>修改终端设备网关</h3><p>将手机的网关和DNS设置为OpenWrt地址，即可通过OpenWrt上网。如果想要所有终端都可以通过旁路网关上网，可以修改主路由器的DHCP设置，令dhcp下发默认网关改为OpenWrt的IP地址。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景知识简介&quot;&gt;&lt;a href=&quot;#背景知识简介&quot; class=&quot;headerlink&quot; title=&quot;背景知识简介&quot;&gt;&lt;/a&gt;背景知识简介&lt;/h1&gt;&lt;h2 id=&quot;Openwrt简介&quot;&gt;&lt;a href=&quot;#Openwrt简介&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="疑难杂症" scheme="https://arclogicr.github.io/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    
    
    <category term="network" scheme="https://arclogicr.github.io/tags/network/"/>
    
    <category term="openwrt" scheme="https://arclogicr.github.io/tags/openwrt/"/>
    
    <category term="virtualbox" scheme="https://arclogicr.github.io/tags/virtualbox/"/>
    
  </entry>
  
  <entry>
    <title>OpenWrt防火墙翻译</title>
    <link href="https://arclogicr.github.io/2023/01/12/openwrt-fw1/"/>
    <id>https://arclogicr.github.io/2023/01/12/openwrt-fw1/</id>
    <published>2023-01-12T10:34:55.000Z</published>
    <updated>2023-01-20T03:25:31.879Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Firewall-and-network-interfaces"><a href="#Firewall-and-network-interfaces" class="headerlink" title="Firewall and network interfaces"></a>Firewall and network interfaces</h4><p>The goal of a router is to forward packet streams from incoming network interfaces to outgoing network interfaces. Firewall rules add another layer of granularity to what is allowed to be forwarded across interfaces - and additionally which packets are allowed to be inputted to, and outputted from, the router itself. This section discusses the relationships between the firewall code and the network interfaces.</p><p>At the heart of all routers is a hardware switch with a number of interface ports. When a packet enters one of the switch ports, the hardware switch matches a fixed field in the packet and forwards the packet to an output port which transmits it.</p><h4 id="防火墙和网络接口"><a href="#防火墙和网络接口" class="headerlink" title="防火墙和网络接口"></a>防火墙和网络接口</h4><p>路由器的目标是从入向网络接口到出向网络接口转发分组流。防火墙规则增加了另一个层面的粒度；即，什么分组可以跨接口转发，还有哪些分组可以被允许进入和离开该路由器。本章讨论防火墙代码和网络接口之间的关系。</p><p>所有路由器的核心就是一个带有一些端口硬件交换机。当一个分组进入其中一个交换端口，硬件交换机匹配该分组内固定的字段并转发到一个可传输它的出接口。</p><p>The switch generally uses the layer-2 destination MAC address in the packet to switch on. Each port has a cache of MAC addresses for stations reachable by (attached to) that port. Entries in the MAC cache gradually out, so must be re-discovered if used again. Layer-2 frames with a known destination MAC are switched to the desired LAN port. If the MAC is not present anywhere in the switch cache, a broadcast packet (e.g. ARP) is flooded to all LAN ports to discover which has access to the destination MAC.</p><p>交换机通常使用分组中的二层目的MAC地址进行分组交换。每个端口都有一个MAC地址缓存表记录与它可达的（直连的）站点。MAC缓存条目会逐渐消失，所以必须重新发现，如果要被使用的话。已知目的MAC的二层帧被交换到期待的LAN口。如果MAC在交换机缓存中不存在，则一个广播包（如ARP）会被泛洪到所有的LAN口用来发现哪个口接着该目的MAC。</p><p>OpenWrt routers have two types of LAN interface: wired Ethernet (IEEE802.3 or RFC894 Ethernet II, Ethernet II being the most common) and wireless Ethernet (IEEE802.11.)</p><p>The wired LAN ports each map directly to a single switch port. Generally there is one 802.11 Wi-Fi port attached to a Wi-Fi radio chip (2.4Ghz, 5Ghz). Each handles one or more IEEE802.11 standard protocols (e.g. 802.11a, 802.11n) and ancillary support for wireless networks (e.g. 802.11s mesh networking). The Wi-Fi chips convert the 802.11 signal into a canonical ethernet frame injected into the switch port for routing. All Wi-Fi stations connected to the 802.11 Access Point use the same radio(s) and the same switch port.</p><p>OpenWrt路由器有两种LAN接口：有线以太网（IEEE802.3 或RFC894 EthernetII，EthernetII是最常见的）和无线以太网（IEEE802.11）。</p><p>每个有线LAN端口直接对应一个单独的交换口。通常有一个802.11Wi-Fi口附在一个Wi-Fi无线电芯片（2.4Ghz，5Ghz）。每个处理一个或多个IEEE802.11标准协议（如802.11a，802.11n）和对无线网络的附加支持（如802.11s mesh网络）。WiFi芯片将802.11信号转换到一个添加到交换端口来进行路由的典型以太网帧。所有连接到802.11无线接入点的Wi-Fi站点使用相同的无线电接收器在相同的交换端口。</p><h4 id="LAN-bridge"><a href="#LAN-bridge" class="headerlink" title="LAN bridge"></a>LAN bridge</h4><p>The LAN bridge combines the WLAN interface(s) with the wired LAN ports to create a single logical network. In the interface configuration set option type bridge or in LuCI Network→Interfaces→LAN Bridge interfaces box and select the physical interfaces to bridge together. All switch ports in the bridge will act as a single network.</p><p>The new pseudo-interface has a br- prepended to the interface name, generally br-lan.<br>Use bridging when combining WLAN and wired Ethernet ports. Otherwise partition the ports into VLANs.</p><h4 id="局域网网桥"><a href="#局域网网桥" class="headerlink" title="局域网网桥"></a>局域网网桥</h4><p>LAN网桥组合WLAN接口和有线LAN接口用来创建一个单独的逻辑网络。在‘interface’配置中设置‘option type bridge’或LuCI中’Network’-‘Interfaces’-‘LAN网桥接口’选项并选择需要桥接在一起的物理接口。所有网桥中的交换端口将成为一个单独的网络。</p><p>新的伪端口有一个’br-‘在接口名字前，通常为’br-lan’。</p><p>当组合WLAN和有线以太网时使用桥接。否则应使用VLAN分割端口。</p><h4 id="Firewall-Zones"><a href="#Firewall-Zones" class="headerlink" title="Firewall Zones"></a>Firewall Zones</h4><p>The firewall of an OpenWrt router is able to collect interfaces into zones to more logically filter traffic. A zone can be configured to any set of interfaces but generally there are at least two zones: lan for the collection of LAN interfaces and wan for the WAN interfaces.</p><p>This simplifies the firewall rule logic somewhat by conceptually grouping the interfaces:</p><p>A rule for a packet originating in a zone must be entering the router on one of the zone’s interfaces,<br>A rule for a packet being forwarded to a zone must be exiting the router on one of the zone’s interfaces.<br>recognize the zone concept does not significantly simplify a simple SOHO router with a single br-lan interface and a single wan interface. Each interface has a one-to-one mapping with a zone.</p><h4 id="防火墙区域"><a href="#防火墙区域" class="headerlink" title="防火墙区域"></a>防火墙区域</h4><p>OpenWrt路由器上的防火墙能够帮接口集中在区域中用来更逻辑化地过滤流量。一个区域可以被配置到任何一个接口组但通常至少有两个区域：lan用来集中LAN接口，wan用来集中WAN接口。</p><p>通过概念上给接口分组某种程度上简化了防火墙的规则逻辑：</p><p>源于一个区域的数据包的规则是必须在路由器该区域的一个接口进入</p><p>被转发到一个区域的分组的规则是必须在路由器该区域的一个接口离开</p><p>注意区域的概念不能显著简化一个简单的SOHO路由器通过单独的br-lan接口和单独的wan接口。每个接口都有一个1对1映射的区域。</p><h3 id="Firewall-components"><a href="#Firewall-components" class="headerlink" title="Firewall components"></a>Firewall components</h3><p>The OpenWrt firewall implementation is the mechanism by which network traffic is filtered coming through the router. At a high level, one of three outcomes will occur: either the packet is discarded (dropped) without any further action, rejected (with an appropriate response to the source), or accepted (routed to the destination). Note that the router itself is a destination for management and monitoring.</p><p>The OpenWrt firewall revolves around the Linux netfilter project. There are the following main components to the OpenWrt firewall:</p><p>the firewall3 application<br>a set of netfilter hooks in the kernel networking stacks<br>a set of linux kernel modules that handle the inspection of network packets<br>a set of kernel tuning parameters to configure the network stacks and firewall modules<br>This documentation is based on OpenWrt 18.06.0. Many of the configurations have been tested against this release using the test network</p><h4 id="Firewall3-fw3"><a href="#Firewall3-fw3" class="headerlink" title="Firewall3 (fw3)"></a>Firewall3 (fw3)</h4><p>The fw3 application package is the main application used to provision the firewall. It was developed by the OpenWrt team specifically for the project.</p><h3 id="防火墙组成"><a href="#防火墙组成" class="headerlink" title="防火墙组成"></a>防火墙组成</h3><p>OpenWrt防火墙的运行机制就是过滤通过路由器的网络流量。在更高的层面上，三个当中的一个结果将会发生：分组要么被丢弃而没有任何进一步操作，要么被拒绝（对源有适当的响应），要么被接受（路由到目的地）。注意路由器本身是一个管理和监控的目的地。</p><h4 id="fw3"><a href="#fw3" class="headerlink" title="fw3"></a>fw3</h4><p>fw3应用包是主要的用来置备（prov团ision）防火墙的应用。它由OpenWrt团队为这个项目特别开发。</p><h4 id="Kernel-netfilter-hooks"><a href="#Kernel-netfilter-hooks" class="headerlink" title="Kernel netfilter hooks"></a>Kernel netfilter hooks</h4><p>Each of the network stacks have netfilter functions call hooks embedded at specific places in the code. As a network packet moves through the stack, each hook is called to check the packet against possible netfilter rules bound to the hook.</p><p>The netfilter hook code uses the NF_HOOK set of macros. Each hook takes the following arguments:</p><ul><li><p>network protocol: unspec (all), ipv4, ipv6, arp, bridge, decnet</p></li><li><p>hook num: PRE_ROUTING, LOCAL_IN, FORWARD, LOCAL_OUT, POST_ROUTING</p></li><li><p>net structure: context for the network stack</p></li><li><p>socket: BSD socket used for packet</p></li><li><p>network packet: a socket buffer containing the network packet</p></li><li><p>incoming device (interface): the source of the packet</p></li><li><p>outgoing device (interface): the destination of the packet after routing</p></li><li><p>a function callback if the packet passes the filter</p></li></ul><h3 id="内核netfilter-hooks"><a href="#内核netfilter-hooks" class="headerlink" title="内核netfilter hooks"></a>内核netfilter hooks</h3><p>每个网络栈都有一个netfilter功能嵌入在代码中的某个特殊地方。当一个网络分组在堆栈中移动时，每个hook会被调用来根据绑定到狗子的可能的netfilter规则检查分组。</p><p>Netfilter hook代码使用NF_HOOK宏组。每个hook采用以下参数：</p><ul><li><p>network protocol: unspec (all), ipv4, ipv6, arp, bridge, decnet</p></li><li><p>hook num: PRE_ROUTING, LOCAL_IN, FORWARD, LOCAL_OUT, POST_ROUTING</p></li><li><p>net structure: 网络栈的环境</p></li><li><p>socket: 为分组使用的BSD套接字</p></li><li><p>network packet: 一个包含分组的套接字缓存</p></li><li><p>incoming device (interface): 分组源</p></li><li><p>outgoing device (interface): 分组路由后的目的r</p></li><li><p>回调函数，如果分组通过过滤器</p></li></ul><h4 id="Kernel-netfilter-modules"><a href="#Kernel-netfilter-modules" class="headerlink" title="Kernel netfilter modules"></a>Kernel netfilter modules</h4><p>The netfilter kernel modules are loaded at boot depend on the configured. There are roughly 35 kernel modules to support the standard netfilter capabilities but there are many more depending on the requirements of the router. For example, many routers use the ipset feature. This adds ~16 additional kernel modules.</p><p>Most of the netfilter modules are small, providing a single specific capability. For example:</p><ul><li><p>ipt_REJECT performs REJECT (target),</p></li><li><p>xt_multiport performs match of the IP port (match)</p></li><li><p>xt_TCPMSS performs Maximum Segment Size adjustment in the TCP header (target in mangle table)</p><p>Several of the netfilter modules are larger. For example:</p></li><li><p>nf_conntrack performs connection tracking for masquerading (NAT) and packet de-fragmentation.</p></li></ul><h4 id="Kernel-tuning-via-sysctl"><a href="#Kernel-tuning-via-sysctl" class="headerlink" title="Kernel tuning via sysctl"></a>Kernel tuning via sysctl</h4><p>&#x2F;etc&#x2F;init.d&#x2F;sysctl is executed at boot time. This is a shell script that loads &#x2F;etc&#x2F;sysctl.conf and all files under &#x2F;etc&#x2F;sysctl.d&#x2F;. These set&#x2F;tune kernel parameters to provide OpenWrt features. See sysctl.conf.</p><p>All are parameters documented under the Documentation&#x2F;networking directory of kernel source tree so the specifics will not be repeated here. See ip-sysctl.txt and nf_conntrack-sysctl.txt for reference.</p><p>Since the OpenWrt feature set is fairly static, the kernel parameters almost certainly do not need to tuned beyond the defaults provided in the build.</p><p>Notice that netfilter bridging support in the kernel is disabled! See ip-sysctl.txt:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bridge-nf-call-iptables - BOOLEAN</span><br><span class="line"> 1 : pass bridged IPv4 traffic to iptables&#x27; chains.</span><br><span class="line"> 0 : disable this.</span><br><span class="line"> Default: 1</span><br></pre></td></tr></table></figure><h4 id="内核netfilter模块"><a href="#内核netfilter模块" class="headerlink" title="内核netfilter模块"></a>内核netfilter模块</h4><p>netfilter内核模块按照配置在启动时被加载。有大概35个内核模块支持标准网络过滤能力，但是有很多更取决于路由器的条件。比如，很多路由器使用ipset功能。这增加了~16个额外内核模块。</p><p>大多数的netfilter模块比较小，提供一个单独而特殊的能力。例如：</p><ul><li><p>ipt_REJECT — REJECT (target),</p></li><li><p>xt_multiport — match of the IP port (match)</p></li><li><p>xt_TCPMSS — Maximum Segment Size adjustment in the TCP header (target in mangle table)</p></li></ul><p>有几个netfilter模块很大。例如：</p><ul><li>nf_conntrack — connection tracking for masquerading (NAT) and packet de-fragmentation.</li></ul><h4 id="内核调节通过sysctl"><a href="#内核调节通过sysctl" class="headerlink" title="内核调节通过sysctl"></a>内核调节通过sysctl</h4><p>&#x2F;etc&#x2F;init.d&#x2F;sysctl在启动时执行。这是一个shell脚本来载入&#x2F;etc&#x2F;sysctl.conf和在&#x2F;etc&#x2F;sysctl.d&#x2F;下的所有文件。这些设置&#x2F;调整内核参数提供了OpenWrt的功能。参见sysctl.conf。</p><p>所有都是在内核源码树的Documentation&#x2F;networking目录下记录的参数，这里不再赘述。 请参阅 ip-sysctl.txt 和 nf_conntrack-sysctl.txt 以供参考。</p><p>既然OpenWrt功能集合是比较静态的，内核参数几乎不需要调整到超出构建时的默认值。</p><p>注意netfilter桥接支持在内核中是关闭的！参见ip-sysctl.txt：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bridge-nf-call-iptables - BOOLEAN</span><br><span class="line"> 1 : pass bridged IPv4 traffic to iptables&#x27; chains.</span><br><span class="line"> 0 : disable this.</span><br><span class="line"> Default: 1</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;Firewall-and-network-interfaces&quot;&gt;&lt;a href=&quot;#Firewall-and-network-interfaces&quot; class=&quot;headerlink&quot; title=&quot;Firewall and network interface</summary>
      
    
    
    
    <category term="文档翻译" scheme="https://arclogicr.github.io/categories/%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="network" scheme="https://arclogicr.github.io/tags/network/"/>
    
    <category term="firewall" scheme="https://arclogicr.github.io/tags/firewall/"/>
    
    <category term="openwrt" scheme="https://arclogicr.github.io/tags/openwrt/"/>
    
    <category term="translation" scheme="https://arclogicr.github.io/tags/translation/"/>
    
  </entry>
  
  <entry>
    <title>kvm如何禁止虚拟机之间通信</title>
    <link href="https://arclogicr.github.io/2023/01/04/kvmq1/"/>
    <id>https://arclogicr.github.io/2023/01/04/kvmq1/</id>
    <published>2023-01-04T07:37:05.000Z</published>
    <updated>2023-01-12T10:34:27.808Z</updated>
    
    <content type="html"><![CDATA[<p>一般来说，使用KVM创建虚拟机，都会有虚拟机之间通信的需求，KVM的四种网络模式也都默认允许同一网段的虚拟机之间互通。如果有特殊需求，需要禁止虚拟机之间的通信，该如何配置？</p><h3 id="KVM四种网络模式"><a href="#KVM四种网络模式" class="headerlink" title="KVM四种网络模式"></a>KVM四种网络模式</h3><ul><li><p>首先隔离模式，相当于Vmware&#x2F;Vbox 仅主机模式，VM之间可通信，VM与宿主可通信，VM与外部不可通信</p></li><li><p>NAT模式，VM之间可通信，VM与宿主可通信，VM可访问外部，外部访问VM需要做端口转发</p></li><li><p>桥接模式，VM之间可通信，VM与宿主可通信，VM可访问外部，外部可访问VM。一般桥接模式下VM网段与宿主机同段。</p></li><li><p>路由模式，VM之间可通信，VM与宿主可通信，VM可访问外部，外部可访问VM。路由模式下VM网段可以与宿主机不同端，外部需要配置路由才能访问VM</p></li></ul><h3 id="iptables解决方案"><a href="#iptables解决方案" class="headerlink" title="iptables解决方案"></a>iptables解决方案</h3><p>搜了资料，有人说可以用iptables实现，原理如下</p><p>NAT模式下，宿主机有一块网卡virbr0。针对virbr0，在iptables中FORWARD链限制同网段互访</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A FORWARD -i virbr0 -s 192.168.1.0/24 -d 192.168.1.0/24 -j DROP</span><br></pre></td></tr></table></figure><p>我尝试了下，不知为何不生效，也许因为虚拟机互访实际流量并不经过virbr0？尝试将FORWARD链改为INPUT链也是不生效。后来放弃iptables，改用nwfilter。</p><h3 id="nwfilter解决方案"><a href="#nwfilter解决方案" class="headerlink" title="nwfilter解决方案"></a>nwfilter解决方案</h3><p>nwfilter是kvm自带的网络流量工具，可以精确控制每一块vm网卡。上面iptables的方案是在宿主机上做策略，而nwfilter是对每一个vm做策略，nwfilter的策略可以应用在多个vm上。</p><p>总的来说nwfilter的用法就是，定义nwfilter策略，生效策略，应用策略。下面以NAT模式下禁止虚拟机之间互通为例介绍nwfilter解决方案</p><h4 id="定义策略"><a href="#定义策略" class="headerlink" title="定义策略"></a>定义策略</h4><p>在&#x2F;etc&#x2F;libvirt&#x2F;nwfilter下建立xml文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/libvir/nwfilter/deny-inter.xml</span><br></pre></td></tr></table></figure><p>写入规则</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter name=&#x27;deny-inter&#x27; chain=&#x27;ipv4&#x27; priority=&#x27;-700&#x27;&gt;</span><br><span class="line">  &lt;uuid&gt;ab4b9613-3442-41af-a4b3-0a3bdaae7111&lt;/uuid&gt;</span><br><span class="line">  &lt;rule action=&#x27;accept&#x27; direction=&#x27;in&#x27; priority=&#x27;200&#x27;&gt;</span><br><span class="line">    &lt;ip srcipaddr=&#x27;192.168.122.1&#x27; srcipmask=&#x27;32&#x27;/&gt;</span><br><span class="line">  &lt;/rule&gt;</span><br><span class="line">  &lt;rule action=&#x27;drop&#x27; direction=&#x27;in&#x27; priority=&#x27;201&#x27;&gt;</span><br><span class="line">    &lt;ip srcipaddr=&#x27;192.168.122.0&#x27; srcipmask=&#x27;24&#x27;/&gt;</span><br><span class="line">  &lt;/rule&gt;</span><br><span class="line">&lt;/filter&gt;</span><br></pre></td></tr></table></figure><p>其中，</p><p>这里只采用了ipv4的链，只需要对ip包进行过滤</p><p>注意uuid不要与现有的相同</p><p>每条规则后的优先级越小越优，如果优先级相同优先匹配前面的规则</p><p>这里的规则将来是应用在虚拟机上，所以in&#x2F;out是针对虚拟机网卡的</p><p>第一条规则是为了保证dhcp正常工作，这里用in方向策略会方便一点，因为dhcp discover包发出去是广播，dhcp offer包回来是单播，in方向只需要允许宿主机的单播包就可以了</p><p>更多nwfilter的详细用法可以参考<a href="https://wiki.libvirt.org/page/VirtualNetworking">VirtualNetworking - Libvirt Wiki</a></p><h4 id="生效策略"><a href="#生效策略" class="headerlink" title="生效策略"></a>生效策略</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">virsh nwfilter-define deny-inter.xml #生效策略</span><br><span class="line">virsh nwfilter-list #查看是否生效</span><br></pre></td></tr></table></figure><h4 id="应用策略"><a href="#应用策略" class="headerlink" title="应用策略"></a>应用策略</h4><p>编辑虚拟机配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virsh edit vm01</span><br></pre></td></tr></table></figure><p>找到<interface type>添加定义过的策略</interface></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;interface type=&#x27;network&#x27;&gt;</span><br><span class="line">  &lt;mac address=&#x27;52:54:00:ec:f5:4e&#x27;/&gt;</span><br><span class="line">  &lt;source network=&#x27;default&#x27;/&gt;</span><br><span class="line">  &lt;model type=&#x27;e1000&#x27;/&gt;</span><br><span class="line">  &lt;filterref filter=&#x27;deny-inter&#x27;/&gt; #ADD POLICY</span><br><span class="line">  &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x03&#x27; function=&#x27;0x0&#x27;/&gt;</span><br></pre></td></tr></table></figure><p>最后重启虚拟机，VM之间无法ping通，VM与宿主机可通，VM ping 外面可通。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一般来说，使用KVM创建虚拟机，都会有虚拟机之间通信的需求，KVM的四种网络模式也都默认允许同一网段的虚拟机之间互通。如果有特殊需求，需要禁止虚拟机之间的通信，该如何配置？&lt;/p&gt;
&lt;h3 id=&quot;KVM四种网络模式&quot;&gt;&lt;a href=&quot;#KVM四种网络模式&quot; class=</summary>
      
    
    
    
    <category term="疑难杂症" scheme="https://arclogicr.github.io/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    
    
    <category term="network" scheme="https://arclogicr.github.io/tags/network/"/>
    
    <category term="kvm" scheme="https://arclogicr.github.io/tags/kvm/"/>
    
  </entry>
  
  <entry>
    <title>使用pushgateway监控需要上传文件的应用接口</title>
    <link href="https://arclogicr.github.io/2022/12/09/pushgateway/"/>
    <id>https://arclogicr.github.io/2022/12/09/pushgateway/</id>
    <published>2022-12-09T15:10:18.000Z</published>
    <updated>2023-01-28T03:03:03.209Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景简介"><a href="#背景简介" class="headerlink" title="背景简介"></a>背景简介</h1><h2 id="什么是Promethues"><a href="#什么是Promethues" class="headerlink" title="什么是Promethues"></a>什么是Promethues</h2><p>prometheus是一套开源的监控系统，可以非常全面地监测硬件服务器、存储、网络、API等监控对象。prometheus主要采用pull模式，即，prometheus服务器通过http get请求来获取各个监控对象的监控数据。当然，各监控对象需要安装相应的node expoter客户端。此外，由于一些特殊的监控和自定义监控，prometheus也提供了blackbox expoter黑盒监控和pushgateway等更灵活的获取监控数据的方式。</p><p><img src="/2022/12/09/pushgateway/prometheus_architecture.png" alt="PUSHGW TOPO"></p><h2 id="什么是pushgateway"><a href="#什么是pushgateway" class="headerlink" title="什么是pushgateway"></a>什么是pushgateway</h2><p>pushgateway是prometheus监控系统中的一个可选组成部分。它类似于一个反向代理，Prometheus正常从pushgateway拉取监控数据，pushgateway的数据来自于用户自定义的metric，用户将这些metric push到pushgateway，即自定义脚本推送的数据。</p><h2 id="为什么使用pushgateway"><a href="#为什么使用pushgateway" class="headerlink" title="为什么使用pushgateway"></a>为什么使用pushgateway</h2><p>通常pushgateway用于解决网络与Prometheus不通的区域充当代理的角色，也可以实现一些自定义的metrics。</p><h2 id="pushgateway与blackbox有什么不同"><a href="#pushgateway与blackbox有什么不同" class="headerlink" title="pushgateway与blackbox有什么不同"></a>pushgateway与blackbox有什么不同</h2><p>blackbox expoter也是prometheus重要组成部分，blackbox exporter主要的功能是接口监控，内置了很多icmp，tcp，http等监控模板。black expoter可以满足大部分api监控需求，但一些复杂参数的api监控并没有办法实现。另外blackbox也能充当代理的角色，这点和pushgateway是相似的。但pushgateway内置api接口支持用户自定义的metrics，这是blackbox exporter做不到的。</p><h1 id="使用pushgateway监控需要上传文件的接口"><a href="#使用pushgateway监控需要上传文件的接口" class="headerlink" title="使用pushgateway监控需要上传文件的接口"></a>使用pushgateway监控需要上传文件的接口</h1><h2 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h2><p>需求是需要对一批接口进行http状态码监控，这批接口要求指定header参数，另外必须上传图片</p><p>根据需求首先想到的是blackbox，添加监控比较方便，有现成模板，但是由于接口需要上传文件，查了官网资料，没有发现blackbox exporter内模板支持post请求文件上传，于是只能使用pushgateway</p><h2 id="获取监控数据"><a href="#获取监控数据" class="headerlink" title="获取监控数据"></a>获取监控数据</h2><p>我们需要把监控到的数据发给pushgateway，监控数据是post请求的状态码，使用以下脚本实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#定义api路径和请求头host参数</span><br><span class="line">path=(&#x27;https://192.168.0.1/some/path1&#x27; &#x27;https://192.168.0.1/some/path2&#x27; &#x27;https://192.168.0.1/some/path3&#x27;)</span><br><span class="line">host=(&#x27;host1&#x27; &#x27;host2&#x27; &#x27;host3&#x27; )</span><br><span class="line"></span><br><span class="line">for (( i = 0; i &lt; $&#123;#host[@]&#125;; ++i ))</span><br><span class="line">  do</span><br><span class="line">         #获取请求结果</span><br><span class="line">         result=`curl -s -w &#x27;%&#123;http_code&#125;\n&#x27; -o /dev/null  --data-binary @/opt/pic.jpg  --connect-timeout 5 -H &quot;host: $&#123;host[i]&#125;&quot; $&#123;path[i]&#125;`</span><br><span class="line">         if [ -z &quot;$result&quot; ]</span><br><span class="line">         then </span><br><span class="line">           value_code=0 </span><br><span class="line">         else</span><br><span class="line">           value_code=$(echo $result)  </span><br><span class="line">         #将结果发给pushgateway（本地）</span><br><span class="line">         echo &quot;somejob_http_code $&#123;value_code&#125;&quot; | curl --data-binary @- http://localhost:9091/metrics/job/somejob/instance/192.168.0.1/hostname/$&#123;host[i]&#125;</span><br><span class="line">         fi</span><br><span class="line">         echo  $&#123;host[i]&#125;&quot;===&quot;$&#123;path[i]&#125;&quot;===&quot;$value_code</span><br><span class="line">  done</span><br></pre></td></tr></table></figure><p>其中，</p><p>上传文件的路径需要以绝对路径引用，因为这个脚本将来是要被crontab执行的，工作目录并不是脚本所在目录</p><p>另外，可以先把push数据那句话注释掉验证请求结果</p><h2 id="添加crontab任务"><a href="#添加crontab任务" class="headerlink" title="添加crontab任务"></a>添加crontab任务</h2><p>无误后，使用crontab定时45s执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#打开crontab配置文件</span><br><span class="line">sudo crontab -e</span><br><span class="line"></span><br><span class="line">#添加定时任务</span><br><span class="line">* * * * * sleep 45; bash /opt/shell.sh &gt; /dev/null 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line">#验证定时任务是否成功添加</span><br><span class="line">sudo crontab -l</span><br></pre></td></tr></table></figure><p>定时任务配置完成后，pushgateway就会周期性收到监控数据并更新了，如果prometheus 已经有pushgateway的job的话，就可以查到metrics了</p><h2 id="配置prometheus-yml"><a href="#配置prometheus-yml" class="headerlink" title="配置prometheus.yml"></a>配置prometheus.yml</h2><p>如果prometheus没有集成pushgateway，则需要在prometheus.yml添加如下job并重载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- job_name: &#x27;pushgateway&#x27;</span><br><span class="line">  scrape_interval: 45s</span><br><span class="line">  honor_labels: true</span><br><span class="line">  static_configs:</span><br><span class="line">    - targets: [&#x27;1.1.1.1:9091&#x27;]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#prometheus热重载</span><br><span class="line">curl -X POST http://127.0.0.1:9090/-/reload</span><br></pre></td></tr></table></figure><p>重载后可在prometheus查询到新的metrics</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">somejob_http_code&#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景简介&quot;&gt;&lt;a href=&quot;#背景简介&quot; class=&quot;headerlink&quot; title=&quot;背景简介&quot;&gt;&lt;/a&gt;背景简介&lt;/h1&gt;&lt;h2 id=&quot;什么是Promethues&quot;&gt;&lt;a href=&quot;#什么是Promethues&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="疑难杂症" scheme="https://arclogicr.github.io/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    
    
    <category term="monitor" scheme="https://arclogicr.github.io/tags/monitor/"/>
    
    <category term="prometheus" scheme="https://arclogicr.github.io/tags/prometheus/"/>
    
    <category term="pushgateway" scheme="https://arclogicr.github.io/tags/pushgateway/"/>
    
  </entry>
  
  <entry>
    <title>交换基础2-STP</title>
    <link href="https://arclogicr.github.io/2022/05/08/switch-basic2/"/>
    <id>https://arclogicr.github.io/2022/05/08/switch-basic2/</id>
    <published>2022-05-07T17:02:18.000Z</published>
    <updated>2023-02-17T09:08:31.622Z</updated>
    
    <content type="html"><![CDATA[<p>STP，Spanning Tree Protocol，生成树协议。网络管理员经常会部署一些冗余链路防止单点中断，但是在一个交换网络中，冗余的链路可能引起重复帧甚至是广播风暴。为解决二层网络中交换节点之间的唯一路径问题，STP被设计出来解决二层环路。STP的目的是在二层冗余网络中在任意节点之间计算出一条最优无环路径。</p><p>STP主要有三个IEEE版本，802.1D&#x2F;802.1w&#x2F;802.1s。广义的STP泛指所有STP相关协议，如IEEE定义的上述三个标准，以及各厂商私有PVST&#x2F;PVST， RAPID-PVST+，VBST等；狭义的STP专指IEEE802.1D STP。</p><h2 id="IEEE-802-1D-STP"><a href="#IEEE-802-1D-STP" class="headerlink" title="IEEE 802.1D STP"></a>IEEE 802.1D STP</h2><p>IEEE802.1D是STP最早的版本。STP采用STA(Spanning Tree Arithmetic)算法，在冗余链路中选择一个参考点（根桥），将选择要到达的路径，并阻断其它路径。若路径失效，自动启用其它路径。</p><h3 id="STP相关概念"><a href="#STP相关概念" class="headerlink" title="STP相关概念"></a>STP相关概念</h3><h4 id="根桥Root-Bridge"><a href="#根桥Root-Bridge" class="headerlink" title="根桥Root Bridge"></a>根桥Root Bridge</h4><p>STA算法选定的参考点，是整个二层网络的逻辑中心。根桥可能会伴随网络拓扑变化而发生改变，但通常在二层网络设计中，会令根桥固定为某台核心交换机。</p><h4 id="桥ID-Bridge-ID"><a href="#桥ID-Bridge-ID" class="headerlink" title="桥ID Bridge ID"></a>桥ID Bridge ID</h4><p>交换机为STP分配的唯一标识号，不同版本STP有不同的结构。IEEE802.1D标准定义BID由2字节优先级（0-65535）和6个字节基mac共8字节组成。其中思科设备交换机默认优先级32768，可以手动修改，PVST+&#x2F;Rapid PVST+优先级配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spanning-tree vlan 3-5 priority</span><br></pre></td></tr></table></figure><h4 id="端口ID-Port-ID"><a href="#端口ID-Port-ID" class="headerlink" title="端口ID Port ID"></a>端口ID Port ID</h4><p>端口ID是发送BPDU端口的标识符，由4bit端口优先级和12bit端口号共16bit组成。PID通常被用来选举指定端口</p><h4 id="根路径开销RPC"><a href="#根路径开销RPC" class="headerlink" title="根路径开销RPC"></a>根路径开销RPC</h4><p>根路径开销是非根桥到根桥的最短路径开销，根端口的根路径开销都位0。路径开销是STP协议用于选择链路的参考值。根桥发出的COST值是0，在下一交换机的入口处才加上COST值，出口处COST值不变。某段链路的路径开销具体参考取值如下：</p><table><thead><tr><th>数据速率</th><th>802.1D STP</th><th>32bit推荐值(RSTP&#x2F;MSTP)</th></tr></thead><tbody><tr><td>10Mbps</td><td>100</td><td>2000000</td></tr><tr><td>100Mbps</td><td>19</td><td>200000</td></tr><tr><td>1Gbps</td><td>4</td><td>20000</td></tr><tr><td>10Gbps</td><td>2</td><td>2000</td></tr></tbody></table><h3 id="STP端口角色"><a href="#STP端口角色" class="headerlink" title="STP端口角色"></a>STP端口角色</h3><h4 id="根端口RP"><a href="#根端口RP" class="headerlink" title="根端口RP"></a>根端口RP</h4><p>根端口是去往根桥开销最小的端口。根端口负责向根桥方向转发数据，并接收上游BPDU和数据流量。每个交换机只有一个根端口，根桥没有根端口。</p><h4 id="指定端口DP"><a href="#指定端口DP" class="headerlink" title="指定端口DP"></a>指定端口DP</h4><p>指定端口是一台交换机向下游交换机转发BPDU的端口。在二层网络每一段都会选举一个指定端口。</p><h3 id="STP端口状态"><a href="#STP端口状态" class="headerlink" title="STP端口状态"></a>STP端口状态</h3><h4 id="Forwarding–转发"><a href="#Forwarding–转发" class="headerlink" title="Forwarding–转发"></a>Forwarding–转发</h4><p>转发状态下的端口既转发用户流量，也处理BPDU。转发状态是端口正常转发的最终状态。</p><h4 id="Learning–学习"><a href="#Learning–学习" class="headerlink" title="Learning–学习"></a>Learning–学习</h4><p>学习状态下的端口根据用户流量学习建立CAM表，但不转发流量。学习状态是为了防止临时环路的过渡状态。此过程持续15s。</p><h4 id="listening–监听"><a href="#listening–监听" class="headerlink" title="listening–监听"></a>listening–监听</h4><p>监听状态下的端口确定端口角色，选举根桥、RP和DP。此过程持续15s。</p><h4 id="Blocking–阻塞"><a href="#Blocking–阻塞" class="headerlink" title="Blocking–阻塞"></a>Blocking–阻塞</h4><p>阻塞状态下的端口仅接受并处理BPDU，不转发用户数据。阻塞状态是STP收敛后阻塞端口的最终状态。</p><h4 id="Disabled–禁用"><a href="#Disabled–禁用" class="headerlink" title="Disabled–禁用"></a>Disabled–禁用</h4><p>端口down，或未开启STP</p><h3 id="BPDU"><a href="#BPDU" class="headerlink" title="BPDU"></a>BPDU</h3><p>BPDU，Bridge Protocol Data Unit，桥协议数据单元，是STP协议通信的报文。BPDU直接采用二层封装，有以下作用：</p><ul><li><p>选举根桥</p></li><li><p>确定冗余路径未知</p></li><li><p>阻塞端口</p></li><li><p>通告拓扑变更</p></li><li><p>监控STP状态</p></li></ul><p>初始状态下，二层网络每台交换机都认为自己是根桥，每隔2s发送BPDU，直到根桥被选举后，只有根桥会发送BPDU。非根桥只能进行转发。</p><h4 id="BPDU类型"><a href="#BPDU类型" class="headerlink" title="BPDU类型"></a>BPDU类型</h4><h5 id="配置BPDU"><a href="#配置BPDU" class="headerlink" title="配置BPDU"></a>配置BPDU</h5><p>通常由根桥周期性发出包括STP参数用于各种角色选举。802.1D配置BPDU抓包如下：</p><p><img src="/2022/05/08/switch-basic2/stp_config.png" alt="SWITCH STP_CONFIG"></p><p>配置BPDU包含以下字段</p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>Protocol ID</td><td>STP固定为0</td></tr><tr><td>Version</td><td>协议版本，STP为0，RSTP为2，MSTP为3</td></tr><tr><td>Message Type</td><td>BPDU类型，标记不同协议的conf或tcn BPDU</td></tr><tr><td>Flags</td><td>标记TC或TCA</td></tr><tr><td>Root ID</td><td>根ID</td></tr><tr><td>Cost of Path</td><td>根路径开销</td></tr><tr><td>Bridge ID</td><td>发送者桥ID</td></tr><tr><td>Port ID</td><td>发送端口PID</td></tr><tr><td>Message age</td><td>该BPDU老化时间</td></tr><tr><td>Max age</td><td>最大老化时间</td></tr><tr><td>Hellotime</td><td>发送BPDU间隔时间</td></tr><tr><td>Forward delay</td><td>控制listening和learning状态的持续时间</td></tr></tbody></table><h5 id="TCN"><a href="#TCN" class="headerlink" title="TCN"></a>TCN</h5><p>拓扑变化通告，当交换机检测到拓扑变化时发出。TCN BPDU只包含Protocol ID，Version和Message Type三个字段。802.1DTCN BPDU抓包如下：</p><p><img src="/2022/05/08/switch-basic2/stp_tcn.png" alt="SWITCH STP_TCN"></p><h3 id="STP三个定时器"><a href="#STP三个定时器" class="headerlink" title="STP三个定时器"></a>STP三个定时器</h3><h4 id="Hellotime"><a href="#Hellotime" class="headerlink" title="Hellotime"></a>Hellotime</h4><p>hellotime用于指定根桥连续发送BPDU的间隔，<u>默认值2秒</u>。</p><h4 id="Forward-Delay"><a href="#Forward-Delay" class="headerlink" title="Forward Delay"></a>Forward Delay</h4><p>转发延迟用于指定在Listening和Learning状态下所停留的时间，<u>默认值15秒</u>。</p><h4 id="Max-Age"><a href="#Max-Age" class="headerlink" title="Max Age"></a>Max Age</h4><p>最大存活时间，<u>默认值20秒</u>。此时间内没有收到BPDU，则不再承认老根桥。</p><p>PVST+&#x2F;Rapid PVST+定时器配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">switch(config)#spanning-tree vlan 3-5 [forward-time/hello-time/max-age]</span><br></pre></td></tr></table></figure><h3 id="STP端口选举"><a href="#STP端口选举" class="headerlink" title="STP端口选举"></a>STP端口选举</h3><p>初始状态下，每台交换机认为自己是根桥，每2s扩散配置BPDU。STP通过一系列的选举，决定根桥、根端口、指定端口和非指定端口。<strong>在STP的各种选举中，参数值越小越优</strong>。</p><p>总结下来可用四句话概括：</p><p>One root bridge per network–选根桥<br>One root port per nonroot bridge-选根端口<br>One designated port per segment-每段链路选指定端口<br>Nondesignated ports are blocked-非指定端口被阻塞</p><h4 id="选根桥"><a href="#选根桥" class="headerlink" title="选根桥"></a>选根桥</h4><p>BID是STP为每台交换机分配的唯一标识符，STP使用IEEE802.1D定义的优先级+基mac组成的BID。每个网络中只有一个根桥，规定<u>拥有最小桥ID的交换机被选举为根桥</u>。</p><h4 id="（非根桥）选根端口"><a href="#（非根桥）选根端口" class="headerlink" title="（非根桥）选根端口"></a>（非根桥）选根端口</h4><p>每个非根桥有且只有一个根端口。对于非根桥，使用以下方法选举根端口：</p><p>1、该端口到达根桥cost最小</p><p>2、该端口收到的BID最小</p><p>3、该端口对接的端口PID最小，若对方PID相同则比较自己PID</p><h4 id="（每段链路）选指定端口"><a href="#（每段链路）选指定端口" class="headerlink" title="（每段链路）选指定端口"></a>（每段链路）选指定端口</h4><p>根桥所有端口都是指定端口。对于每段链路，使用以下方法选举指定端口：</p><p>1、到达根桥cost最小</p><p>2、BID最小的一端</p><p>3、（集线器共享链路，一个冲突域）对方端口PID最小，若对方PID相同则比较自己PID</p><h4 id="阻塞非指定端口"><a href="#阻塞非指定端口" class="headerlink" title="阻塞非指定端口"></a>阻塞非指定端口</h4><p>最后，既不是根端口，又不是指定端口的哪些接口被称为非指定端口，这些端口将被block掉。从而达到防环的目的。</p><p>在所有端口选举完成后，STP完成收敛，此时任意两节点之间的二层通路只有唯一一条。</p><h3 id="二层收敛"><a href="#二层收敛" class="headerlink" title="二层收敛"></a>二层收敛</h3><h4 id="STP收敛"><a href="#STP收敛" class="headerlink" title="STP收敛"></a>STP收敛</h4><p>当二层网络出现变动或故障时，可能会导致STP重收敛。STP会将端口状态按照以下顺序转变：BLOCKING–LISTENING–LEARNING–FORWARDING</p><h5 id="STP收敛时间"><a href="#STP收敛时间" class="headerlink" title="STP收敛时间"></a>STP收敛时间</h5><p>当拓扑发生变化时，端口从阻塞状态过渡到正常转发状态的时间是30-50S<br>如果是直连接口down掉，端口状态过渡最大需要30S，因为无需等老化<br>如果是非直连故障，最大需要50S</p><h4 id="CAM表收敛"><a href="#CAM表收敛" class="headerlink" title="CAM表收敛"></a>CAM表收敛</h4><p>二层网络故障或变动还会导致CAM表收敛。以下事件会使得STP发送TCN BPDU</p><ul><li><p>链路故障（FWD-BLK）</p></li><li><p>端口进入FWD状态，且交换机拥有DP</p></li><li><p>非根桥从DP收到TCN会将其转发</p></li></ul><p>CAM表收敛过程如下：</p><p>1、拓扑发生改变的交换机向RP端口发出TCN BPDU<br> 2、上级交换机做两件事：先回应一个TCA BPDU，再继续向自已的RP接口发出TCN的BPDU<br> 3、TCN的BPDU就这样一跳跳的传到根交换机上<br> 4、然后根交换机将自已MAC地址表的老化时间由默认的300S改为转发延迟时间(15S)。<br> 5、根交换机再向网络中发出TC置位的BPDU<br> 6、网络中的其他交换机收到TC置位的BPDU后，也将自已MAC地址表的老化时间由默认的300S改为15S。</p><p>这样，每台交换机就快速的老化了MAC地址表，清除掉了已经失效的MAC地址条目。</p><h3 id="PVST-x2F-PVST"><a href="#PVST-x2F-PVST" class="headerlink" title="PVST&#x2F;PVST+"></a>PVST&#x2F;PVST+</h3><p>很容易发现STP的一个弊端：STP协议将整个二层网络生成一颗树，这样就会导致诸多问题。比如不同VLAN可能会产生次优路径，冗余链路带宽浪费等。如下图所示，STP收敛后，阻塞一条链路，则在这条链路上任何VLAN的用户流量都不能被转发。</p><p><img src="/2022/05/08/switch-basic2/stp_loop.png" alt="SWITCH STP_LOOP"></p><h4 id="PVST"><a href="#PVST" class="headerlink" title="PVST"></a>PVST</h4><p>思科为解决上述问题，开发了PVST，Per Vlan STP。PVST为每个VLAN创建一颗生成树，解决了不同VLAN次优路径问题，另外可以通过设计将二层流量进行一定程度的负载分担。假设上图中描述了VLAN10的树，而VLAN20的树中被阻塞的是左边一条链路，那么在二层网络通信中，VLAN10和VLAN20的流量将分别走左右两条链路，利用了冗余链路的带宽。</p><h4 id="PVST-1"><a href="#PVST-1" class="headerlink" title="PVST+"></a>PVST+</h4><p>由于PVST只支持ISL封装，并且无法与IEEE802.1D STP兼容，思科很快又开发了增强的PVST+协议。PVST+支持dot1Q封装，并且在VLAN1内可以与IEEE802.1D STP对接。PVST可以通过PVST+与IEEE802.1D STP间接对接。思科设备默认运行PVST+生成树协议，PVST+在某个VLAN内运行时基本与STP类似，包括计时器、端口状态等。PVST+ BPDU有单独的目的mac地址0100-0ccc-cccd。</p><p>PVST+配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">switch(config)#spanning-tree mode pvst</span><br></pre></td></tr></table></figure><h5 id="PVST-的BID"><a href="#PVST-的BID" class="headerlink" title="PVST+的BID"></a>PVST+的BID</h5><p>PVST+在计算BID时与STP稍有不同。BID共8个字节，STP使用前2个字节做priority，后6个字节做mac地址，中间10bit，保留不用；PVST+后6个字节做mac地址，前2个字节前4bit用作priority，后12bit用于表示vlan号。比如，PVST+ BID前2个字节如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0011 0000 0000 000a</span><br></pre></td></tr></table></figure><p>则表示VLAN 10 的 优先级为12288（2^12+2^13），<u>由于只用高4bit表示优先级，这也是优先级只能表示为4096倍数的原因</u>。</p><p>PVST+配置BPDU抓包如下：</p><p><img src="/2022/05/08/switch-basic2/pvst+_config.png" alt="SWITCH PVST+_CONFIG"></p><h4 id="PVST-增强特性"><a href="#PVST-增强特性" class="headerlink" title="PVST+增强特性"></a>PVST+增强特性</h4><p>802.1D STP设计目的是为了让二层网络可以在冗余链路中断后，1min内恢复。这对于当时也不是一个很短的时间。为了加快收敛，Cisco设备支持了一些私有特性，优化STP收敛速度。</p><h5 id="PortFast"><a href="#PortFast" class="headerlink" title="PortFast"></a>PortFast</h5><p>PortFast特性可以让2层的接入端口跳过LIST&#x2F;LRN状态直接进入FWD，可以节省30s的收敛时间。PortFast通常配置在终端接入端口。Porfast配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#接口开启</span><br><span class="line">switch(config-if)#spanning-tree portfast</span><br><span class="line"></span><br><span class="line">#或全局开启</span><br><span class="line">switch(config)#spanning-tree portfast edge default</span><br></pre></td></tr></table></figure><h5 id="UplinkFast"><a href="#UplinkFast" class="headerlink" title="UplinkFast"></a>UplinkFast</h5><p>UplinkFast特性用于检测直连到汇聚层链路故障并加快收敛。当上联FWD链路中断时，UplinkFast将增加交换机STP的priority和cost，原有BLK链路立即转为FWD状态，可节省30s时间。UplinkFast是全局命令，影响所有VLAN。UplinkFast配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">switch(config)#spanning-tree uplinkfast</span><br></pre></td></tr></table></figure><h5 id="Backbonefast"><a href="#Backbonefast" class="headerlink" title="Backbonefast"></a>Backbonefast</h5><p>Backbonefast特性是用于检测主干SW间的链路故障。接受到次级BPDU后会主动发送RLQ BPDU探测链路，加速收敛，可以节省20s老化时间。BackboneFast需要在所有交换机配置，配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">switch(config)#spanning-tree backbonefast</span><br></pre></td></tr></table></figure><h2 id="IEEE-802-1w-Rapid-STP"><a href="#IEEE-802-1w-Rapid-STP" class="headerlink" title="IEEE 802.1w Rapid STP"></a>IEEE 802.1w Rapid STP</h2><p>IEEE802.1w在IEEE802.1D基础上改进了STP，制定了RSTP，快速生成树协议，RSTP加快了收敛速度并增加边缘端口及STP防护功能。</p><h3 id="RSTP链路类型"><a href="#RSTP链路类型" class="headerlink" title="RSTP链路类型"></a>RSTP链路类型</h3><p>运行RSTP的端口加入了链路类型概念。</p><h4 id="Point-to-Point-Link"><a href="#Point-to-Point-Link" class="headerlink" title="Point-to-Point Link"></a>Point-to-Point Link</h4><p>点对点链路一般用于点对点连接的全双工链路，只有在点对点链路下，RSTP才能实现快速收敛。</p><h4 id="Shared-Link"><a href="#Shared-Link" class="headerlink" title="Shared Link"></a>Shared Link</h4><p>共享链路用于连接物理层HUB的链路。</p><h4 id="Edge"><a href="#Edge" class="headerlink" title="Edge"></a>Edge</h4><p>边缘链路，用于接入终端设备。</p><p>RSTP链路类型配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">switch(config-if)#spanning-tree link-type [point-to-point/shared]</span><br></pre></td></tr></table></figure><h3 id="RSTP端口角色"><a href="#RSTP端口角色" class="headerlink" title="RSTP端口角色"></a>RSTP端口角色</h3><p>RSTP保留了STP中的<strong>根端口RP</strong>和<strong>指定端口DP</strong>的概念</p><h4 id="替代端口AP"><a href="#替代端口AP" class="headerlink" title="替代端口AP"></a>替代端口AP</h4><p>到根网桥的替换路径, 用以替换的根端口, 责任是为其他网桥的链路作备份</p><h4 id="备份端口BP"><a href="#备份端口BP" class="headerlink" title="备份端口BP"></a>备份端口BP</h4><p>是指定端口的备份端口, 是为本网桥的端口作备份。备份端口只有两种情况下会存在：</p><ul><li><p>同一交换机两个端口通过点到点链路相连成一个环路</p></li><li><p>网桥与物理层HUB共享网络有多条连接</p></li></ul><h4 id="边缘端口EP"><a href="#边缘端口EP" class="headerlink" title="边缘端口EP"></a>边缘端口EP</h4><p>边缘端口, 指网桥上连接到终端设备的端口, 此类端口可以实现快速收敛。边缘端口和PVST+的portfast类似，在up&#x2F;down后不会产生拓扑改变。但是当RSTP边缘端口收到BPDU后，该端口会变成一个正常的生成树端口。</p><h3 id="RSTP端口状态"><a href="#RSTP端口状态" class="headerlink" title="RSTP端口状态"></a>RSTP端口状态</h3><h4 id="Forwarding–转发-1"><a href="#Forwarding–转发-1" class="headerlink" title="Forwarding–转发"></a>Forwarding–转发</h4><p>转发状态下的端口既转发用户流量，也处理BPDU。转发状态是端口正常转发的最终状态。</p><h4 id="Learning–学习-1"><a href="#Learning–学习-1" class="headerlink" title="Learning–学习"></a>Learning–学习</h4><p>学习状态下的端口根据用户流量学习建立CAM表，但不转发流量。学习状态是为了防止临时环路的过渡状态。此过程持续15s。</p><h4 id="Discarding–丢弃"><a href="#Discarding–丢弃" class="headerlink" title="Discarding–丢弃"></a>Discarding–丢弃</h4><p>丢弃状态下的端口仅接受并处理BPDU，不转发用户数据。阻塞状态是STP收敛后阻塞端口的最终状态。</p><h4 id="RSTP端口状态与STP对比"><a href="#RSTP端口状态与STP对比" class="headerlink" title="RSTP端口状态与STP对比"></a>RSTP端口状态与STP对比</h4><table><thead><tr><th>802.1D STP</th><th>802.1w RSTP</th><th>学习mac</th><th>收发用户数据</th></tr></thead><tbody><tr><td>Disabled</td><td>Discarding</td><td>否</td><td>否</td></tr><tr><td>Blocking</td><td>Discarding</td><td>否</td><td>否</td></tr><tr><td>Listening</td><td>Discarding</td><td>否</td><td>否</td></tr><tr><td>Learning</td><td>Learning</td><td>是</td><td>否</td></tr><tr><td>Forwarding</td><td>Forwarding</td><td>是</td><td>是</td></tr></tbody></table><h3 id="RSTP-BPDU报文结构"><a href="#RSTP-BPDU报文结构" class="headerlink" title="RSTP BPDU报文结构"></a>RSTP BPDU报文结构</h3><p>RSTP与STP采用相同的目的mac地址0180-c200-0000。有以下字段与STP不同</p><p><img src="/2022/05/08/switch-basic2/rstp_stp.jpg" alt="SWITCH RSTP_STP"></p><p>其中</p><p>version字段，message字段有改变，改为RSTP对应的值。</p><p>flag字段全部被使用，用于协商加速收敛。</p><p>增加v1长度字段</p><p>RSTP抓包如下：</p><p><img src="/2022/05/08/switch-basic2/rstp_bpdu.png" alt="SWITCH RSTP_BPDU"></p><p>除非有老设备，否则通常RSTP不需要TCN BPDUP，RSTP使用TC置位的config BPDU通知拓扑变化</p><h3 id="RSTP端口选举"><a href="#RSTP端口选举" class="headerlink" title="RSTP端口选举"></a>RSTP端口选举</h3><p>RSTP与STP不同，在任何时候都会每隔2s发送BPDU。初始状态下，各交换机通过BPDU选举各式端口角色。</p><p>RSTP的根桥、RP、DP选举与STP类似，RSTP增加了AP和BP端口的选举。规则如下：</p><ul><li><p>BP是DP的备份，所以某段链路选举出DP后，该DP所在交换机为指定交换机，BP只能出现在指定交换机上。</p></li><li><p>AP是RP的备份，除了DP,RP,BP，剩下的端口就是AP</p></li></ul><p>RSTP工作选举顺序可以总结为如下：</p><p>1、选根桥RB（与STP方法类似）</p><p>2、选根端口RP（与STP方法类似）</p><p>3、选指定端口DP（与STP方法类似）</p><p>4、选备份端口BP</p><p>5、剩余的是替代端口AP</p><p>6、AP和BP进入Discarding状态</p><h4 id="RSTP端口选举举例"><a href="#RSTP端口选举举例" class="headerlink" title="RSTP端口选举举例"></a>RSTP端口选举举例</h4><p>假设BID SW1&lt;SW2&lt;SW3，除了右边3号端口所在链路cost为3，其余每条链路的cost为1，图中数字代表端口号。最下面的HUB不运行STP。</p><p><img src="/2022/05/08/switch-basic2/rstp_topo.png" alt="SWITCH RSTP_TOPO"></p><p>可以根据上述规则，按照以下步骤分析：</p><p>1、选根桥，SW1 BID最小，成为根桥；</p><p>2、选根端口，SW2&#x2F;SW3上联口到根桥SW1的cost都是1，毫无疑问是RP。SW4上联cost是3，9&#x2F;10端口是2&lt;3，又因为9号端口号小，所以9号端口是RP。这里SW4到SW3虽有两条线路，但对于STP来说中间设备是透明的（不运行STP），视作一条链路；</p><p>3、选指定端口，首先根桥1，2，3端口都是DP；然后SW2&#x2F;SW3&#x2F;SW4通过HUB连接，相当于在一个段中，所以45678910中只会选举一个DP，由于SW2 BID最小，所以选择PID最小的4号端口作为DP；</p><p>4、选备份端口，由于DP在SW2上，所以同一段的5、6两个端口为BP；</p><p>5、其余的端口为AP</p><h3 id="RSTP收敛"><a href="#RSTP收敛" class="headerlink" title="RSTP收敛"></a>RSTP收敛</h3><h4 id="RSTP对BPDU的处理"><a href="#RSTP对BPDU的处理" class="headerlink" title="RSTP对BPDU的处理"></a>RSTP对BPDU的处理</h4><ul><li><p>与STP不同，任何时候RSTP每隔2s就会发送BPDU。</p></li><li><p>STP中，老化必须等待20s；RSTP中当一台交换机3个hellotime没收到BPDU就会老化自己的BPDU配置信息；这种老化机制可以快速检测故障。</p></li><li><p>STP的DP收到次级BPDU会把更优的BPDU发出去，对非指定端口不会做同样处理；RSTP中无论是否为DP，收到次级BPDU都会马上发送本地更优的BPDU给对方，或覆盖现有BPDU信息。</p></li></ul><h4 id="RSTP拓扑变更"><a href="#RSTP拓扑变更" class="headerlink" title="RSTP拓扑变更"></a>RSTP拓扑变更</h4><p><strong><u>在RSTP中，只有非边缘端口进入FWD状态时，才能导致拓扑改变。</u></strong></p><p>当某台交换机检测到拓扑改变后，进行以下操作：</p><ul><li><p>为所有非edge DP和RP启动计时器，为2倍hellotime</p></li><li><p>清空这些端口的mac地址</p></li><li><p>计时器有效期内，向这些端口发送TC置位的BPDU</p></li></ul><p>其它交换机收到TC置位的BPDU后，进行以下操作：</p><ul><li><p>清除接受TC端口以外所有端口的mac地址</p></li><li><p>所有端口启动2倍hellotime计时器，并在时间内发送TC置位BPDU。</p></li></ul><h4 id="RSTP-P-x2F-A协商机制"><a href="#RSTP-P-x2F-A协商机制" class="headerlink" title="RSTP P&#x2F;A协商机制"></a>RSTP P&#x2F;A协商机制</h4><p>P&#x2F;A，Proposal&#x2F;Agreement机制用于主动协商RP、DP，P&#x2F;A机制仅在p2p链路上生效。当指定端口DP处于Learning或Discarding状态时，此时需要将proposal置位。P&#x2F;A协商过程：</p><p>1、SW1发送P置位的BPDU</p><p>2、阻塞所有端口（除边缘端口）</p><p>3、SW2根据自身情况，回复A置位的BPDU</p><p>4、SW1收到A置位的BPDU后，该端口立即进入FWD</p><h4 id="RSTP收敛时间优化总结"><a href="#RSTP收敛时间优化总结" class="headerlink" title="RSTP收敛时间优化总结"></a>RSTP收敛时间优化总结</h4><ul><li><p>直连故障，可以用过AP&#x2F;BP立即进入FWD状态</p></li><li><p>P&#x2F;A协商，可以使RP和DP互联口立即进入FWD</p></li><li><p>次优BPDU，AP收到次级BPDU会变为DP，并发送最优BPDU</p></li><li><p>BPDU丢包，连续丢3个BPDU，端口角色就需要切换，最长等待6s</p></li><li><p>任意位置交换机可以发送TC，加快收敛</p></li></ul><p>常见STP&#x2F;RSTP收敛时间如下：</p><table><thead><tr><th>IEEE</th><th>收敛</th><th>CISCO</th><th>收敛</th></tr></thead><tbody><tr><td>802.1D STP</td><td>30-50</td><td>PVST&#x2F;PVST+</td><td>30-50&#x2F;0-30</td></tr><tr><td>802.1W RAPID-STP</td><td>1秒内</td><td>RAPID-PVST</td><td>1秒内</td></tr></tbody></table><h3 id="RSTP安全防护功能"><a href="#RSTP安全防护功能" class="headerlink" title="RSTP安全防护功能"></a>RSTP安全防护功能</h3><h4 id="BPDU-GUARD"><a href="#BPDU-GUARD" class="headerlink" title="BPDU GUARD"></a>BPDU GUARD</h4><p>BPDU GUARD用于防止意外接受BPDU。配置BPUD防护的edge端口收到BPDU后，会将接口置于errdisable，可以手动down&#x2F;up恢复或配置自动恢复。</p><h4 id="BPDU-FILTER"><a href="#BPDU-FILTER" class="headerlink" title="BPDU FILTER"></a>BPDU FILTER</h4><p>BPDU FILTER用于过滤BPDU。同时配置GUARD和FILTER，则先进行FILTER功能。若全局启用BPDU FILTER，则edge端口收到BPDU后会转为生成树端口；若在接口下启用BPDU FILTER，则该接口不收发BPDU。</p><h4 id="GUARD-ROOT"><a href="#GUARD-ROOT" class="headerlink" title="GUARD ROOT"></a>GUARD ROOT</h4><p>GUARD ROOT功能可以将端口强制设置位DP，从而防止对端交换机成为根桥。当配置GUARD ROOT的端口收到更高优先级BPDU后，该端口将被置Discarding状态4s，若不再收到跟高级BPDU则恢复为FWD状态。</p><h4 id="GUARD-LOOP"><a href="#GUARD-LOOP" class="headerlink" title="GUARD LOOP"></a>GUARD LOOP</h4><p>GUARD LOOP用于防止环路。某些情况，STP中discarding端口错误过渡到FWD状态会出现环路。当RP或AP长时间收不到上游设备的BPDU时，AP会进入Discarding状态并切换为DP；AP会保持在discarding状态，从而不会形成环路。</p><h4 id="RSTP安全防护相关配置"><a href="#RSTP安全防护相关配置" class="headerlink" title="RSTP安全防护相关配置"></a>RSTP安全防护相关配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#BPDU GUARD</span><br><span class="line">switch(config)#spanning-tree portfast edge bpdugard default</span><br><span class="line">switch(config-if)#spanning-tree bpduguard enable</span><br><span class="line"></span><br><span class="line">#BPDU FILTER</span><br><span class="line">switch(config)#spanning-tree portfast edge bpdufilter default</span><br><span class="line">switch(config-if)#spanning-tree bpdufilter enable</span><br><span class="line"></span><br><span class="line">#GUARD ROOT</span><br><span class="line">switch(config-if)#spanning-tree guardloop</span><br><span class="line"></span><br><span class="line">#GUARD LOOP</span><br><span class="line">switch(config)#spanning-tree loopguard default </span><br><span class="line">switch(config-if)#spanning-tree guardroot</span><br></pre></td></tr></table></figure><h3 id="RSTP兼容性"><a href="#RSTP兼容性" class="headerlink" title="RSTP兼容性"></a>RSTP兼容性</h3><p>RSTP可以兼容STP，当RSTP端口收到三次连续的STP BPDU时，将端口协议切换到STP，但同时会失去RSTP的快速收敛特性。</p><h4 id="Rapid-PVST"><a href="#Rapid-PVST" class="headerlink" title="Rapid-PVST+"></a>Rapid-PVST+</h4><p>Rapid-PVST+是Cisco针对RSTP开发的快速收敛版本的PVST+。在每个VLAN中，RPVST+各项特性与RSTP基本一致。</p><p>Rapid PVST+配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">switch(config)#spanning-tree mode rapid-pvst </span><br></pre></td></tr></table></figure><h2 id="IEEE802-1s-MST"><a href="#IEEE802-1s-MST" class="headerlink" title="IEEE802.1s MST"></a>IEEE802.1s MST</h2><p>IEEE802.1s在RSTP基础上进行了改进，指定了MST，Multiple Spanning Tree多生成树协议，由于STP,RSTP在域内只有一颗树，存在次优路径和贷款浪费的问题。虽然Rapid PVST+解决了这些问题，但Rapid PVST+ 带来新的问题，就是当VLAN数量增多时，每个VLAN都要计算生成树，可能很多VLAN的拓扑可能是一致的，但还是要分开计算生成树，这对交换机造成很大负载压力。</p><h3 id="MST的改进"><a href="#MST的改进" class="headerlink" title="MST的改进"></a>MST的改进</h3><p>IEEE802.1s MST解决这个问题，MST的主要特点是支持将VLAN分组定义到不同的多生成树实例MSTI，既满足了不同VLAN不同拓扑的问题，也能将同拓扑VLAN归为一类计算同一生成树，解决交换机负载问题。可以看作是RSTP和RPVST+折中方案。</p><h3 id="MIST"><a href="#MIST" class="headerlink" title="MIST"></a>MIST</h3><p>思科也曾尝试开发类似的生成树协议，叫MIST，Multiple Instance Spanning Tree多实例生成树，由于功能基本域MST类似，为了避免小特性上的不同，思科弃用MIST，改用MST。所以现在思科的交换设备上的STP协议通常只有三种：PVST+，Rapid-PVST+,MST。分别对应IEEE802.1D STP，IEEE802.1w RSTP和IEEE802.1s MST。</p><h3 id="MST相关概念"><a href="#MST相关概念" class="headerlink" title="MST相关概念"></a>MST相关概念</h3><h4 id="MST-Region"><a href="#MST-Region" class="headerlink" title="MST Region"></a>MST Region</h4><p>MST区域是指具有相同配置一类MST，这些配置包括：</p><ul><li><p>区域名</p></li><li><p>相同的实例与vlan映射配置</p></li><li><p>相同的修订号</p></li></ul><h4 id="MSTI"><a href="#MSTI" class="headerlink" title="MSTI"></a>MSTI</h4><p>MSTI，MST Instance，多生成树实例。一个MSTI可以包含多个vlan的映射。每个MSTI单独使用RSTP计算生成树互不影响。</p><h4 id="CST"><a href="#CST" class="headerlink" title="CST"></a>CST</h4><p>CST，Common Spanning Tree，公共生成树，是连接各MSTP区域的一颗生成树。</p><h4 id="IST"><a href="#IST" class="headerlink" title="IST"></a>IST</h4><p>IST，Internal Spanning Tree，内部生成树，是指各MST域内的一颗生成树（MSTI0）。</p><h4 id="CIST"><a href="#CIST" class="headerlink" title="CIST"></a>CIST</h4><p>CIST，Common and Internal Spanning Tree，公共和内部生成树，是连接二层网络所有交换机的一颗总生成树。</p><h4 id="域根"><a href="#域根" class="headerlink" title="域根"></a>域根</h4><p>域根是指MST区域内各MSTI的根（IST根）。</p><h4 id="总根"><a href="#总根" class="headerlink" title="总根"></a>总根</h4><p>总根是CIST的根。</p><h3 id="MST端口角色"><a href="#MST端口角色" class="headerlink" title="MST端口角色"></a>MST端口角色</h3><p>MSTP保留了RSTP中的RP，DP，AP，BP，EP的概念，新增Master端口MP和域边缘端口Boundary port（BdP）。</p><h4 id="Master端口MP"><a href="#Master端口MP" class="headerlink" title="Master端口MP"></a>Master端口MP</h4><p>Master端口是MST域和总跟相连路径中最短路径的端口，MP是特殊的BdP</p><h4 id="域边缘端口BdP"><a href="#域边缘端口BdP" class="headerlink" title="域边缘端口BdP"></a>域边缘端口BdP</h4><p>域边缘端口BdP是位于MST域边缘并连接其它STP域的端口</p><p>MST端口角色示意图如下：</p><p><img src="/2022/05/08/switch-basic2/mst_port.png" alt="SWITCH MST_PORT"></p><h3 id="MST端口状态"><a href="#MST端口状态" class="headerlink" title="MST端口状态"></a>MST端口状态</h3><p>MST端口状态与RSTP完全相同，分别为Forwarding，Learning和Discarding</p><h3 id="MST-BPDU格式"><a href="#MST-BPDU格式" class="headerlink" title="MST BPDU格式"></a>MST BPDU格式</h3><p>相比较于RSTP，MSTP BPDU增加了version3长度和MST配置信息的一些字段，抓包如下</p><p><img src="/2022/05/08/switch-basic2/mst_bpdu.png" alt="SWITCH MST_BPDU"></p><p>其中</p><p>MST conifg name：MST区域名</p><p>MST config revision：MST修订号</p><p>CIST Internal Root Path Cost：CIST内部路径开销，从本端口到IST Master累计路径开销。</p><p>CIST BID：CIST指定交换机BID</p><p>CIST Remaining Hops：BPDU在CIST剩余跳数</p><p>MSTID x：MSTI配置信息</p><h3 id="MST收敛"><a href="#MST收敛" class="headerlink" title="MST收敛"></a>MST收敛</h3><p>MST将二层网络划分为多个MST域，MST域间计算生成CST，域内分别计算MSTI。各交换机通过MST BPDU来生成MSTI和CIST</p><h4 id="CIST拓扑计算"><a href="#CIST拓扑计算" class="headerlink" title="CIST拓扑计算"></a>CIST拓扑计算</h4><p>经处理BPDU消息，整个二层网络BID最小的设备成为CIST总根。每隔MST域内计算生成IST(MST0)，同时MST将各MST域作为整体在MST域间计算CST。CST和IST构成CIST。</p><h5 id="CIST总根选举"><a href="#CIST总根选举" class="headerlink" title="CIST总根选举"></a>CIST总根选举</h5><p>CIST根据以下原则在域根桥中选总根（越小越优）：</p><p>1、域根BID</p><p>2、外部路径开销</p><p>3、内部路径开销</p><p>4、指定交换机BID</p><p>5、指定端口PID</p><p>6、接受端口PID</p><h5 id="CIST端口角色选举（RP-x2F-DP-x2F-MP）"><a href="#CIST端口角色选举（RP-x2F-DP-x2F-MP）" class="headerlink" title="CIST端口角色选举（RP&#x2F;DP&#x2F;MP）"></a>CIST端口角色选举（RP&#x2F;DP&#x2F;MP）</h5><p>CIST根据以下原则选举端口角色（越小越优）：</p><p>1、CIST总根BID</p><p>2、CIST到总根的外部开销</p><p>3、CIST域根BID</p><p>4、CIST到域根的内部开销</p><p>5、CIST BPDU发送端BID</p><p>6、CIST BPDU发送端PID</p><p>7、CIST BPDU接收端PID</p><h4 id="MSTI拓扑计算"><a href="#MSTI拓扑计算" class="headerlink" title="MSTI拓扑计算"></a>MSTI拓扑计算</h4><p>MST域内，各MSTI根据VLAN映射关系分别计算生成树，计算方法与RSTP类似。在MST域内安装MSTI转发数据，MST域间按照CST转发数据。</p><h4 id="MST拓扑变化与快速收敛机制"><a href="#MST拓扑变化与快速收敛机制" class="headerlink" title="MST拓扑变化与快速收敛机制"></a>MST拓扑变化与快速收敛机制</h4><p>MSTP拓扑变化与快速收敛机制与RSTP类似。</p><h3 id="MST兼容性"><a href="#MST兼容性" class="headerlink" title="MST兼容性"></a>MST兼容性</h3><p>MSTI0可与RSTP&#x2F;STP兼容，不能与PVST+&#x2F;RPVST+兼容，相应互联端口会置BKN*状态。</p><h3 id="MST配置"><a href="#MST配置" class="headerlink" title="MST配置"></a>MST配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#进入mst配置</span><br><span class="line">swtich(config)#spanning-tree mst configuration </span><br><span class="line"></span><br><span class="line">#配置mst区域信息，name，revision，MSTI vlan映射</span><br><span class="line">swtich(config-mst)#name ccie</span><br><span class="line">swtich(config-mst)#revision 100</span><br><span class="line">swtich(config-mst)#instance 1 vlan 2-19</span><br><span class="line">swtich(config-mst)#instance 2 vlan 20-100</span><br><span class="line"></span><br><span class="line">#配置msti优先级</span><br><span class="line">switch(config)#spanning-tree mst 1 priority 8192</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;STP，Spanning Tree Protocol，生成树协议。网络管理员经常会部署一些冗余链路防止单点中断，但是在一个交换网络中，冗余的链路可能引起重复帧甚至是广播风暴。为解决二层网络中交换节点之间的唯一路径问题，STP被设计出来解决二层环路。STP的目的是在二层冗余网</summary>
      
    
    
    
    <category term="路由交换RS" scheme="https://arclogicr.github.io/categories/%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2RS/"/>
    
    
    <category term="network" scheme="https://arclogicr.github.io/tags/network/"/>
    
    <category term="switching" scheme="https://arclogicr.github.io/tags/switching/"/>
    
    <category term="stp" scheme="https://arclogicr.github.io/tags/stp/"/>
    
  </entry>
  
  <entry>
    <title>交换基础1</title>
    <link href="https://arclogicr.github.io/2022/04/25/switch-basic/"/>
    <id>https://arclogicr.github.io/2022/04/25/switch-basic/</id>
    <published>2022-04-25T13:02:48.000Z</published>
    <updated>2023-01-31T10:29:34.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="交换设备"><a href="#交换设备" class="headerlink" title="交换设备"></a>交换设备</h1><h2 id="中继器Repeater"><a href="#中继器Repeater" class="headerlink" title="中继器Repeater"></a>中继器Repeater</h2><p>中继器是信号放大设备，用于远距离传输时信号的重放。</p><h2 id="集线器HUB"><a href="#集线器HUB" class="headerlink" title="集线器HUB"></a>集线器HUB</h2><p>早期狭义上的HUB是物理层设备，这种HUB仅仅将各个交换端口用电缆连接起来，使用CSMA&#x2F;CD来控制收发信号。整个HUB是一个冲突域，HUB上的任何终端可以侦听到全部的其它终端信号，没有安全性。</p><p>现在我们广义上的HUB指的是非网管交换机，即傻瓜交换机，它仅具有二层转发能力。</p><h3 id="冲突域"><a href="#冲突域" class="headerlink" title="冲突域"></a>冲突域</h3><p>在同一个网络上两个设备同时进行传输则会产生冲突；在网络内部信号传输所产生与发生冲突的这样一个区域称为冲突域。</p><h3 id="广播域"><a href="#广播域" class="headerlink" title="广播域"></a>广播域</h3><p>一个广播分组能被泛洪传播的范围叫广播域。</p><h3 id="CSMA-x2F-CD"><a href="#CSMA-x2F-CD" class="headerlink" title="CSMA&#x2F;CD"></a>CSMA&#x2F;CD</h3><p>CSMA&#x2F;CD是带冲突检测的多路载波监听。简单来说，其原理就是持续侦听信道是否空闲，空闲时才发送数据；如果遇到同时发送，即发生冲突，会有一系列回退机制，等待重发。这种技术用于早期标准以太网（10Mbps）和快速以太网（100Mbps）的半双工模式。</p><h2 id="网桥Bridge"><a href="#网桥Bridge" class="headerlink" title="网桥Bridge"></a>网桥Bridge</h2><p>网桥是阻断冲突域的设备。假设在两个HUB之间由一个网桥连接，网桥会记录这两个HUB上接入的所有终端的链路层地址，这样当HUB A访问HUB A上的终端时，信号就可以不用被发送到HUB B；仅当HUB A 终端访问 HUB B上的终端时才会发送到HUB B。因此，网桥一定程度上可以将冲突域减半。</p><p><img src="/2022/04/25/switch-basic/hub_bridge.png" alt="SWITCH HUB_BRIDGE"></p><h2 id="交换机Switch"><a href="#交换机Switch" class="headerlink" title="交换机Switch"></a>交换机Switch</h2><p>和网桥类似，交换机也是阻断冲突域的设备，一个交换机端口就是一个冲突域。现代交换机基本都采用存储-转发的方式进行转发，通过ASIC硬件可以将转发速度达到线速（100M&#x2F;1G&#x2F;10G&#x2F;25G&#x2F;40G&#x2F;100G）。一个衡量交换机性能的重要指标是吞吐量&#x2F;背板带宽，即交换机所有端口满载时消耗的带宽总和。</p><h3 id="交换机工作原理"><a href="#交换机工作原理" class="headerlink" title="交换机工作原理"></a>交换机工作原理</h3><p>交换机工作原理可以总结为三点</p><ul><li><p>学习mac地址</p></li><li><p>泛洪广播、组播和未知单播</p></li><li><p>点到点转发已知单播</p></li></ul><p>考虑两台同一局域网内的终端A和B首次ping通信过程：</p><p>终端A欲发送icmp包给B，但是无法填充目的mac（即B的mac），于是发送arp广播，问谁是B；</p><p><strong>此时交换机收到广播包，首先学习A的mac地址，然后泛洪该广播；</strong></p><p>B收到arp广播后，填充自己的arp表，单播回复我是B；</p><p><strong>此时交换机收到已知单播包（已习得A的mac），首先学习B的MAC地址，然后点到点转发该arp回复包；</strong></p><p>A收到B的arp回复，填充自己的arp表，发送icmp包给B；</p><p><strong>交换机收到已知单播，点到点转发给B；</strong></p><p>B收到icmp echo，回复icmp reply；</p><p><strong>交换机收到已知单播，点到点转发给A；</strong></p><p>A收到icmp回复，通信结束。</p><h3 id="交换机端口模式"><a href="#交换机端口模式" class="headerlink" title="交换机端口模式"></a>交换机端口模式</h3><p>交换机端口模式是交换机在数据转发时重要的依据，不同的端口模式会影响该接口的二层封装。</p><h4 id="access"><a href="#access" class="headerlink" title="access"></a>access</h4><p>access端口是用来接入终端的端口模式，思科的access口只能属于一个vlan，access口收发的流量不带ISL或802.1Q标签。</p><h4 id="trunk"><a href="#trunk" class="headerlink" title="trunk"></a>trunk</h4><p>trunk端口主要用于网络设备间的连接，如交换机-交换机，路由器-交换机等。turnk端口可以传输多个vlan的流量，通过ISL或802.1Q封装来区分他们。配置trunk端口前，需要配置trunk端口的封装方式，另外trunk模式端口的DTP模式自动为on。</p><h4 id="private-vlan"><a href="#private-vlan" class="headerlink" title="private-vlan"></a>private-vlan</h4><p>private-vlan是上述所讲的辅vlan端口，用于VLAN内的VLAN划分。</p><h4 id="dot1q-tunnel"><a href="#dot1q-tunnel" class="headerlink" title="dot1q tunnel"></a>dot1q tunnel</h4><p>dot1q tunnel是qinq模式，可以封装外层802.1Q标签，可更精确的区分业务。</p><h3 id="交换机端口模式配置"><a href="#交换机端口模式配置" class="headerlink" title="交换机端口模式配置"></a>交换机端口模式配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">###交换机端口模式配置</span><br><span class="line">switch(config-if)#switchport mode [access/trunk/dot1q-tunnel/private-vlan/dynamic]</span><br></pre></td></tr></table></figure><h1 id="以太网数据链路层简介"><a href="#以太网数据链路层简介" class="headerlink" title="以太网数据链路层简介"></a>以太网数据链路层简介</h1><h2 id="数据链路层的子层"><a href="#数据链路层的子层" class="headerlink" title="数据链路层的子层"></a>数据链路层的子层</h2><p>数据链路层，即二层，分为MAC子层和LLC子层。IEEE802.2定义了LLC子层，IEEE802.3定义了MAC子层，LLC子层在MAC子层之上。</p><h3 id="LLC子层"><a href="#LLC子层" class="headerlink" title="LLC子层"></a>LLC子层</h3><p>以太网 LLC 子层处理上层与下层之间的通信。 这通常是在网络软件和设备硬件之间进行的。 LLC 子层获取网络协议数据（通常是 IPv4 数据包）并加入控制信息，帮助将数据包传送到目的节点。 LLC 用于与应用层的上层进行通信，并将数据包转换到下层以便传输。</p><h3 id="MAC子层"><a href="#MAC子层" class="headerlink" title="MAC子层"></a>MAC子层</h3><p>MAC 构成数据链路层的较低子层，负责链路层面的寻址。 MAC 由硬件实现，通常在计算机网卡中实施。IEEE 802.3 标准指定了这些细节。</p><h2 id="以太网二层帧"><a href="#以太网二层帧" class="headerlink" title="以太网二层帧"></a>以太网二层帧</h2><p>以太网常见的二层mac帧有两种，第一种是Ethernet II，是由Xerox与DEC、Intel（DIX）在1982年制定，后来被定义在RFC1042；另一种是IEEE802.3，由IEEE802委员会在1985年定义，后被写进RFC1042。</p><h3 id="Ethernet-II"><a href="#Ethernet-II" class="headerlink" title="Ethernet II"></a>Ethernet II</h3><p>Ehernet II二层帧通常被广泛用在终端数据通信，上层协议支持IP,ARP等。帧结构如下</p><p><img src="/2022/04/25/switch-basic/ethernetii.png" alt="SWITCH ETHERNETII"></p><p>其中类型字段表示了上层协议类型，为大于1500的值，可通过类型字段大于1500分辨出这是EthernetII帧格式，如果小于1500则是IEEE802.3帧格式</p><h3 id="IEEE802-3"><a href="#IEEE802-3" class="headerlink" title="IEEE802.3"></a>IEEE802.3</h3><p>IEEE802.3二层帧通常用在网络设备间的通信，如STP，CDP等。帧结构如下</p><p><img src="/2022/04/25/switch-basic/802.png" alt="SWITCH 802"></p><p>其中长度字段表示了帧长度，为小于1500的值，可通过类型字段小于1500分辨出这是IEEE802.3帧格式，如果大于1500则是EthernetII帧格式</p><h2 id="CDP"><a href="#CDP" class="headerlink" title="CDP"></a>CDP</h2><p>CDP，Cisco Discovery Protocol，思科发现协议，是思科私有的邻居发现协议，所有的思科产品包括交换机、路由器、AC、服务器等都支持CDP。CDP工作在数据链路层，要求物理介质支持SNAP(SubNetwork Acess Protocol)协议，即必须使用IEEE802.3的二层帧，通过LLC子层来传递上层协议类型。CDP默认每60s向直连邻居发送CDP消息，如果180s收不到邻居的CDP消息则清除记录。</p><p>CDP报文发向组播mac 0100-0CCC-CCCC，事实上思科的一些二层私有协议都使用此组mac，如DTP,PAgP,VTP等。</p><p>CDP消息包含以下信息：</p><ul><li><p>设备标识符</p></li><li><p>地址</p></li><li><p>互相连接的物理端口号</p></li><li><p>设备类型</p></li><li><p>设备型号</p></li></ul><p>CDP报文抓包如下：</p><p><img src="/2022/04/25/switch-basic/cdp.png" alt="SWITCH CDP"></p><p>启用cdp命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">switch(config)#cdp run</span><br></pre></td></tr></table></figure><h2 id="LLDP"><a href="#LLDP" class="headerlink" title="LLDP"></a>LLDP</h2><p>LLDP，Link Layer Discovery Protocol，链路层发现协议，是一个公共的设备发现协议。由于网络设备种类日益繁多且拓扑复杂，LLDP可以跨设备厂商交换设备和拓扑信息。绝大多数设备都支持lldp，甚至windows10也有lldp功能。LLDP既支持SNAP格式封装也支持EthernetII封装，LLDP报文发向组mac 0180-C200-000E。LLDP主要完成以下任务：</p><ul><li><p>建立并护本地MIB</p></li><li><p>从本地MIB提取信息，封装至LLDPDU（LLDP数据单元）发送给邻居。有两种方式会触发更新，定时自动触发和状态变化触发</p></li><li><p>接受远程设备MIB并维护远程MIB</p></li><li><p>当MIB信息变化时发出通告</p></li></ul><p>LLDP工作模式有以下四种：</p><ul><li><p>TXRX：收发LLDPDU</p></li><li><p>TX：只发不收</p></li><li><p>RX：只收不发</p></li><li><p>DISABLED：不发不收（lldp功能未使能）</p></li></ul><p>LLDP EthernetII封装抓包如下：</p><p><img src="/2022/04/25/switch-basic/lldp.png" alt="SWITCH LLDP"></p><p>LLDP默认每30s发送LLDPDU，超120s每收到则清除条目。LLDPDU包含了设备的主要能力、管理地址、设备类型、型号和接口标识等。每个LLDP可携带共28种TLV（类型，长度，值），其中Chasis ID，TTL，Port和End是四个必须携带的类型。</p><p>启用lldp命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">switch(config)#lldp run</span><br></pre></td></tr></table></figure><h1 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h1><p>VLAN，virtual local area network，虚拟局域网。是一种将局域网划分为多个逻辑局域网的技术。每个LAN是一个广播域，，每个被划分的逻辑局域网即vlan也是一个广播域。关于以太网交换的技术大部分是和VLAN有关的。</p><p>VLAN技术实现了多业务组网隔离的需求。比如，在某公司某楼层，有市场部、财务部和技术部，这些部门的办公终端要求隔离。在没有vlan技术的情况下，不管每个部门多少人，我们都需要至少使用三台交换机部署三个LAN来满足需求，造成交换机端口资源浪费。在有vlan的情况下，只需根据楼层总人数规划交换机数量，不同部门的人划分到不同vlan即可。</p><p>相比传统LAN，使用VLAN的优势如下：</p><ul><li><p>有效利用交换机资源</p></li><li><p>提高了网络安全性</p></li><li><p>隔离故障域，二层故障域都比加大（stp故障可能影响一个lan，划分VLAN可以减小故障域）</p></li></ul><h2 id="VLAN封装协议"><a href="#VLAN封装协议" class="headerlink" title="VLAN封装协议"></a>VLAN封装协议</h2><p>VLAN可以跨交换机配置，不同VLAN 流量跨交换机通信时，通过VLAN号区分不同VLAN流量，即，将原有的二层帧使用特定的方式将vid信息封装进去。VLAN号有两种封装协议ISL和IEEE802.1Q，其中VLAN1002-1005是交换机保留vlan，1006-4094是扩展VLAN。交换机之间承载多VLAN的链路也称trunk（中继）链路。</p><h3 id="ISL"><a href="#ISL" class="headerlink" title="ISL"></a>ISL</h3><p>ISL，Inter-Swith link，跨交换机链路，是思科私有二层封装协议。封装结构如下：</p><p><img src="/2022/04/25/switch-basic/isl.jpg" alt="SWITCH ISL"></p><p>ISL使用26字节头和4字节尾将原有二层帧封装，其中VID字段有15bit实际只用到10bit即1024，所以使用ISL封装的VLAN号最多只有1024个。</p><h3 id="IEEE802-1Q"><a href="#IEEE802-1Q" class="headerlink" title="IEEE802.1Q"></a>IEEE802.1Q</h3><p>IEEE802.1Q是IEEE对二层的封装规范，是业界标准。802.1q封装结构如下：</p><p><img src="/2022/04/25/switch-basic/dot1q.jpg" alt="SWITCH DOT1Q"></p><p>802.1Q在二层帧中间插入了4个字节，其中VID字段有12bit，即使用802.1Q封装的VLAN号最多可以有4096个。</p><p>相比较与ISL，IEEE802.1Q封装的字节更少，占用带宽较少；但是ISL封装不改变原有帧结构，处理速度会略占优势。总体来说，ISL尽仅思科设备上可用，目前基本都会使用IEEE802.1Q封装协议。可以用以下命令配置交换机trunk封装协议：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">switch(config-if)#switchport trunk encapsulation [isl/dot1q] </span><br></pre></td></tr></table></figure><h4 id="本征VLAN"><a href="#本征VLAN" class="headerlink" title="本征VLAN"></a>本征VLAN</h4><p>802.1Q将不打VLAN标签的vlan成为native vlan，即本征vlan，没有vlan标签的流量会被转发至本征vlan。默认本征vlan为vlan 1，每台交换机本征vlan只能有一个。可以通过一下命令修改本征vlan：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">switch(config-if)#switchport trunk native vlan 2</span><br></pre></td></tr></table></figure><h4 id="QinQ"><a href="#QinQ" class="headerlink" title="QinQ"></a>QinQ</h4><p>QinQ，即802.1Q in 802.1Q，是一种隧道技术，相当于二层帧插入了二个802.1Q标签。用于区分不同的流量。例如，在广域网传输时，运营商根据外层标签指派路径，帧被送达后，局域网交换机根据内层标签区分vlan。</p><h2 id="vlan相关命令"><a href="#vlan相关命令" class="headerlink" title="vlan相关命令"></a>vlan相关命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#定义vlan</span><br><span class="line">switch(config)# vlan 888</span><br><span class="line"></span><br><span class="line">#划分vlan</span><br><span class="line">switch(config-if)# switchport</span><br><span class="line">switch(config-if)# switchport mode access</span><br><span class="line">switch(config-if)# switchport access vlan 888</span><br><span class="line"></span><br><span class="line">#验证vlan</span><br><span class="line">switch# show vlan brief</span><br></pre></td></tr></table></figure><h2 id="DTP"><a href="#DTP" class="headerlink" title="DTP"></a>DTP</h2><p>DTP，Dynamic Trunk Protocol，动态trunk协议，是思科私有的用于协商trunk链路的协议。DTP也必须使用IEEE802.3以太网封装，使用LLC子层传递上层协议类型。DTP用于思科设备协商交换机端口是否为trunk模式。DTP携带本地的trunk信息，包括DTP模式和封装方式。DTP抓包如下：<br><img src="/2022/04/25/switch-basic/dtp.png" alt="SWITCH DTP"></p><p>DTP工作有三种种模式，on，Desireable，Auto。</p><h3 id="On模式"><a href="#On模式" class="headerlink" title="On模式"></a>On模式</h3><p>若某端口处于On模式。则该端口不协商，直接以本地配置开启turnk模式。处于On模式的端口会持续发送DTP消息。</p><h3 id="Desirable模式"><a href="#Desirable模式" class="headerlink" title="Desirable模式"></a>Desirable模式</h3><p>若某端口处于Desirable模式下，该端口主动发送DTP消息，同时也监听DTP消息，接受到有效DTP后会根据消息内容配置端口trunk。</p><h3 id="Auto模式"><a href="#Auto模式" class="headerlink" title="Auto模式"></a>Auto模式</h3><p>若某端口处于Auto模式下，该端口不主动发送DTP消息，但收到有效DTP消息会成为turnk端口。交换机默认处于DTP Auto模式下。</p><h3 id="DTP配置"><a href="#DTP配置" class="headerlink" title="DTP配置"></a>DTP配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">###DTP配置</span><br><span class="line">####DTP on 模式</span><br><span class="line">switch(config-if)# switchport mode trunk</span><br><span class="line"></span><br><span class="line">####DTP 其它模式</span><br><span class="line">switch(config-if)# switchport mode dynamic [auto/desirable]</span><br></pre></td></tr></table></figure><h2 id="VTP"><a href="#VTP" class="headerlink" title="VTP"></a>VTP</h2><p>VTP，VLAN Trunk Protocol，VLAN中继协议。类似于CDP，VTP也是一个目的mac为组播0100-0CCC-CCCC的二层消息协议，也必须使用802.3以太网封装。最新版本为VTPv3。</p><h3 id="VTP域"><a href="#VTP域" class="headerlink" title="VTP域"></a>VTP域</h3><p>若要使用VTP，必须先指定VTP域名，一台交换机只能加入一个VTP域。所有具有相同VTP域名的交换机成为一个VTP域，并在VTP域内交换VTP消息。没有更新的情况下，vtp消息每5min更新一次，vtp消息主要携带本地vlan信息（v3版本增加mst信息），抓包如下：</p><p><img src="/2022/04/25/switch-basic/vtp.png" alt="SWITCH VTP"></p><h3 id="VTP工作模式"><a href="#VTP工作模式" class="headerlink" title="VTP工作模式"></a>VTP工作模式</h3><h4 id="server模式"><a href="#server模式" class="headerlink" title="server模式"></a>server模式</h4><p>vtp配置为server模式后，管理员可以编辑本地vlan，包括删除，增加，修改名字。Server模式是交换机默认的vtp模式。收到更新的vtp消息会同步自己的vlan。</p><h4 id="client模式"><a href="#client模式" class="headerlink" title="client模式"></a>client模式</h4><p>vtp配置为client模式后，本地vlan信息不可更改，收到更新的vtp消息会同步自己的vlan。</p><h4 id="transparent模式"><a href="#transparent模式" class="headerlink" title="transparent模式"></a>transparent模式</h4><p>vtp配置为transparent模式后，可以对本地VLAN进行修改，并透传vtp，但不使用该vtp信息，也不发送vtp信息。</p><h3 id="VTP修订版本号"><a href="#VTP修订版本号" class="headerlink" title="VTP修订版本号"></a>VTP修订版本号</h3><p>VTP修订版本号是指该VTP域内vlan被编辑的次数。一般修改VTP域名后，修订版本号置0，以后每次修改一次vlan信息（v3版本增加mst）修订号+1。<u><strong>所以判断VTP消息新旧的唯一依据是修订号，和工作模式无关</strong></u>。</p><h3 id="VTPv3"><a href="#VTPv3" class="headerlink" title="VTPv3"></a>VTPv3</h3><p>VTPv3在vtp消息种增加了多实例生成树mst的配置信息，除了同步VLAN信息，还可以同步mst信息。另外，开启VTPv3后可以设置VTP密码，防止VTP配置被随意改动。</p><h3 id="VTP-Prunning"><a href="#VTP-Prunning" class="headerlink" title="VTP Prunning"></a>VTP Prunning</h3><p>VTP Prunning，VTP裁剪是一个二层网络优化的功能。VTP裁剪可以减少trunk端口不必要的vlan通信，减少广播数量。比如某交换机只有VLAN 10，那么VLAN 20等其它VLAN信息就没有必要发给他。</p><h3 id="VTP配置"><a href="#VTP配置" class="headerlink" title="VTP配置"></a>VTP配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">###vtp v3 配置</span><br><span class="line">switch(config)# vtp domain somedomain</span><br><span class="line">switch(config)# vtp version 3</span><br><span class="line">switch(config)# vtp mode [server/client/transparent] mst</span><br><span class="line">switch(config)# vtp mode [server/client/transparent] vlan</span><br><span class="line">switch(config)# vtp password somepassword hidden</span><br><span class="line">switch(config)# vtp prunning</span><br></pre></td></tr></table></figure><h2 id="PVLAN"><a href="#PVLAN" class="headerlink" title="PVLAN"></a>PVLAN</h2><p>PVLAN，Private VLAN，私有VLAN。PVLAN将一个VLAN内部广播域继续进行划分，实现更精细的交换端口隔离，相当于在VLAN内创建VLAN。配置PVLAN时，VTP必须为transparent模式。思科给出的两个应用场景是：</p><ul><li><p>运营商可以给不同的用户分配同一个子网IP，通过PVLAN来隔离它们</p></li><li><p>在某些安全要求下，可以提供二层隔离</p></li></ul><h3 id="PVLAN分类"><a href="#PVLAN分类" class="headerlink" title="PVLAN分类"></a>PVLAN分类</h3><p>PVLAN分类如下</p><ul><li><p>Primary Vlan 主VLAN</p></li><li><p>Secondary Vlans 辅VLAN，辅VLAN默认不能与外界VLAN通信</p><ul><li><p>Isolated Vlan 隔离VLAN，一个主VLAN内只能由一个隔离VLAN</p></li><li><p>Community VLANs 联盟VLAN，一个主VLAN可以有多个联盟VLAN</p></li></ul></li></ul><h3 id="PVLAN端口类型"><a href="#PVLAN端口类型" class="headerlink" title="PVLAN端口类型"></a>PVLAN端口类型</h3><p>host isolated 隔离端口，此端口类型属于隔离VLAN，技能与混杂端口通信</p><p>host community 联盟端口，此端口类型属于一个联盟VLAN，技能与同联盟VLAN和混杂端口通信</p><p>promiscuous 混杂端口，此端口类型不属于任何辅VLAN，通常连接路由器</p><p>不同端口类型之间的可达情况如下：</p><table><thead><tr><th>端口类型</th><th>隔离端口</th><th>混杂端口</th><th>VLAN10联盟端口</th><th>VLAN20联盟端口</th></tr></thead><tbody><tr><td>隔离端口</td><td>拒绝</td><td>接受</td><td>拒绝</td><td>拒绝</td></tr><tr><td>混杂端口</td><td>接受</td><td>接受</td><td>接受</td><td>接受</td></tr><tr><td>VLAN10联盟端口</td><td>拒绝</td><td>接受</td><td>接受</td><td>拒绝</td></tr><tr><td>VLAN20联盟端口</td><td>拒绝</td><td>接受</td><td>拒绝</td><td>接受</td></tr></tbody></table><h3 id="PVLANSVI三层映射"><a href="#PVLANSVI三层映射" class="headerlink" title="PVLANSVI三层映射"></a>PVLANSVI三层映射</h3><p>默认辅VLAN无法与其它VLAN通信，除非将其映射到主VLAN的三层SVI口。映射后，辅VLAN技能通过主VLAN的SVI与外界通信。</p><h3 id="PVLAN配置"><a href="#PVLAN配置" class="headerlink" title="PVLAN配置"></a>PVLAN配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">###PVLAN配置</span><br><span class="line">####定义PVLAN</span><br><span class="line">switch(config)# vlan 10</span><br><span class="line">switch(config-vlan)# private-vlan [primary/isolated/community]</span><br><span class="line"></span><br><span class="line">####辅VLAN关联主VLAN，假设vlan10为主vlan</span><br><span class="line">switch(config)# vlan 10</span><br><span class="line">switch(config-vlan)# private-vlan association 11-19</span><br><span class="line"></span><br><span class="line">####配置端口模式</span><br><span class="line">switch(config)# int e0/0</span><br><span class="line">switch(config-if)# switchport mode private-vlan [host/promiscuous]</span><br><span class="line"></span><br><span class="line">####pvlan host模式下划分VLAN</span><br><span class="line">switch(config-if)# switchport private-vlan host-association 10 19</span><br><span class="line"></span><br><span class="line">####pvlan promiscuous模式下配置下游辅vlan</span><br><span class="line">switch(config-if)# switchport mapping 10 11-19</span><br><span class="line"></span><br><span class="line">####SVI三层映射</span><br><span class="line">switch(config)# int vlan 10</span><br><span class="line">switch(config-if)# private-vlan mapping 11-19</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;交换设备&quot;&gt;&lt;a href=&quot;#交换设备&quot; class=&quot;headerlink&quot; title=&quot;交换设备&quot;&gt;&lt;/a&gt;交换设备&lt;/h1&gt;&lt;h2 id=&quot;中继器Repeater&quot;&gt;&lt;a href=&quot;#中继器Repeater&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="路由交换RS" scheme="https://arclogicr.github.io/categories/%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2RS/"/>
    
    
    <category term="network" scheme="https://arclogicr.github.io/tags/network/"/>
    
    <category term="switching" scheme="https://arclogicr.github.io/tags/switching/"/>
    
    <category term="vlan" scheme="https://arclogicr.github.io/tags/vlan/"/>
    
    <category term="vtp" scheme="https://arclogicr.github.io/tags/vtp/"/>
    
  </entry>
  
  <entry>
    <title>IPv6地址</title>
    <link href="https://arclogicr.github.io/2022/04/17/ipv6/"/>
    <id>https://arclogicr.github.io/2022/04/17/ipv6/</id>
    <published>2022-04-17T12:54:13.000Z</published>
    <updated>2023-02-17T09:11:14.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IPv6简介"><a href="#IPv6简介" class="headerlink" title="IPv6简介"></a>IPv6简介</h2><h3 id="什么是IPv6"><a href="#什么是IPv6" class="headerlink" title="什么是IPv6"></a>什么是IPv6</h3><p>IPv6，Internet Protocol version 6（网际协议第六版），IPv4的升级版本。和IPv4类似，IPv6是一种逻辑编址方案，用于网络层主机到主机的通信。</p><h3 id="为什么使用IPv6"><a href="#为什么使用IPv6" class="headerlink" title="为什么使用IPv6"></a>为什么使用IPv6</h3><p>IPv4初期由于其协议简单、易于物理实现等优势，被广泛使用。随着互联网技术迅速发展，IPv4在很多方面已经无法满足现有需求，IPv6的问世解决了IPv4的很多弊端。</p><h4 id="IPv4的局限性-x2F-IPv6的优势"><a href="#IPv4的局限性-x2F-IPv6的优势" class="headerlink" title="IPv4的局限性&#x2F;IPv6的优势"></a>IPv4的局限性&#x2F;IPv6的优势</h4><ul><li>地址空间</li></ul><p>IPv4的理论可用地址数为2的32次方约43亿个，已经无法满足巨量终端的入网需求，只能依靠NAT等技术减少公网IP的使用。实际上在2019年11月25日欧洲RIPE NCC宣布IPv4地址正式耗尽。</p><p>IPv6地址采用128bit标识，理论上可用地址数是2的128次方，为全部IPv4地址的2的96次方倍，拥有近乎无限的地址空间。</p><ul><li>安全</li></ul><p>IPv4在设计上并没有考虑网络层的安全问题，当时认为安全是上层才需要负责的。</p><p>IPv6集成了IPSec，支持IPSec的认证和加密。由于充足的地址空间，使得层次化地址分配成为可能，容易溯源。对于攻击者，在有限的时间内，无法遍历巨量的IPv6地址。</p><ul><li>通信模型</li></ul><p>由于NAT的大量使用，破坏了端到端的模型，由此衍生了一些列繁琐的配置（如端口映射）</p><p>IPv6地址充足，无需使用NAT。</p><ul><li>路由聚合</li></ul><p>互联网在世界各地发展并不均衡，所以IPv4在分配时各地区所获得的地址并不连续。这会导致每个地区的公网路由无法被聚合，路由表会相当庞大，对路由设备性能要求极高。</p><p>IPv6可以很方便的进行层次化网络部署，方便路由聚合，提高转发效率。</p><ul><li>配置</li></ul><p>IPv4没有重编功能，网卡原则上职能配置一个IPv4地址，而一个网卡可以配置多个并重的IPv6问题，简化重编值的复杂性。</p><p>IPv6内置自动配置，可使得主机自动发现网络并获取IPv6地址，提高管理效率。</p><ul><li>处理效率</li></ul><p>IPv4包头字段相对较多，对网络设备有一定性能要求</p><p>IPv6去除了标志位、段偏移、头部校验和、选项等字段，只增加流标签域方便做QoS，因此IPv6报头更为简化，提高处理效率。</p><h2 id="IPv6地址"><a href="#IPv6地址" class="headerlink" title="IPv6地址"></a>IPv6地址</h2><h3 id="IPv6地址结构"><a href="#IPv6地址结构" class="headerlink" title="IPv6地址结构"></a>IPv6地址结构</h3><p>一个IPv6地址由128个bit组成。一个十六进制数可以表示4个bit，通常用32个16进制数四个一组表示IPv6地址。如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2001:0db8:02de:0000:0000:0000:0000:0e13/64</span><br></pre></td></tr></table></figure><p>在一个IPv6地址中分为前缀和接口号两个部分。前缀和IPv4中网络号类似，用于标识一个网络；接口号和IPv4中主机号类似，用于标识终端。上述IPv6地址所在的网络是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2001:0db8:02de:0000:0000:0000:0000:0000/64</span><br></pre></td></tr></table></figure><h3 id="IPv6地址表示"><a href="#IPv6地址表示" class="headerlink" title="IPv6地址表示"></a>IPv6地址表示</h3><h4 id="IPv6地址的简化表示"><a href="#IPv6地址的简化表示" class="headerlink" title="IPv6地址的简化表示"></a>IPv6地址的简化表示</h4><p>IPv6地址采用冒号分十六进制的方式表示。128bit长的IPv6地址可以表示8组4个十六进制数，用冒号隔开（如上述IPv6地址）。</p><p>其中，</p><ul><li><p>每一组的前导0可以省略</p></li><li><p>连续的0可以用::来省略</p></li><li><p>一个IPv6地址中只能使用一次::来省略连续的0（不然无法唯一确定连续0的个数）。</p></li></ul><p>如上述IPv6地址可简写为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2001:db8:2de::e13/64</span><br></pre></td></tr></table></figure><h4 id="URL的IPv6表示"><a href="#URL的IPv6表示" class="headerlink" title="URL的IPv6表示"></a>URL的IPv6表示</h4><p>在URL中，需要使用[]来确定IPv6地址，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://[2001:ab:123::cdef]:8080/index.html</span><br></pre></td></tr></table></figure><h4 id="IEEE-EUI-64规范"><a href="#IEEE-EUI-64规范" class="headerlink" title="IEEE EUI-64规范"></a>IEEE EUI-64规范</h4><p>IEEE EUI-64规范定义了如何将网络接口的MAC地址转换为IPv6接口标识。网卡物理地址由48bit组成，使用十六进制可表示为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0050:A1AB:CDEF</span><br></pre></td></tr></table></figure><p>MAC地址的前24位（0050A1）为厂商标识，后24位（ABCDEF）为扩展标识符。从高位数，第7位是0表示了MAC地址本地唯一。</p><p>MAC转换位IPv6接口方法：</p><p>将48位的MAC地址从中间分开，插入一个固定数值FFFE</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0050:A1AB:CDEF--&gt;0050:A1FF:FEAB:CDEF</span><br></pre></td></tr></table></figure><p>然后将第7个比特位反转，如果原来是0，就变为1,如果原来是1，就变为0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0050:A1FF:FEAB:CDEF--&gt;0250:A1FF:FEAB:CDEF</span><br></pre></td></tr></table></figure><p>这种由MAC地址产生IPv6地址接口标识的方法可以减少配置的工作量，尤其是当采用无状态地址自动配置时，只需要获取一个IPv6前缀就可以与接口标识形成IPv6地址。但是使用这种方式最大的缺点是任何人都可以通过二层MAC地址推算出三层IPv6地址。</p><h3 id="IPv6地址分类"><a href="#IPv6地址分类" class="headerlink" title="IPv6地址分类"></a>IPv6地址分类</h3><p>IPv6没有广播的概念，所以没有ARP包，也没有广播地址。IPv6地址分为单播、组播和任意播。</p><h4 id="单播"><a href="#单播" class="headerlink" title="单播"></a>单播</h4><p>单播地址用于一对一的连接，主要有以下几种类型</p><h5 id="可聚合全球单播地址（Aggregate-Global-Unicast-Address）"><a href="#可聚合全球单播地址（Aggregate-Global-Unicast-Address）" class="headerlink" title="可聚合全球单播地址（Aggregate Global Unicast Address）"></a>可聚合全球单播地址（Aggregate Global Unicast Address）</h5><p>可聚合全球单播地址类似于IPv4的公网地址，可在全球路由。目前前三位为001的IPv6地址被用作可聚合全球单播地址，即2000:&#x2F;3，占了12.5%的IPv6地址空间</p><p><strong>IPv6全球可路由地址的分配</strong></p><p>由于IPv6采用分级编址，IPv6全球可路由地址前缀由地址分配机构逐级向下分配：</p><table><thead><tr><th>前缀长度</th><th>适用场景</th></tr></thead><tbody><tr><td>32</td><td>RIR&#x2F;NIR（区域&#x2F;国家互联网注册机构）分配给有 ASN 的运营商、互联网公司、大型企业。是地址最小分配单元（再小就不给了）。</td></tr><tr><td>40</td><td>运营商向有多个（256个以内）站点和数据中心的大型企业分配的前缀</td></tr><tr><td>44</td><td>运营商向有多个（16个以内）站点和数据中心的中型企业分配的前缀</td></tr><tr><td>48</td><td>运营商向中小客户分配的常见前缀长度。或大中企业内一个站点的前缀</td></tr><tr><td>56</td><td>宽带运营商给家庭用户和小微企业分配的最小前缀长度（最大子网大小）</td></tr><tr><td>64</td><td>末端设备子网，&#x2F;64 是很多协议硬性要求的（IPv6 无广播风暴风险）</td></tr><tr><td>127</td><td>路由器点对点链路，此处不是为了节约地址而是防止一种资源耗尽型攻击</td></tr></tbody></table><h5 id="链路本地地址（Link-Local-Address）"><a href="#链路本地地址（Link-Local-Address）" class="headerlink" title="链路本地地址（Link-Local Address）"></a>链路本地地址（Link-Local Address）</h5><p>链路本地地址是一个<strong>只在本链路有效</strong>的IPv6地址。在一个节点启用IPv6后，每个接口都会生成以一个链路本地地址。链路本地地址前10bit固定，为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fe80::/10</span><br></pre></td></tr></table></figure><p>其后64位通常根据EUI-64格式来构造，但也有的终端是根据一定算法生成（出于安全原因），如：windows。</p><p>链路本地地址唯一标识一个节点，在本地链路看到下一跳都是对端的Link Local地址，在网络重新编址过程中，节点和路由器的Link Local地址不会发生变化，可以很容易地做一个修改，不用担心中断。</p><h5 id="唯一本地地址-（Unique-Local-Address）"><a href="#唯一本地地址-（Unique-Local-Address）" class="headerlink" title="唯一本地地址 （Unique Local Address）"></a>唯一本地地址 （Unique Local Address）</h5><p>唯一本地地址类似于IPv4私网地址，今能在站点本地使用。由于站点本地地址被废除，唯一本地地址用来代替站点本地地址。</p><p>固定前缀为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FC00::/7</span><br></pre></td></tr></table></figure><p><img src="/2022/04/17/ipv6/ulc.png" alt="IPV6"></p><p>其中，</p><p>L为标志位，值为1表示该地址为在本地网络范围内使用的地址；为0被保留，相当于只有FD00::&#x2F;8被使用</p><p>Global ID为全球唯一前缀；随机产生</p><p>Subnet ID为子网ID；用于划分子网</p><p>Interface ID；接口标识</p><p>唯一本地地址拥有全球唯一前缀，可以在私有网络之间通信。</p><h5 id="站点本地地址-（Site-Local-Address）已弃用"><a href="#站点本地地址-（Site-Local-Address）已弃用" class="headerlink" title="*站点本地地址 （Site-Local Address）已弃用"></a>*站点本地地址 （Site-Local Address）已弃用</h5><p>IPv6的保留地址，类似于IPv4的私网地址，<strong>只能在站点本地使用，无法在公网路由</strong>。站点本地地址占整个地址空间0.1%。</p><p>站点本地地址前10bit固定，为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FEC0::/10</span><br></pre></td></tr></table></figure><p>后54为左右子网标识，最后64为用于接口标识。</p><h5 id="未指定地址-（Unspecified-Address）"><a href="#未指定地址-（Unspecified-Address）" class="headerlink" title="未指定地址 （Unspecified Address）"></a>未指定地址 （Unspecified Address）</h5><p>未指定地址表示地址未被指定，或者表示默认路由（所有路由），形式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0:0:0:0:0:0:0:0 或 ::</span><br></pre></td></tr></table></figure><h5 id="环回地址-（Loopback-Address）"><a href="#环回地址-（Loopback-Address）" class="headerlink" title="环回地址 （Loopback Address）"></a>环回地址 （Loopback Address）</h5><p>换回地址表示节点自己，在本节点有效，和IPv4类似，形式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0:0:0:0:0:0:0:1 或::1</span><br></pre></td></tr></table></figure><h5 id="IPv4映射的IPv6地址-（IPv4-Mapped-IPv6-Address）"><a href="#IPv4映射的IPv6地址-（IPv4-Mapped-IPv6-Address）" class="headerlink" title="IPv4映射的IPv6地址 （IPv4-Mapped IPv6 Address）"></a>IPv4映射的IPv6地址 （IPv4-Mapped IPv6 Address）</h5><p>IPv4映射的IPv6地址是包含IPv4的IPv6地址，用于双栈的本地范围</p><p>其中高80bit为0，后跟16bit的1，在跟IPv4地址，如：</p><p>IPv4地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100.100.100.100</span><br></pre></td></tr></table></figure><p>的IPv4映射的IPv6地址为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::ffff:6464:6464</span><br></pre></td></tr></table></figure><h5 id="IPv4兼容地址-（IPv4-Compatible-IPv6-Address）-已弃用"><a href="#IPv4兼容地址-（IPv4-Compatible-IPv6-Address）-已弃用" class="headerlink" title="*IPv4兼容地址 （IPv4-Compatible IPv6 Address） 已弃用"></a>*IPv4兼容地址 （IPv4-Compatible IPv6 Address） 已弃用</h5><p> IPv4兼容的IPv6地址是包含IPv4的IPv6地址，用于在IPv4网络上建立自动隧道，传输IPv6包</p><p>其中高96比特设置为0，后面设置为32bit的IPv4地址，如：</p><p>IPv4地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100.100.100.100</span><br></pre></td></tr></table></figure><p>的IPv4兼容的IPv6地址为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::6464:6464</span><br></pre></td></tr></table></figure><p>这种机制不太完善，后被弃用</p><h4 id="组播"><a href="#组播" class="headerlink" title="组播"></a>组播</h4><p>组播用于一对多的通信、</p><p>组播前缀固定FF00::&#x2F;8，占用约0.38%的IPv6地址空间</p><p><img src="/2022/04/17/ipv6/multi.png" alt="IPV6 MULTI"></p><p>其中，</p><p>FF为前8位固定值</p><p>Flag标志位0000永久保留</p><p>Scope传播范围</p><p>Scope定义了组播地址的范围，取值与范围如下：</p><table><thead><tr><th>十六进制</th><th>范围</th></tr></thead><tbody><tr><td>1</td><td>本地接口</td></tr><tr><td>2</td><td>本地链路</td></tr><tr><td>3</td><td>本地子网</td></tr><tr><td>4</td><td>本地管理</td></tr><tr><td>5</td><td>本地站点</td></tr><tr><td>8</td><td>组织机构</td></tr><tr><td>E</td><td>全球</td></tr></tbody></table><p>RFC2373建议将后112的前80为置0，后32位为组播的组ID</p><h5 id="被请求节点组播地址-（Solicited-Node-Multicast-Address）"><a href="#被请求节点组播地址-（Solicited-Node-Multicast-Address）" class="headerlink" title="被请求节点组播地址 （Solicited-Node Multicast Address）"></a>被请求节点组播地址 （Solicited-Node Multicast Address）</h5><p>被请求节点组播地址根据每一个单播和任意播地址生成一个对应的组播地址，并加入该组播组。被请求节点组播地址只在本地有效。被请求节点组播地址用于邻居发现和DAD地址重复检测。</p><p>被请求节点组播地址固定前缀为FF02::1:FF00:0000&#x2F;104，将IPv6地址的后24位填充到被请求节点组播地址的接口标识就组成了改IPv6地址的被请求节点组播地址。如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2001::ABCD:ABCD/64</span><br></pre></td></tr></table></figure><p>对应的被请求节点组播地址为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FF02::1:FFCD:ABCD/104</span><br></pre></td></tr></table></figure><p>如图，在路由器的一个接口上开启IPv6功能，然后查看该接口的ipv6的状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int e0/0</span><br><span class="line"> ipv6 enable</span><br><span class="line">end</span><br><span class="line">show ipv6 int e0/0</span><br></pre></td></tr></table></figure><p>显示结果如下：</p><p><img src="/2022/04/17/ipv6/addr.png" alt="IPV6 ADDR"></p><p>其中可以看到IPv6使能后，接口生成了链路本地地址，为FE80::A8BB:CCFF:FE00:200，并为它生成了被请求节点组播地址FF02::1:FF00:200</p><p>由于被请求节点组播地址是可以根据IPv6地址容易计算出来的，当需要解析链路上IPv6的二层地址时，可以通过NS报文发送至改IPv6的被请求节点组播地址，实现了类似IPv4中的ARP解析功能。</p><h4 id="任意播"><a href="#任意播" class="headerlink" title="任意播"></a>任意播</h4><p>任意播本质是单播。任意播标识一组设备，需在网络设备如路由器上定义一个单播IPv6地址为任意播地址，当路由器收到目的地址为任意播地址时，会将其转发到最近的任意播地址。这种机制在网络层面上起到了类似于CDN的作用，就近分配任务。</p><p>IPv6没有为任意播单独定义地址空间，任意播和单播使用相同地址空间，任意播不可以作为源IPv6地址。</p><h4 id="IPv6报文格式"><a href="#IPv6报文格式" class="headerlink" title="IPv6报文格式"></a>IPv6报文格式</h4><p>IPv6报文由IPv6基本报头、IPv6扩展报头和上层协议数据三部分组成</p><h5 id="IPv6基本报头"><a href="#IPv6基本报头" class="headerlink" title="IPv6基本报头"></a>IPv6基本报头</h5><p>IPv6报头格式如下</p><p><img src="/2022/04/17/ipv6/header.png" alt="IPV6 HEADER"></p><p>其中</p><p>Version，为版本号，固定为6</p><p>Traffic Class，为流类别，与IPv4中TOS类似，定义流的类别</p><p>Flow Label，为流标签，新增字段，区分实时流量，网络设备可根据这个字段更高效的转发</p><p>Payload Length，为有效载荷长度，16bit，表示出基本头以外的载荷（拓展头和上层数据）长度，超过65535会置0</p><p>Next Header，为下一个报头，即紧跟在基本报头后的协议类型（可以是拓展报头也可以是上层协议）</p><p>Hop Limit，为跳数限制，类似于IPv4中的TTL，定义了IPv6数据包可以经过的最大跳数</p><p>Source Address，为源IPv6地址</p><p>Destination Address，为目的IPv6地址</p><h5 id="IPv6拓展报头"><a href="#IPv6拓展报头" class="headerlink" title="IPv6拓展报头"></a>IPv6拓展报头</h5><p>IPv4中，IPv4报头包含可选字段Options，这些选项会增加IPv4报头长度，校验和也会改变，在实际中很少使用。</p><p>IPv6不使用Options字段，改用拓展报头。IPv6拓展报头位于IPv6基本报头与上层数据之间，根据需要可任意添加0个或多个拓展报头。下一级拓展报头通过上一级报头的Next Header字段指明协议类型。拓展报头格式如下：</p><p><img src="/2022/04/17/ipv6/ext_header.png" alt="IPV6 EXTHEADER"></p><p>RFC2460中定义了6种IPv6拓展头</p><table><thead><tr><th>IPv6拓展头</th><th>Next Header</th><th>作用</th></tr></thead><tbody><tr><td>逐跳选项</td><td>0</td><td>巨型载荷；设备提示；RSVP</td></tr><tr><td>目的选项</td><td>60</td><td>携带目的节点才会处理的信息</td></tr><tr><td>路由</td><td>43</td><td>携带IPv6路由信息，强制指定数据包经过特点设备</td></tr><tr><td>分段</td><td>44</td><td>IPv6也受MTU限制，通过分段拓展报头进行分段</td></tr><tr><td>认证</td><td>51</td><td>由IPsec使用，提供认证、完整性和重放等保护</td></tr><tr><td>封装安全净载</td><td>50</td><td>由IPsec使用，类似于AH</td></tr></tbody></table><p>IPv6大包ping分段拓展头抓包结果如下：</p><p><img src="/2022/04/17/ipv6/frag.png" alt="IPV6 FRAG"></p><p>可以看到，IPv6基本头中的Next Header为分段拓展头协议号44，IPv6拓展报头中的Next Header指向ICMPv6协议号58</p><p>当超过一种扩展报头被用在同一个IPv6报文里时，不是所有的拓展报头都需要被处理，但报头必须按照下列顺序出现：</p><ul><li>IPv6基本报头</li><li>逐跳选项扩展报头</li><li>目的选项扩展报头</li><li>路由扩展报头</li><li>分段扩展报头</li><li>认证扩展报头</li><li>封装安全有效载荷扩展报头</li><li>目的选项扩展报头</li><li>上层协议数据报文</li></ul><p>目的选项拓展报头可能出现1或2次，其它拓展报头只能出现一次。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;IPv6简介&quot;&gt;&lt;a href=&quot;#IPv6简介&quot; class=&quot;headerlink&quot; title=&quot;IPv6简介&quot;&gt;&lt;/a&gt;IPv6简介&lt;/h2&gt;&lt;h3 id=&quot;什么是IPv6&quot;&gt;&lt;a href=&quot;#什么是IPv6&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="网络基础" scheme="https://arclogicr.github.io/categories/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="network" scheme="https://arclogicr.github.io/tags/network/"/>
    
    <category term="tcp/ip" scheme="https://arclogicr.github.io/tags/tcp-ip/"/>
    
  </entry>
  
  <entry>
    <title>BGP学习笔记</title>
    <link href="https://arclogicr.github.io/2022/04/02/bgp-notes/"/>
    <id>https://arclogicr.github.io/2022/04/02/bgp-notes/</id>
    <published>2022-04-02T11:18:05.000Z</published>
    <updated>2023-01-17T08:34:25.717Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>BGP全称边界网关协议（<strong>Boarder Gateway Protocol</strong>）,是运行在自治系统（AS）之间传递路由信息的协议</p><p>AS定义（rfc1930）</p><p>The classic definition of an Autonomous System is a set of routers under a single technical administration, using an interior gateway<br>protocol and common metrics to route packets within the AS, and using an exterior gateway protocol to route packets to other ASes.</p><p>AS的经典定义是一组被单一技术管理的路由器，使用IGP和统一的metric在AS内路由分组，并使用EGP与其它AS路由分组。</p><h3 id="基本特点"><a href="#基本特点" class="headerlink" title="基本特点"></a>基本特点</h3><ul><li><p>路径矢量路由协议，基于TCP 179端口</p></li><li><p>首次建立连接做完整路由信息更新，以后就只做增量更新、触发更新</p></li><li><p>有丰富的属性可以灵活选路</p></li><li><p>被设计用于特大网络，例如Internet</p></li></ul><h3 id="三张表"><a href="#三张表" class="headerlink" title="三张表"></a>三张表</h3><h4 id="邻居表"><a href="#邻居表" class="headerlink" title="邻居表"></a>邻居表</h4><p>用于记录BGP对等体的邻居信息，包括状态信息，AS号等等，邻居不需要直连</p><h4 id="BGP表"><a href="#BGP表" class="headerlink" title="BGP表"></a>BGP表</h4><p>用于记录学习到的路由详细信息，包括BGP的路由属性，最优路由等</p><h4 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h4><p>BGP提交最优路由到路由表</p><h3 id="BGP报文"><a href="#BGP报文" class="headerlink" title="BGP报文"></a>BGP报文</h3><h4 id="OPEN"><a href="#OPEN" class="headerlink" title="OPEN"></a>OPEN</h4><p>用于建立一个BGP连接，包括holdtime，RID，AS等</p><p><img src="/2022/04/02/bgp-notes/open.jpg" alt="BGP OPEN"></p><h4 id="KEEPALIVE"><a href="#KEEPALIVE" class="headerlink" title="KEEPALIVE"></a>KEEPALIVE</h4><p>用于维护邻居，默认60s一次，holdtime180s</p><p><img src="/2022/04/02/bgp-notes/keepalive.jpg" alt="BGP KEEPALIVE"></p><h4 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h4><p>用于更新路径信息，一次可以通告一条路由和它的多个属性；也可以一次通告多个路由但它们的所有属性必须相同；一次可撤销多个路由</p><p><img src="/2022/04/02/bgp-notes/update.jpg" alt="BGP UPDATE"></p><h4 id="NOTIFICATION"><a href="#NOTIFICATION" class="headerlink" title="NOTIFICATION"></a>NOTIFICATION</h4><p>用于传递错误信息</p><p><img src="/2022/04/02/bgp-notes/notification.jpg" alt="BGP NOTIFICATION"></p><h4 id="REFRESH"><a href="#REFRESH" class="headerlink" title="REFRESH"></a>REFRESH</h4><p>路由刷新请求</p><p><img src="/2022/04/02/bgp-notes/refresh.jpg" alt="BGP REFRESH"></p><h3 id="BGP邻居"><a href="#BGP邻居" class="headerlink" title="BGP邻居"></a>BGP邻居</h3><h4 id="BGP邻居关系状态机"><a href="#BGP邻居关系状态机" class="headerlink" title="BGP邻居关系状态机"></a>BGP邻居关系状态机</h4><p>初始阶段，双方都是 idle 状态，等待连接重试时间到期后，双方进入 active 状态，并且双方各自回退一个 随机 delay 时间，delay 小的路由器，delay到期后，将主动发起 TCP 连接，delay 大的路由器在收到 TCP 连接请求后，将回到 idle 状态后进入到 connect 状态。若TCP连接失败，则进入active状态重传，建立成功进入opensent，不成功回退到Connet状态。TCP 连接建立完后，双方进入 OpenSent 状态，在这状态 中，双发互相发送 open 消息，并且侦听来自邻居的 open 消息，如果接收到的 open 消息没有差错，则发送 keepalive 消息并设置 keepalive 定时器，协商保持时间，根据对方的 AS 号，确定连接是内部的还是外部的，并 且迁移到OpenConfirm 状态，在 OpenConfirm 状态下，一旦收到 keepalive 消息，则进入到 establish 状态， establish 状态后，即双方已经建立 BGP 邻居，随即双方交换 update包。</p><p><img src="/2022/04/02/bgp-notes/state.jpg" alt="BGP STATE"> </p><p>其中，</p><ul><li><p>默认路由无法主动发起TCP连接，但可以回应主动发起TCP连接请求的一方必须用对方neighbor所指定的IP地址作为源发出TCP连接请求</p></li><li><p>建邻居的两端，先协商 Hold 时间，Hold 时间保持一致，Hold 时间为两端的最小值。</p></li><li><p>keepalive 时间 &gt; 三分之一的 Hold 时间，取三分之一的 Hold 时间作为 keepalive 时间。</p></li><li><p>keepalive 时间 &lt;&#x3D; 三分之一的 Hold 时间，keepalive 时间不变。</p></li><li><p>BGP只有当连接处于建立状态时，才能交换更新、存活和通知消息</p></li><li><p>EBGP建立邻居默认TTL是1</p><ul><li><p>关闭直连检测TTL还是1</p></li><li><p>改eBGP多跳设置，TTL可设置其他值</p></li></ul></li></ul><p>如果一直停在idle状态，则可能：</p><ul><li><p>没有去往邻居的路由</p></li><li><p>neighbor命令指错了邻居的地址</p></li></ul><p>如果一直停在active状态，则可能：</p><ul><li><p>邻居没有过来的路由</p></li><li><p>邻居没有指neighbor命令</p></li><li><p>邻居neighbor中指的地址错误</p></li><li><p>两端的AS号不匹配</p></li></ul><h4 id="BGP邻居类型"><a href="#BGP邻居类型" class="headerlink" title="BGP邻居类型"></a>BGP邻居类型</h4><h5 id="eBGP"><a href="#eBGP" class="headerlink" title="eBGP"></a>eBGP</h5><ul><li><p>eBGP是不同AS之间建立的BGP邻居</p></li><li><p>通常要求直连，建议使用直连接口建立邻居</p></li><li><p>AD默认20（Cisco）</p></li></ul><h5 id="iBGP"><a href="#iBGP" class="headerlink" title="iBGP"></a>iBGP</h5><ul><li><p>iBGP是AS内建立的BGP邻居</p></li><li><p>无需直连，只需传输层可达</p></li><li><p>AD默认200（Cisco）</p></li></ul><h4 id="BGP更新源"><a href="#BGP更新源" class="headerlink" title="BGP更新源"></a>BGP更新源</h4><p>BGP默认开启直连监测和源监测</p><ul><li><p>直连监测：需要根据neighbor中的指定的具体IP来进行判断，是不是直连IP，如果不是，连TCP三次握手都不成功，更不可能建立完整的BGP邻接了</p></li><li><p>源检测：监测过来访问自己179端口的IP是否是nei后面的ip</p></li></ul><p>路由器用来和邻居建立邻居关系的IP地址叫BGP更新源地址。BGP建立邻居过程中，由于默认开启源检测，来自邻居的邻居建立源IP必须是本地neibor指定的邻居IP，否则无法建立邻居关系。</p><p>“show ip bgp summary中的Neighbor” &#x2F; “show ip bgp中的Next Hop ”都是指Update-Source</p><h4 id="查看BGP邻居"><a href="#查看BGP邻居" class="headerlink" title="查看BGP邻居"></a>查看BGP邻居</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show ip bgp summary</span><br></pre></td></tr></table></figure><p>显示结果</p><p><img src="/2022/04/02/bgp-notes/nei.png" alt="BGP NEIGHBOR"></p><p>其中，</p><p>Neighbor为邻居更新源IP</p><p>AS为对方AS号</p><p>MsgRcvd&#x2F;Sent为BGP消息接受&#x2F;发送数量</p><p>State&#x2F;PfxRcd为BGP邻居建立状态，当显示为数字时，表示状态为Established并且收到该数量的路由前缀</p><h4 id="清除BGP会话"><a href="#清除BGP会话" class="headerlink" title="清除BGP会话"></a>清除BGP会话</h4><p>bgp不会周期更新，是增量更新</p><p>以下命令为BGP会话硬件清除，<strong>重新建立邻居；慎用！！！</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clear ip bgp *</span><br><span class="line">clear ip bgp 3.3.3.3</span><br></pre></td></tr></table></figure><p>以下命令为出入向软件清除，不会改变状态机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clear ip bgp * soft  [out/in/-]</span><br></pre></td></tr></table></figure><p>出向软清，发送UPDATE，不发送刷新消息</p><p>入向软清，不发送UPDATE，发送刷新消息，对方回复UPDATE</p><p>双向软清，发送UPDATE，发送刷新消息，对方恢复UPDATE</p><p>可以使用以下命令缓存被拒绝的路由</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bgp 100</span><br><span class="line">nei 3.3.3.3 soft-reconfiguation inbound</span><br></pre></td></tr></table></figure><h4 id="BGP防环机制"><a href="#BGP防环机制" class="headerlink" title="BGP防环机制"></a>BGP防环机制</h4><ul><li><p>从iBGP邻居收到的路由不再传给其它iBGP邻居（iBGP水平分割）</p></li><li><p>拒绝从EBGP邻居收到的AS-PATH属性含有自身AS号的路由</p></li></ul><p>iBGP水平分割可以通过Fullmesh、RR或联邦来解决</p><h5 id="neighbor-a-a-a-a-remote-as-AS含义"><a href="#neighbor-a-a-a-a-remote-as-AS含义" class="headerlink" title="neighbor a.a.a.a remote-as AS含义"></a>neighbor a.a.a.a remote-as AS含义</h5><p>指定对方属于哪个AS，所指a.a.a.a地址，必须在IGP可达（双方不能都是默认路由）</p><p>1、我将会向nei后面地址的179端口发起TCP连接，建立BGP邻居</p><p>2、只允许nei后面地址作为源来访问我的179端口（TCP请求源检测 ）</p><h4 id="对等体组"><a href="#对等体组" class="headerlink" title="对等体组"></a>对等体组</h4><p>有时可能对多个邻居进行相同的BGP配置，可以定义对等体组将其统一配置（neighbor XX peer-group）</p><h3 id="BGP路由操作"><a href="#BGP路由操作" class="headerlink" title="BGP路由操作"></a>BGP路由操作</h3><h4 id="BGP路由发布"><a href="#BGP路由发布" class="headerlink" title="BGP路由发布"></a>BGP路由发布</h4><h5 id="network宣告特点"><a href="#network宣告特点" class="headerlink" title="network宣告特点"></a>network宣告特点</h5><ul><li><p>够通告路由表中的所有非BGP路由</p></li><li><p>默认情况下必须精确宣告网络和掩码</p></li><li><p>只起到宣告作用，不建邻居</p></li><li><p>可宣告IGP学到的路由，并携带Metric和Next-hop</p></li></ul><h5 id="no-autosummary"><a href="#no-autosummary" class="headerlink" title="no-autosummary"></a>no-autosummary</h5><p>network含义–network后面的网段和掩码必须和路由表中条目精确匹配才能宣告进BGP表</p><p>redistribute–重分布明细进BGP</p><h5 id="autosummary"><a href="#autosummary" class="headerlink" title="autosummary"></a>autosummary</h5><p>network含义–network后面的网段和掩码必须和路由表中明细路由的主类路由匹配才能宣告进BGP表</p><p>redistribute–重分布主类路由进BGP</p><p>ibgp重分布需要在bgp进程下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bgp redistribute-internal</span><br></pre></td></tr></table></figure><h4 id="BGP路由传递规则"><a href="#BGP路由传递规则" class="headerlink" title="BGP路由传递规则"></a>BGP路由传递规则</h4><ul><li><p>iBGP之间传递路由，下一跳不变</p></li><li><p>联邦iBGP&#x2F;eBGP传递路由，下一跳不变</p></li><li><p>eBGP之间传递路由，下一跳改变</p></li><li><p>iBGP水平分割：从iBGP邻居收到的路由不会传给iBGP邻居</p></li></ul><h4 id="BGP同步"><a href="#BGP同步" class="headerlink" title="BGP同步"></a>BGP同步</h4><p>BGP同步是针对iBGP水平分割的一个早起解决方案。</p><p>开启同步后，AS内的一个路由器从iBGP邻居处学到一条路由，不用也不传，除非是从IGP学到同样一条路由。（网络号和掩码都必须完全一样）</p><p>BGP同步配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">router bgp 64512</span><br><span class="line">synchronization</span><br></pre></td></tr></table></figure><h4 id="BGP路由优化"><a href="#BGP路由优化" class="headerlink" title="BGP路由优化"></a>BGP路由优化</h4><p>BGP收到路由后会优化路由，被优化的路由才能被使用，被传递。一般根据以下条件判断该路由是否可以被优化：</p><ul><li><p>是否满足同步条件</p></li><li><p>下一跳是否可达（本地优化）</p></li><li><p>入向策略允许的路由、</p></li><li><p>路径选择（路径优化），若有多条路径去往相同的网段，选择一条最优的路由</p></li></ul><p>BGP表中的路由优化后的2个动作：</p><ul><li>向路由表提交这条最优的BGP路由</li><li>向BGP的peer邻居发送包含这条BGP最优路由的更新</li></ul><h4 id="第三方下一跳"><a href="#第三方下一跳" class="headerlink" title="第三方下一跳"></a>第三方下一跳</h4><p>收到BGP路由的下一跳（递归完的下一跳）与建邻居nei地址在同一网段，保持下一跳不变；不在同一网段，改变下一跳。（RIP与EIGRP也存在第三方下一跳，EIGRP默认关闭）</p><h4 id="BGP路由重分发"><a href="#BGP路由重分发" class="headerlink" title="BGP路由重分发"></a>BGP路由重分发</h4><p>将OSPF重分发进BGP时，默认只将internal充分发。可使用以下令充分发其它OSPF路由</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">router bgp 64512</span><br><span class="line">     redistribute ospf 1 match [internal | external | nssa external] </span><br></pre></td></tr></table></figure><p>将BGP重分发进IGP默认只重分发eBGP，可使用以下命令充分发iBGP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">router bgp 64512</span><br><span class="line">     bgp redistribute-internal</span><br></pre></td></tr></table></figure><h4 id="BGP注入默认路由的3种方法"><a href="#BGP注入默认路由的3种方法" class="headerlink" title="BGP注入默认路由的3种方法"></a>BGP注入默认路由的3种方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip route 0.0.0.0 0.0.0.0 null0</span><br><span class="line">router bgp 64512</span><br><span class="line">   network 0.0.0.0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ip route  0.0.0.0 0.0.0.0 null 0                       </span><br><span class="line">router bgp 64512</span><br><span class="line">   redistribute static</span><br><span class="line">   default-information originate </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">router bgp 64512                                      </span><br><span class="line">    neighbor x.x.x.x default-originate </span><br><span class="line"></span><br><span class="line">router bgp 64512                                     </span><br><span class="line">    neighbor x.x.x.x default-originate route-map xx  </span><br></pre></td></tr></table></figure><h4 id="BGP路由聚合"><a href="#BGP路由聚合" class="headerlink" title="BGP路由聚合"></a>BGP路由聚合</h4><h5 id="network方式汇总"><a href="#network方式汇总" class="headerlink" title="network方式汇总"></a>network方式汇总</h5><p>先配置一条指向null0的汇总静态路由，然后在bgp宣告此静态路由</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip route 192.168.0.0 255.255.252.0 Null0</span><br><span class="line">router bgp 64512</span><br><span class="line">  network 192.168.0.0 mask 255.255.252.0</span><br></pre></td></tr></table></figure><h5 id="Aggregate聚合"><a href="#Aggregate聚合" class="headerlink" title="Aggregate聚合"></a>Aggregate聚合</h5><p>先使用network宣告明细路由，然后使用aggregate进行聚合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">router bgp 123</span><br><span class="line">  network 192.168.0.0 mask 255.255.255.128</span><br><span class="line">  network 192.168.0.128 mask 255.255.255.128</span><br><span class="line">  aggregate-address 192.168.0.0 255.255.255.0 summary-only</span><br></pre></td></tr></table></figure><h5 id="Aggregate聚合常见参数"><a href="#Aggregate聚合常见参数" class="headerlink" title="Aggregate聚合常见参数"></a>Aggregate聚合常见参数</h5><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>advertise-map</td><td>只对该map匹配的路由进行聚合</td></tr><tr><td>as-set</td><td>让聚合路由继承明细路由属性</td></tr><tr><td>attribute-map</td><td>清除&#x2F;添加需要的属性</td></tr><tr><td>summary-only</td><td>抑制明细路由，只发布聚合路由</td></tr><tr><td>suppress-map</td><td>抑制该map匹配的路由</td></tr></tbody></table><h3 id="BGP路由属性"><a href="#BGP路由属性" class="headerlink" title="BGP路由属性"></a>BGP路由属性</h3><h4 id="BGP路由属性分类"><a href="#BGP路由属性分类" class="headerlink" title="BGP路由属性分类"></a>BGP路由属性分类</h4><ul><li><p>公认强制的–所有的BGP的updata消息都要包含该属性</p></li><li><p>公认自由决定的–该属性是可选可不选的，但是所有的BGP进程都能识别</p></li><li><p>可选传递的–即使BGP进程不能识别该属性，也会继续传递下去</p></li><li><p>可选非传递的–如果BGP进程不能识别该属性，可以忽略这条updata,并且不传递下去</p></li></ul><p>1、公认强制属性</p><p>    –AS路径(AS-path)</p><p>    –下一跳（next-hop）</p><p>    –源头(origin)</p><p>2、公认自由决定的</p><p>    –本地优先级（local preferent）</p><p>3、可选传递的</p><p>    –团体属性（community）</p><p>4、可选非传递属性</p><p>    –MED</p><h4 id="BGP路由常见属性"><a href="#BGP路由常见属性" class="headerlink" title="BGP路由常见属性"></a>BGP路由常见属性</h4><h5 id="weight-路由权重"><a href="#weight-路由权重" class="headerlink" title="weight-路由权重"></a>weight-路由权重</h5><p>只能入向做,cisco私有，本地产生路由weight 32768，越大越优</p><h5 id="local-preference-本地优先级"><a href="#local-preference-本地优先级" class="headerlink" title="local preference-本地优先级"></a>local preference-本地优先级</h5><p>LP属性在同一AS内有效，发送给AS内其它路由器，告知离开AS的最佳路由。</p><ul><li><p>EBGP邻居传路由，不携带LP，默认100</p></li><li><p>IBGP邻居传递路由，携带LP</p></li></ul><p>修改LP的操作可以在IBGP邻居的入向或出向，或者EBGP邻居之间的入向执行</p><p>bgp default local-preference 101 针对自己始发的路由和EBGP传给我的路由有效</p><h5 id="AS-PATH-AS路径"><a href="#AS-PATH-AS路径" class="headerlink" title="AS-PATH-AS路径"></a>AS-PATH-AS路径</h5><p>AS-PATH表示一条路由经过的AS。</p><p>AS-PATH的优先级按个数算，经过越少的AS越优。</p><p>其中，</p><ul><li><p>联邦内as不计入总数，路由聚合后的as-set算一个AS；</p></li><li><p>在使用route-map添加AS时，添加后的AS在出向策略靠右显示，在入向策略靠左显示</p></li><li><p>可以增加多个自己的as号来加长as-path属性</p></li><li><p>bgp best-path ignore 可忽略这条选路原则</p></li></ul><h5 id="origin-起源类型"><a href="#origin-起源类型" class="headerlink" title="origin-起源类型"></a>origin-起源类型</h5><p>起源类型三种igp，egp，未知（?）</p><p>其中优先级如下</p><p>igp&gt;egp&gt;imcomplete（i&gt;e&gt;?）</p><h5 id="MED-多出口鉴别"><a href="#MED-多出口鉴别" class="headerlink" title="MED-多出口鉴别"></a>MED-多出口鉴别</h5><p>MED用于发送给其它AS，告知进入本AS的最佳路径。</p><ul><li><p>在两个AS之间存在多条路径时使用</p></li><li><p>用来影响ebgp邻居，告诉自己的ebgp邻居如何选最优路由</p></li><li><p>MED默认值0，越小越优</p></li></ul><p>MED传递特殊规则</p><ul><li><p>metric传递不能传出AS。例：始发路由器可以将metric传给任何邻居，可以是IBGP&#x2F;EBGP，但邻居收到后，不能传出邻居所在的AS。</p></li><li><p>默认相同AS传来的MED才会比较，如果比较不同AS传来的MED需要命令bgp always-compare-med</p></li></ul><h5 id="团体属性（标准）"><a href="#团体属性（标准）" class="headerlink" title="团体属性（标准）"></a>团体属性（标准）</h5><p>标准BGP团体属性作用于多条路由，让经过的路由器知道这些路由的传递范围。团体属性默认不被发送，可用以下命令向指定邻居发送团体属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">neighbor 192.168.23.2 send-community [-/standard/both]</span><br></pre></td></tr></table></figure><p>这里的团体属性是标准团体属性，而拓展团体属性本质是MPLS中的Route-Target（rt），这里暂不讨论</p><p>标准团体属性分公有团体属性和私有团体属性。公有团体属性是所有路由器都认识的属性，而私有团体属性需要预先在路由器上针对改属性做定义才可被路由器执行。</p><p><strong>公有团体属性</strong></p><p>公有团体属性的值表明了具有该属性的路由可被通告的范围</p><table><thead><tr><th>属性</th><th>路由传递范围</th></tr></thead><tbody><tr><td>internet</td><td>收到后传递给任何peer</td></tr><tr><td>no-advertise</td><td>收到后不传递给任何peer</td></tr><tr><td>local-as</td><td>只在AS内传递，只在联邦iBGP之间传递</td></tr><tr><td>no-export</td><td>只在AS内传递，可在联邦iBGP和eBGP之间传递</td></tr></tbody></table><p><strong>私有团体属性</strong></p><p>私有团体属性（32bits）有两种定义方式</p><ul><li><p>十进制数，如123</p></li><li><p>XX:XX形式</p></li></ul><p>路由器在收到私有团体属性后不做任何操作，除非有预先定义的策略。如，AWS DX-Gateway根据BGP私有团体属性（XX:XX形式）来进行云网络至IDC网络方向的选路，7224:7100，7224:7200，7224:7300分别表示携带该属性路由的优先级为低中高。</p><p><strong>标准团体属性配置</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">router bgp 64512</span><br><span class="line"> neighbor 192.168.12.2 route-map community_std out</span><br><span class="line">route-map community_std permit 10</span><br><span class="line"> set community local-AS #公有团体属性</span><br><span class="line"> set community 7224:7100 #私有团体属性</span><br></pre></td></tr></table></figure><h3 id="BGP选路原则"><a href="#BGP选路原则" class="headerlink" title="BGP选路原则"></a>BGP选路原则</h3><p>以下情况忽略路由</p><ul><li>不同步</li><li>下一跳不可达</li><li>ebgp学到路由AS包含自己</li><li>bgp enforce-first-as但收到不是第一个as</li><li>receive only</li></ul><p>11+2条选路原则，标准BGP选路11条，带*的两条是补充：</p><p>1、最高weight值优先（思科私有默认32768，本地有效）</p><p>2、最高LP优先</p><p>3、加入方式，local&gt;network&gt;REDISTRIBUTE&gt;aggreate；local 最优</p><p>4、最短AS</p><p>5、起源类型origin  IGP&lt;EGP&lt;IMCOMPLETE</p><p>6、最小MED</p><p>7、 EBGP&gt;IBGP</p><p>8 、优选去往下一跳 IGP metric小的</p><p>*9、负载（满足前8条和以下条件则负载）</p><ul><li> 配置maximum-path</li><li>多条等价路由的下一跳要不同</li><li><strong>EBGP如果穿越了不同AS，也不会负载！！</strong></li><li>如果穿越了联邦，穿越了不通联邦的两条路由不负载</li><li>除非在BGP中加一条bgp bestpath<br> as-path multipath-relax</li><li>负载仅仅是路由表，BGP表会继续向下比较知道选出一条best路径</li><li>隐藏命令bgp bestpath<br> as-path multipath-relax</li></ul><p>10、如果都是ebgp，优先选择先学到的</p><p>11、rid 小的优先，有RR的话，用originater地址代替rid比较</p><p>  *12、最小的RR中cluster长度</p><p>13、最小的建立邻居的neighbor地址</p><h3 id="路由反射器RR"><a href="#路由反射器RR" class="headerlink" title="路由反射器RR"></a>路由反射器RR</h3><p>路由反射器是一台BGP路由器，可以将它的iBGP邻居指定为自己的客户端。路由反射器是为了解决iBGP的水平分割问题。为了使得iBGP路由全通，如果采用full mesh的方法则需要建立非常多的邻居关系，而路由反射器打破iBGP水平分割的原则，解决iBGP的路由传递问题。</p><p>路由反射器和其客户的集合被称为集群（cluster）,每一个集群都有一个cluster-id，默认情况下路由反射器的router-id会被用做cluster-id，也可以手工指定。路由反射器所传递的每一条客户端路由都会带上这个cluster-id。</p><h4 id="RR路由传递规则"><a href="#RR路由传递规则" class="headerlink" title="RR路由传递规则"></a>RR路由传递规则</h4><p>从RR的一个客户端传递过来的一条路由：</p><ul><li>RR会传递给我的另外一个反射族的客户端</li><li>RR会传递给我的另外一个非客户端</li><li>RR会传递给我的另一个EBGP邻居</li></ul><p>从RR的一个非客户端传递过来的一条路由：</p><ul><li>RR会传递给我的另外一个反射族的客户端</li><li><strong>RR不会传递给我的另外一个非客户端</strong></li><li>RR会传递给我的另一个EBGP邻居</li></ul><p>从RR的一个EBGP传递过来的一条路由：</p><ul><li>RR会传递给我的另外一个反射族的客户端</li><li>RR会传递给我的另外一个非客户端</li><li>RR会传递给我的另一个EBGP邻居</li></ul><p><strong>总结：非非不能传，其它都能传</strong></p><h4 id="RR防环"><a href="#RR防环" class="headerlink" title="RR防环"></a>RR防环</h4><p>R4上的路由经过 R3 路由反射后，路由中就会带有Originator，即为 AS234 中始发此路由的 router-id，Cluster list：3.3.3.3，表明此路由已经经过路由反射器R3，就将路由反射器的 router-id 存放在Cluster list里 面。此时路由再传递至 R2 或 R3 上的时候，包含自己的<br>router-id，将拒绝接收这条路由，这样设计的目的在于防止路由反射器FULL-MESH 时产生的环路</p><p><img src="/2022/04/02/bgp-notes/rr.png" alt="BGP RR"></p><h4 id="RR配置"><a href="#RR配置" class="headerlink" title="RR配置"></a>RR配置</h4><p>定义本路由器为路由反射器，指定邻居1.1.1.1为客户端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">router bgp 64512</span><br><span class="line">  neighbor 1.1.1.1 route-reflector-client </span><br></pre></td></tr></table></figure><h3 id="BGP联邦"><a href="#BGP联邦" class="headerlink" title="BGP联邦"></a>BGP联邦</h3><p>BGP联邦是指将一个大的AS分成若干个小AS，小AS之间是EBGP关系。联邦也是为了解决iBGP水平分割问题。</p><h4 id="联邦的定义"><a href="#联邦的定义" class="headerlink" title="联邦的定义"></a>联邦的定义</h4><ul><li><p>联邦中的所有路由器需要使用子AS的AS号</p></li><li><p>联邦中所有路由器需要声明主AS的AS号</p></li><li><p>子AS边界路由器需要互指联邦peers</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">R1</span><br><span class="line">router bgp 64512</span><br><span class="line"> bgp confederation identifier 100</span><br><span class="line"> neighbor 192.168.12.2 remote-as 64512</span><br><span class="line"> neighbor 192.168.12.2 next-hop-self</span><br><span class="line"></span><br><span class="line">R2</span><br><span class="line">router bgp 64512</span><br><span class="line"> bgp confederation identifier 100</span><br><span class="line"> bgp confederation peers 64513 </span><br><span class="line"> neighbor 192.168.12.1 remote-as 64512</span><br><span class="line"> neighbor 192.168.23.3 remote-as 64513</span><br><span class="line"></span><br><span class="line">R3</span><br><span class="line">router bgp 64513</span><br><span class="line"> bgp confederation identifier 100</span><br><span class="line"> bgp confederation peers 64512 </span><br><span class="line"> neighbor 192.168.23.2 remote-as 64512</span><br></pre></td></tr></table></figure><p><img src="/2022/04/02/bgp-notes/confederation.png" alt="BGP CONFEDERATION"></p><h4 id="联邦的AS号"><a href="#联邦的AS号" class="headerlink" title="联邦的AS号"></a>联邦的AS号</h4><ul><li><p>联邦外路由器和联邦的边界路由器建立邻居关系时，neighbor大AS号。</p></li><li><p>联邦中的小AS号（64512）不算作AS-Path属性比较，只算作一个</p></li><li><p>在BGP表中，小AS号会用括号括住，并且不算做一个进行路径比较的AS号</p></li></ul><h3 id="路由惩罚（Dampening）"><a href="#路由惩罚（Dampening）" class="headerlink" title="路由惩罚（Dampening）"></a>路由惩罚（Dampening）</h3><p>由于BGP是运行再AS间的路由协议，通常没有办法直接管理对方AS的设备，为了防止因设备或者专线故障引起的路由频繁抖动，BGP可采用Dampening添加条件抑制抖动，予以抖动的邻居惩罚（主动抑制）。</p><h4 id="Dampening相关参数"><a href="#Dampening相关参数" class="headerlink" title="Dampening相关参数"></a>Dampening相关参数</h4><p>惩罚值penalty：路由每翻动一次，这个惩罚值就会增加。惩罚值1000，不可修改</p><p>半衰期half life：默认15min，一个半衰期惩罚值降为原来一半。路由的惩罚值每5秒钟减少一次。</p><p>惩罚状态damp state：路由出于惩罚状态时，改路由不会被在BGP表中被优化，也不会传播</p><p>抑制门限suppress limit：默认2000，若一条路由的惩罚值超过抑制门限，则状态由history改为damp</p><p>重用门限reuse limit：默认750，惩罚值降到重用门限后，该路由将不被抑制</p><p>最大抑制时间、最大抑制门限：默认值60min&#x2F;12000，如果路由在短时间内表现出极端的不稳定性，然后又稳定下来，那么累计的惩罚值可能会导致这条路由在过长的时间里一直处于惩罚状态。这就是设置最大抑制门限的基本目的。如果路由表现出连续的不稳定性，那么惩罚值就停留在它的上限上，使得路由保持在惩罚状态。最大抑制门限是用公式计算出来的。最大抑制时间为一条路由停留在惩罚状态的最长时间。默认为60分钟（半衰期的4倍）可以配置。</p><p>针对某条路由的Dampening配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ip prefix-list 1 permit 1.1.1.0/24</span><br><span class="line"></span><br><span class="line">route-map DAMP  </span><br><span class="line">  match ip address prefix-list 1</span><br><span class="line">  set dampening 15 750 2000 60</span><br><span class="line"></span><br><span class="line">router bgp 64512</span><br><span class="line">  bgp dampening route-map DAMP    </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;BGP全称边界网关协议（&lt;strong&gt;Boarder Gateway Protocol&lt;/strong&gt;）,是运行在自治系统（AS）之间传</summary>
      
    
    
    
    <category term="路由交换RS" scheme="https://arclogicr.github.io/categories/%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2RS/"/>
    
    
    <category term="network" scheme="https://arclogicr.github.io/tags/network/"/>
    
    <category term="routing" scheme="https://arclogicr.github.io/tags/routing/"/>
    
    <category term="bgp" scheme="https://arclogicr.github.io/tags/bgp/"/>
    
  </entry>
  
  <entry>
    <title>OSPF经典问题汇总</title>
    <link href="https://arclogicr.github.io/2022/03/28/OSPF-QA/"/>
    <id>https://arclogicr.github.io/2022/03/28/OSPF-QA/</id>
    <published>2022-03-28T08:13:52.000Z</published>
    <updated>2023-01-17T07:30:20.667Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OSPF采用分区域设计有什么好处？"><a href="#OSPF采用分区域设计有什么好处？" class="headerlink" title="OSPF采用分区域设计有什么好处？"></a>OSPF采用分区域设计有什么好处？</h2><ul><li>可以在ABR做路由汇总，减少其它区域路由表条目，减轻路由器压力</li><li>减少1，2类LSA泛洪</li><li>减少路由收敛的范围，一个区域的问题不会影响其它区域</li></ul><h2 id="影响OSPF邻接的原因有哪些？"><a href="#影响OSPF邻接的原因有哪些？" class="headerlink" title="影响OSPF邻接的原因有哪些？"></a>影响OSPF邻接的原因有哪些？</h2><p>1、ROUTER ID不能相同；<br>2、HELLO时间必须一致；<br>3、DEAD时间必须一致；<br>4、区域ID必须相同；<br>5、认证必须相同；<br>6、STUB标志位必须相同（hello包中域外路由重分布能力位）；<br>7、MTU不匹配无法形成邻接关系<br>8、OSPF版本号不同（目前版本为2）；<br>9、当OSPF网络类型是MA时，要求掩码一定一致（两个邻居）。因为会出现DR和LSA-2，无法描述网段</p><h2 id="如果OSPF双方路由器MTU不一致，会发生什么情况"><a href="#如果OSPF双方路由器MTU不一致，会发生什么情况" class="headerlink" title="如果OSPF双方路由器MTU不一致，会发生什么情况"></a>如果OSPF双方路由器MTU不一致，会发生什么情况</h2><p><strong>无法建立邻接关系</strong></p><p>假设<strong>R1 MTU &lt; R2 MTU</strong></p><p>首先，双方都可以进入exstart状态。然后双方开始单播发送第一个DBD，<br>此时<br>若R2的RID&gt;R1的RID</p><p>对于R1：收到R2第一个DBD发现MTU比自己大，无法接受；所以维持发送第一个DBD的状态，即维持exstart状态</p><p>对于R2: 正常收到R1的第一个DBD然后可以计算出自己是master，然后等待对方发送LSA摘要；但是发现R1只会发第一个DBD不发LSA摘要，（猜测：可能以为通讯有问题），于是维持发送第一个DBD，即维持exstart状态</p><p>若R2的RID&lt;RI的RID</p><p>对于R1：收到R2第一个DBD发现MTU比自己大，无法接受；所以维持发送第一个DBD的状态，即维持exstart状态</p><p>对于R2: 正常收到R1的第一个DBD然后可以计算出对方是master而自己是slave，然后会发送LSA摘要，即进入exchange状态，但对方没有回复LSA摘要，所以会支持卡在exchange这个状态</p><p>总结：<br>当双方mtu不一致时<br><strong>若DBD从的mtu小，则双方都卡在exstart</strong><br><strong>若DBD从的mtu大，则mtu大的进入exchange，mtu小的维持exstart</strong></p><p><strong>总之，mtu小的一定卡在exstart，mtu大的有可能进入exchange（取决于是否是DBD从角色）</strong></p><h2 id="OSPF何时用组播，何时用单播？"><a href="#OSPF何时用组播，何时用单播？" class="headerlink" title="OSPF何时用组播，何时用单播？"></a>OSPF何时用组播，何时用单播？</h2><ul><li>HELLO包，不手动指定邻居的话都是发送到组播224.0.0.5</li><li>DBD，只是两个路由器之间建邻居互传DB摘要，采用单播</li><li>LSR，请求LSA，直接向DR请求，单播</li><li>LSU<ul><li>回复LSR时是单播</li><li>触发更新时是组播<ul><li>DR-Other 采用组播224.0.0.6告知DR&#x2F;BDR，由DR发送224.0.0.5告知其它所有路由器</li><li>p2p类型网络都是发送到组播224.0.0.5</li></ul></li></ul></li><li>LSAck，组播224.0.05</li></ul><h2 id="OSPF邻居表发现2-way是否正常"><a href="#OSPF邻居表发现2-way是否正常" class="headerlink" title="OSPF邻居表发现2-way是否正常"></a>OSPF邻居表发现2-way是否正常</h2><p><strong>MA网络中正常</strong><br>在MA网络中，DR和BDR分别与DROther建立full邻接关系，DROther之间只是2-way关系</p><h2 id="如何判断一条LSA的新旧"><a href="#如何判断一条LSA的新旧" class="headerlink" title="如何判断一条LSA的新旧"></a>如何判断一条LSA的新旧</h2><p>当一台路由器收到相同的LSA的多个实例时，将通过以下算法决定将哪一条放入数据库：</p><p>1、比较LSA实例的序列号，大的优先<br>2、序列号相同，再比校验和，大的优先<br>3、校验和也相同，再比老化时间，如果有一条LSA拥有大小为最大生存时间（3600S）的老化时间，则最优<br>4、如果LSA的老化时间之间的差别多于15分钟，则老化时间小的优先<br>5、如果以上条件都比不出来，则认为这些LSA相同</p><h2 id="如果不相邻的两台OSPF路由器RID相同会发生什么"><a href="#如果不相邻的两台OSPF路由器RID相同会发生什么" class="headerlink" title="如果不相邻的两台OSPF路由器RID相同会发生什么"></a>如果不相邻的两台OSPF路由器RID相同会发生什么</h2><p><strong>若这些路由器在同一区域</strong><br><img src="/2022/03/28/OSPF-QA/RID1.png" alt="OSPF RID1"><br>R1-R2-R3连接，且都属于同一区域<br>假设R2-R3先正常建立邻居后，R1配置R3的RID接入。此时R1与R2可以建立full邻接关系，R1会收到R2发来的较新的1类LSA，这里的1类LSA应该有两条<br>第一条ADV Router是R3<br>第二条ADV Router是R1</p><p>这里R1会接受R2独有的路由（即ADV Router为R2且R3 没通告的路由，如lo 0的路由），收到R3路由发现和自己RID一样，会报RID dup的错，同时也会发送自己的最新的LSA。R3同理。<br><strong>最后结果就是R1,R3可以学到R2的loopback 路由但R1,R3互相的路由不稳定会翻动</strong></p><p><strong>若这些路由器在不通区域</strong><br><img src="/2022/03/28/OSPF-QA/RID2.png" alt="OSPF RID2"><br>R1-R2-R3连接，R1-R2属于区域1，R2-R3属于区域0<br>假设R2-R3先正常建立邻居后，R1配置R3的RID接入。此时R1与R2可以建立full邻接关系。这里R2是ABR，R2会吧R3通告的1类LSA转为3类，在发给区域1的时候ADV Router字段会变为自己（即R2的RID），但不会重新处理5类LSA。所以对区域1的内部路由器R1来说，收到的R3路由会当做普通的三类LSA处理，并不知道这些OIA路由来自哪里；同理，R3也能学到R1的域内路由。<br><strong>最后结果就是R1,R3可以互相学到域内路由</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;OSPF采用分区域设计有什么好处？&quot;&gt;&lt;a href=&quot;#OSPF采用分区域设计有什么好处？&quot; class=&quot;headerlink&quot; title=&quot;OSPF采用分区域设计有什么好处？&quot;&gt;&lt;/a&gt;OSPF采用分区域设计有什么好处？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;可以在A</summary>
      
    
    
    
    <category term="路由交换RS" scheme="https://arclogicr.github.io/categories/%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2RS/"/>
    
    
    <category term="network" scheme="https://arclogicr.github.io/tags/network/"/>
    
    <category term="routing" scheme="https://arclogicr.github.io/tags/routing/"/>
    
    <category term="ospf" scheme="https://arclogicr.github.io/tags/ospf/"/>
    
  </entry>
  
  <entry>
    <title>OSPF学习笔记</title>
    <link href="https://arclogicr.github.io/2022/03/27/ospf-notes/"/>
    <id>https://arclogicr.github.io/2022/03/27/ospf-notes/</id>
    <published>2022-03-27T10:12:04.000Z</published>
    <updated>2023-01-17T07:29:36.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>OSPF全称<strong>开放最短路径优先</strong>（Open Shortest Path First）是一种<strong>链路状态</strong>路由协议。v2版本的OSPF基于IPv4，v3版本的OSPF基于IPv6。在IPv4网络中OSPF应该是被使用最广泛的IGP了。</p><h2 id="基本特点"><a href="#基本特点" class="headerlink" title="基本特点"></a>基本特点</h2><ul><li>OSPF属于IGP，是链路状态协议，基于IP协议号89</li><li>采用分区域的设计，所有区域需要和骨干区域ar0相连</li><li>区域内采用SPF(Dijkstra算法)计算最佳路径</li><li>可以快速响应网络拓扑变化（触发更新）</li><li>支持等价路径负载</li></ul><h2 id="三张表"><a href="#三张表" class="headerlink" title="三张表"></a>三张表</h2><p>OSPF的运行涉及三张表</p><ul><li>邻居表<br>用于记录与opsf邻居之间的状态、参数等；</li><li>拓扑表<br>本质是LSDB,通过LSA来更新数据。用于记录接收的LSA信息，在区域内和ma网络中保持一致</li><li>路由表<br>通过DJ算法将最佳路由提交到路由表</li></ul><h2 id="OSPF路由器类型"><a href="#OSPF路由器类型" class="headerlink" title="OSPF路由器类型"></a>OSPF路由器类型</h2><table><thead><tr><th>路由器类型</th><th>功能</th></tr></thead><tbody><tr><td>内部路由器</td><td>在一个普通区域内部的路由器</td></tr><tr><td>骨干路由器</td><td>在区域0的内部路由器</td></tr><tr><td>ABR</td><td>区域边界路由器，连接两个不通区域的路由器</td></tr><tr><td>ASBR</td><td>自治系统边界路由器，连接OSPF到另一个自治系统的路由器</td></tr></tbody></table><h2 id="OSPF报文类型"><a href="#OSPF报文类型" class="headerlink" title="OSPF报文类型"></a>OSPF报文类型</h2><table><thead><tr><th>类型</th><th>内容</th></tr></thead><tbody><tr><td>HELLO</td><td>hello包，用于建立&#x2F;维护邻居</td></tr><tr><td>DBD</td><td>数据库描述，用于同步自身LSDB摘要</td></tr><tr><td>LSR</td><td>链路状态请求，用于请求LSA</td></tr><tr><td>LSU</td><td>链路状态更新，用于传播LSA详细，可单播可组播</td></tr><tr><td>LSAck</td><td>用于确认收到LSU</td></tr></tbody></table><h2 id="OSPF邻居"><a href="#OSPF邻居" class="headerlink" title="OSPF邻居"></a>OSPF邻居</h2><p>OSPF通过hello报文来建立和维护邻居</p><p><img src="/2022/03/27/ospf-notes/HELLO.png" alt="OSPF HELLO"></p><p>ospf邻居建立过程<br>down：周期性发送hello包；收到不带自己RID的hello包时进入init<br>init：继续正常周期性发送hello包；收到带自己RID的hello包进入2way<br>2way：通过hello包携带的DR&#x2F;BDR信息（如有）选举DR&#x2F;BDR;然后进入exstart<br>exstart: 双法开始单播发送第一个DBD；根据对方的第一个DBD选取主从；然后进入exchange<br>exchange: 开始交换DBD，以master序列号为基准，slave先发DBD，通过序列号隐式确认；发送完毕后进入Loading<br>loading: 双方开始根据DBD的LSA摘要，单播发送LSR请求详细的LSU，同步完成后进入full<br>full: 邻接完成</p><h2 id="OSPF-LSA内容"><a href="#OSPF-LSA内容" class="headerlink" title="OSPF LSA内容"></a>OSPF LSA内容</h2><p>一个LSA可由{Type,LS ID,ADV Router}唯一描述</p><ul><li>Type，LSA类型，常见有1，2，3，4，5，7</li><li>LS ID，链路状态ID，可理解为一个LSA的名称，每类LSA的该字段有不通含义</li><li>ADV Router，通告路由器</li><li>Age，老化时间，一般为3600s，每1800s会无触发更新</li><li>Seq，序列号，0x80000001开始计数，越大表示LSA越新</li><li>Checksum，校验和</li><li>Do Not Age Flag，不老化标识，虚链路LSA该位为1</li></ul><p><img src="/2022/03/27/ospf-notes/LSU.png" alt="OSPF LSU"></p><h2 id="OSPF-LSA类型"><a href="#OSPF-LSA类型" class="headerlink" title="OSPF LSA类型"></a>OSPF LSA类型</h2><table><thead><tr><th>类型</th><th>传播范围</th><th>产生与功能</th><th>LS ID字段</th><th>ADV字段</th></tr></thead><tbody><tr><td>1类Router</td><td>区域内</td><td>每台路由器都会产生，传输本地链路状态</td><td>Router ID</td><td>Router ID</td></tr><tr><td>2类Network</td><td>区域内，广播域内</td><td>DR产生，标识本MA网络中掩码和路由器</td><td>DR接口IP</td><td>DR RouterID</td></tr><tr><td>3类Router Summary</td><td>泛洪整个AS（除totally stub区域）</td><td>由ABR重新产生（根据1、2类或其它3类），用于传递区域间路由</td><td>域间路由（网络号）</td><td>ABR的Router ID，经过一个ABR就会变为该ABR的RID</td></tr><tr><td>4类ASBR Summary</td><td>除ASBR外的非stub区域</td><td>由ASBR所在区域的ABR产生并发出，用于告知ASBR的位置</td><td>ASBR的Router ID</td><td>ABR的Router ID，经过一个ABR就会变为该ABR的RID</td></tr><tr><td>5类AS-External</td><td>全域泛洪，stub区域除外</td><td>ASBR产生，保持ADV不变，传递域外路由</td><td>域外路由（网络号）</td><td>ASBR的Router ID</td></tr><tr><td>7类NSSA-External</td><td>只存在于NSSA区域内,NSSA的ABR会做7转5</td><td>由NSSA区域内ASBR产生，传递域外路由</td><td>域外路由（网络号）</td><td>ASBR的Router ID</td></tr></tbody></table><h2 id="OSPF区域类型"><a href="#OSPF区域类型" class="headerlink" title="OSPF区域类型"></a>OSPF区域类型</h2><p>ospf采用层次设计，用区域分割路由器；区域中路由器保存该区域中所有链路和路由器详细信息，但只保存其它区域路由器和链路的摘要信息</p><ul><li><p>骨干区域主要为高速快速传递数据，通常不接用户</p></li><li><p>常规区域主要连接用户。所有数据需经过骨干区域中转。</p><p>非骨干区域主要包含以下几种类型</p></li></ul><table><thead><tr><th>区域</th><th>特点</th></tr></thead><tbody><tr><td>普通区域</td><td>区域内泛洪1、2类LSA，也会传递3，4，5类LSA</td></tr><tr><td>Stub</td><td>不能配置外部重分发，阻止4，5类路由，ABR自动下发OIA默认路由</td></tr><tr><td>Totally Stub</td><td>不能外部重分发，不会传3，4，5类LSA，会传递1，2类和3类默认LSA，ABR自动下发OIA默认</td></tr><tr><td>NSSA</td><td>可以重分发外部路由作为7类LSA在ABR转成5类。允许1，2，3，7类LSA，ABR不会自动下发OIA默认</td></tr><tr><td>Totally NSSA</td><td>阻止3，4，5类LSA，允许1，2，7和3类默认LSA，ABR自动下发OIA默认</td></tr></tbody></table><h2 id="OSPF路由类型"><a href="#OSPF路由类型" class="headerlink" title="OSPF路由类型"></a>OSPF路由类型</h2><p>OSPF的LSA类型较多，不同LSA传递的路由类型也不一样，共有一下几种类型</p><ul><li>O路由<br>区域内路由，由1类LSA和2类LSA通过DJ算法计算得出</li><li>O IA路由<br>区域间路由，由3类LSA习得</li><li>O E1&#x2F;N1路由<br>1类外部路由&#x2F;1类NSSA外部路由，由4&#x2F;5&#x2F;7类LSA习得；</li><li>O E2&#x2F;N2路由<br>2类外部路由&#x2F;1类NSSA外部路由，由4&#x2F;5&#x2F;7类LSA习得；</li></ul><h2 id="OSPF选路"><a href="#OSPF选路" class="headerlink" title="OSPF选路"></a>OSPF选路</h2><h3 id="度量"><a href="#度量" class="headerlink" title="度量"></a>度量</h3><p>OSPF路由管理距离（AD）默认是110 （CISCO）， 度量单位是cost</p><p><strong>cost&#x3D;reference&#x2F;interface bandwidth</strong></p><p>reference默认是100000000 （10^8），其中每台路由器可以配置不一样，但建议全局一致。另外cost是分方向的，因为ospf区域内收敛算法（dj）需要画有向权重图，cost即为单向权重。</p><h3 id="外部路由度量-x2F-Forward-Address"><a href="#外部路由度量-x2F-Forward-Address" class="headerlink" title="外部路由度量 &#x2F;Forward Address"></a>外部路由度量 &#x2F;Forward Address</h3><p>Forward Address 字段用于优化外部MA网络路由下一跳的问题。在ASBR产生LSA5时填充FA，若该外部路由下一跳接口是MA、且是有效ospf接口则FA填充为改路由实际下一跳地址。</p><p>Forward Metric 是本地到Forward Address 的cost，当forward<br>address&#x3D;0.0.0.0时，forward metric是本路由器到ASBR的metric</p><p>OSPF外部路由type2（默认），默认种子metric为20，且metric不变<br>OSPF外部路由type1，metric是种子metric+forward metric</p><p>另外，在 NSSA 区域，协议规定不能发送为0的FA；<br>当把直连重分布进来，Forward Address：<br>1、加入 ospf 最新的回环口作为 Forward Address；<br>2、如果没有回环口，那么加入 ospf 最新的激活的接口地址；</p><p>如果把外部路由重分布进来，Forward Address：<br>1、外部接口没有运行 ospf，Forward Address 同上；<br>2、外部接口运行了 ospf，Forward Address 是外部路由的下一跳地址。</p><h3 id="O-路由选路"><a href="#O-路由选路" class="headerlink" title="O 路由选路"></a>O 路由选路</h3><ul><li>依次比较AD Metric 小的优先</li><li>当收到来自不同的AR的1 2类LSA，计算的O路由，AD与Metric，先到的优先，不会负载</li><li>当收到来自相同AR的LSA1 2类，计算的O路由，AD与Metric相同，负载</li></ul><h3 id="O-IA-路由选路"><a href="#O-IA-路由选路" class="headerlink" title="O IA 路由选路"></a>O IA 路由选路</h3><ul><li>O&gt;OIA，不考虑AD、Metric</li><li>当收到来自Area 0的3类LSA时，不考虑其它区域的3类LSA，优选Area 0的，不考虑AD、Metric。若均来自Area0，一次比较AD、Metric，若相同，则负载；</li><li>当收到来自非Area0的3类LSA时，依次比较AD、Metric，小的有限，若相同，则负载</li></ul><h3 id="O-E-选路"><a href="#O-E-选路" class="headerlink" title="O E 选路"></a>O E 选路</h3><ul><li>OIA&gt;OE，不考虑AD、metric</li><li>OE1&gt;OE2，不考虑AD、meitric</li><li>OE1路由，比较AD与Metric，相同则负载</li></ul><h2 id="OSPF路由汇总"><a href="#OSPF路由汇总" class="headerlink" title="OSPF路由汇总"></a>OSPF路由汇总</h2><h3 id="3类LSA汇总"><a href="#3类LSA汇总" class="headerlink" title="3类LSA汇总"></a>3类LSA汇总</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">area 2 range 100.1.0.0 255.255.252.0</span><br></pre></td></tr></table></figure><ul><li>含义：把区域2的1,2类转为3类时做汇总，即area 后面跟的区域。不能把本来就是OIA的路由做汇总；</li></ul><h3 id="5类LSA汇总"><a href="#5类LSA汇总" class="headerlink" title="5类LSA汇总"></a>5类LSA汇总</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Summary-address 100.1.0.0 255.255.252.0</span><br></pre></td></tr></table></figure><ul><li>含义：5类LSA的汇总，只能在ASBR上做，即对自己产生的5类路由汇总，对于别的路由器产生的5类路由，没有汇总能力</li></ul><h2 id="OSPF网络类型"><a href="#OSPF网络类型" class="headerlink" title="OSPF网络类型"></a>OSPF网络类型</h2><p>网络物理连接可分为三种</p><ul><li>POINT_TO_POINT</li><li>BROADCAST</li><li>NBMA</li></ul><p>根据物理网络连接类型，OSPF网络类型分为以下几种：</p><table><thead><tr><th>类型</th><th>二层</th><th>Hello&#x2F;Dead</th><th>DR&#x2F;BDR</th><th>手动邻居</th><th>&#x2F;32路由</th></tr></thead><tbody><tr><td>P2P</td><td>HDLC\PPP\FRp2p</td><td>10&#x2F;40</td><td>NO</td><td>NO</td><td>NO</td></tr><tr><td>BROADCAST</td><td>Eth、令牌环、FDDI</td><td>10&#x2F;40</td><td>YES</td><td>NO</td><td>NO</td></tr><tr><td>NBMA</td><td>FR&#x2F;X.25&#x2F;ATM</td><td>30&#x2F;120</td><td>YES</td><td>YES</td><td>NO</td></tr><tr><td>P2MP(Multi)</td><td>HUB-SPOKE</td><td>30&#x2F;120</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>P2MP(NB)</td><td>CISCO私有</td><td>30&#x2F;120</td><td>NO</td><td>YES</td><td>YES</td></tr><tr><td>Loopback</td><td>loopback</td><td>当作host处理</td><td></td><td></td><td></td></tr></tbody></table><p>OSPF建立邻接关系与网络类型无关，与hello&#x2F;dead有关，但不同的网络类型建立邻居后有可能学不到路由。</p><p>如果参与建邻的路由器都需要选举或都不需要选举DR&#x2F;BDR，则可以学习到路由，否则学不到，具体关系如下：</p><table><thead><tr><th></th><th>p2p</th><th>broadcast</th><th>NBMA</th><th>p2mp</th><th>p2mp  NB</th></tr></thead><tbody><tr><td>p2p</td><td></td><td>NO</td><td>NO</td><td>YES</td><td>YES</td></tr><tr><td>broadcast</td><td></td><td></td><td>YES</td><td>NO</td><td>NO</td></tr><tr><td>NBMA</td><td></td><td></td><td></td><td>NO</td><td>NO</td></tr><tr><td>p2mp</td><td></td><td></td><td></td><td></td><td>YES</td></tr><tr><td>p2mp  NB</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="OSPF虚链路"><a href="#OSPF虚链路" class="headerlink" title="OSPF虚链路"></a>OSPF虚链路</h2><p>OSPF虚链路用于解决OSPF区域设计上的问题。</p><p>假设R0-R1-R2-R3互联，R0-R1之间，R1-R2之间，R2-R2之间区域分别为0，1，2。R3由于现实原因无法与R0互联，那么可以采用虚链路。在ABR R1和中转区域R2上配置虚链路，相当于R2与区域0相连。</p><p><img src="/2022/03/27/ospf-notes/OSPF1.png" alt="OSPF Virtual Link"></p><p>虚链路在使用上有一些限制：</p><ul><li>虚链路只在建立邻居的时候发送hello包，邻居建立后不再发送</li><li>虚链路的LSA只会触发更新，并且不会老化</li><li>虚拟链路cost继承物理链路</li><li>虚链路不能跨区域建立（只能在‘被分割的’中转区域建立）</li><li>不能建立再STUB区域</li></ul><h2 id="OSPF认证"><a href="#OSPF认证" class="headerlink" title="OSPF认证"></a>OSPF认证</h2><p>OSPF认证是指在发送hello包时添加认证字段达到认证邻居的效果，可以保护自己的路由传给通过认证的邻居。</p><p>OSPF认证分接口认证和区域认证，区域认证本质就是所有属于该区域的接口都参与认证。同时配置接口认证和区域认证，以接口认证配置优先。</p><h3 id="接口认证"><a href="#接口认证" class="headerlink" title="接口认证"></a>接口认证</h3><h4 id="接口明文认证"><a href="#接口明文认证" class="headerlink" title="接口明文认证"></a>接口明文认证</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int s1/1</span><br><span class="line">ip ospf authentication</span><br><span class="line">ip ospf authentication-key cisco</span><br></pre></td></tr></table></figure><h4 id="接口md5认证"><a href="#接口md5认证" class="headerlink" title="接口md5认证"></a>接口md5认证</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int s1/1</span><br><span class="line">ip ospf authentication message-digest</span><br><span class="line">ip ospf message-digest-key **1** md5 **cisco**</span><br></pre></td></tr></table></figure><p>其中1是key-id，cisco是md5原文</p><h3 id="区域认证"><a href="#区域认证" class="headerlink" title="区域认证"></a>区域认证</h3><h4 id="区域明文"><a href="#区域明文" class="headerlink" title="区域明文"></a>区域明文</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">router ospf 1</span><br><span class="line">ar 0 authentication</span><br></pre></td></tr></table></figure><h4 id="区域md5"><a href="#区域md5" class="headerlink" title="区域md5"></a>区域md5</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">router ospf 1</span><br><span class="line">ar 0 authentication message-digest</span><br></pre></td></tr></table></figure><h3 id="多-key-md5-认证规则："><a href="#多-key-md5-认证规则：" class="headerlink" title="多 key md5 认证规则："></a>多 key md5 认证规则：</h3><p>当配置了最新的 key，将最新 key 与旧 key 都发送到对端：</p><ul><li>若最新的 key，到对端没有找到对应的 key-id，则两端采用旧 key 完成认证。</li><li>若最新的 key，到对端找到相同的key-id，比较密钥，密钥不一致，认证失败；密钥一致，则认证通</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;OSPF全称&lt;strong&gt;开放最短路径优先&lt;/strong&gt;（Open Shortest Path First）是一种&lt;strong&gt;链路</summary>
      
    
    
    
    <category term="路由交换RS" scheme="https://arclogicr.github.io/categories/%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2RS/"/>
    
    
    <category term="network" scheme="https://arclogicr.github.io/tags/network/"/>
    
    <category term="routing" scheme="https://arclogicr.github.io/tags/routing/"/>
    
    <category term="ospf" scheme="https://arclogicr.github.io/tags/ospf/"/>
    
  </entry>
  
  <entry>
    <title>IPv4地址</title>
    <link href="https://arclogicr.github.io/2022/03/17/ipv4/"/>
    <id>https://arclogicr.github.io/2022/03/17/ipv4/</id>
    <published>2022-03-17T10:16:23.000Z</published>
    <updated>2022-10-28T09:47:39.067Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>IPv4，全称Internet Protocol version 4，网际互联协议第四版。“the Internet”专指的互联网，而这里感觉internet翻译成“网络之间”、“网际”比较好，而不是“互联网”。</p><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>IP地址是IP协议中重要的一个逻辑概念，它用来去定位、寻找网络的组成部分中的一个（单播）或一些（多播、组播）</p><h3 id="IP地址的组成"><a href="#IP地址的组成" class="headerlink" title="IP地址的组成"></a>IP地址的组成</h3><p>一个IP地址由4组8位的二进制数组成，中间用“.”分隔，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11000000.10101000.00000001.00000010</span><br></pre></td></tr></table></figure><p>二进制位数太多，为了记忆、表达方便，一般采用十进制方式表达，每一段取值区间为[0,255]，上述IP地址可表示为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.2</span><br></pre></td></tr></table></figure><h3 id="掩码（Mask）"><a href="#掩码（Mask）" class="headerlink" title="掩码（Mask）"></a>掩码（Mask）</h3><p>一个IP地址共有4×8&#x3D;32位组成，按照位来划分，可人为定义主机号和网络号，比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.2</span><br></pre></td></tr></table></figure><p>我们定义前24位是网络位，后面8位是主机位。如此一来，我们可以很方便地根据前24位IP来定位一个网络，后8位来定位一台主机。其中192.168.1.0表示一个<strong>网络号</strong>，192.168.1.2表示192.168.1.0这个网络中的一台主机，24是192.168.1.0这个网络的<strong>掩码长度</strong>。</p><p>很容易发现192.168.1.0这个网络可用前24位唯一标识，而后8位主机位不能影响我们识别一个网络。那么我们将192.168.1.2化为二进制11000000.10101000.00000001.00000010，将它和由24个1和8个0组成的“IP”地址11111111.11111111.11111111.00000000进行’与’操作，得到的恰好就是它的网络号11000000.10101000.00000001.00000000(192.168.1.0)。把这个特殊的“IP”化为二进制得到255.255.255.0，这就是<strong>子网掩码</strong>。</p><h3 id="IP地址分类、私有地址"><a href="#IP地址分类、私有地址" class="headerlink" title="IP地址分类、私有地址"></a>IP地址分类、私有地址</h3><h4 id="有类划分"><a href="#有类划分" class="headerlink" title="有类划分"></a>有类划分</h4><p>早期IP地址有一套有类划分方式，即根据一定则将IP地址根据子网掩码&#x2F;8，&#x2F;16，&#x2F;24分为不同类。但是这种分类方案显然并不十分合理，浪费IP资源。比如一个固定20台终端的部门被分配了&#x2F;24掩码的网段，那么有230多个地址没有被使用。</p><h4 id="无类划分"><a href="#无类划分" class="headerlink" title="无类划分"></a>无类划分</h4><p>后来有了VLSM（可变长子网掩码）的概念，即可任意指定子网掩码。早期的路由协议如ripv1，igrp等都是只支持有类路由的；而CIDR(无类域间路由)，是基于VLSM的。</p><h4 id="私有IP地址"><a href="#私有IP地址" class="headerlink" title="私有IP地址"></a>私有IP地址</h4><p>IP地址是一个逻辑概念，用于定位互联的网络中一台终端。理论上一个网络中所有IP地址不能有重复，但是由于IPv4地址耗尽，必须复用一些IP地址。一些不接入互联网的组织、单位、机构等，只需内部网络IP地址保持唯一即可。私有IP就是为这种场景设计的，在IP地址的有类划分中，每一类都有一个私有地址段。当然这种场景下，如果有访问互联网的需求，在公网地址有限的情况下，可以通过NAT技术实现私有网络与互联网互通。</p><h4 id="IPv4地址有类划分"><a href="#IPv4地址有类划分" class="headerlink" title="IPv4地址有类划分"></a>IPv4地址有类划分</h4><h5 id="A类地址"><a href="#A类地址" class="headerlink" title="A类地址"></a>A类地址</h5><p>IP地址第一段首位固定为0，即</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0xxxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx</span><br></pre></td></tr></table></figure><p>由于第一位固定是0，第一段取值范围为0-127</p><p>A类私有地址为10.0.0.0&#x2F;8<br>A类地址占总地址1&#x2F;2</p><h5 id="B类地址"><a href="#B类地址" class="headerlink" title="B类地址"></a>B类地址</h5><p>首位固定10，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10xxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx</span><br></pre></td></tr></table></figure><p>第一段取值范围是128-191</p><p>私有地址172.16.16.0&#x2F;12 (16-31) 16个B</p><h5 id="C类地址"><a href="#C类地址" class="headerlink" title="C类地址"></a>C类地址</h5><p>首位固定110</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">110xxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx</span><br></pre></td></tr></table></figure><p>第一段取值范围192-223</p><p>私有地址192.168.0.0&#x2F;16 256个C</p><p>C类地址占总地址1&#x2F;8</p><h5 id="D类地址（组播，没有网络号和主机号）"><a href="#D类地址（组播，没有网络号和主机号）" class="headerlink" title="D类地址（组播，没有网络号和主机号）"></a>D类地址（组播，没有网络号和主机号）</h5><p>首位固定1110</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1110xxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx</span><br></pre></td></tr></table></figure><p>首段取值224-239</p><p>私有地址239.0.0.0&#x2F;8</p><p>D类地址占总地址1&#x2F;16</p><h5 id="E类地址为实验地址，为除ABCD类之外的地址"><a href="#E类地址为实验地址，为除ABCD类之外的地址" class="headerlink" title="E类地址为实验地址，为除ABCD类之外的地址"></a>E类地址为实验地址，为除ABCD类之外的地址</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;IPv4，全称Internet Protocol version 4，网际互联协议第四版。“the Internet”专指的互联网，而这里感</summary>
      
    
    
    
    <category term="网络基础" scheme="https://arclogicr.github.io/categories/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="network" scheme="https://arclogicr.github.io/tags/network/"/>
    
    <category term="tcp/ip" scheme="https://arclogicr.github.io/tags/tcp-ip/"/>
    
  </entry>
  
</feed>
