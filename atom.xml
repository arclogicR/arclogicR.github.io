<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Arclogic&#39;s Blog</title>
  
  <subtitle>subtitleA</subtitle>
  <link href="https://arclogicr.github.io/atom.xml" rel="self"/>
  
  <link href="https://arclogicr.github.io/"/>
  <updated>2023-01-20T15:11:55.629Z</updated>
  <id>https://arclogicr.github.io/</id>
  
  <author>
    <name>Arclogic</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用VirtualBox部署OpenWrt充当旁路由</title>
    <link href="https://arclogicr.github.io/2023/01/14/openwrt-ply/"/>
    <id>https://arclogicr.github.io/2023/01/14/openwrt-ply/</id>
    <published>2023-01-14T13:17:08.000Z</published>
    <updated>2023-01-20T15:11:55.629Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景知识简介"><a href="#背景知识简介" class="headerlink" title="背景知识简介"></a>背景知识简介</h1><h2 id="Openwrt简介"><a href="#Openwrt简介" class="headerlink" title="Openwrt简介"></a>Openwrt简介</h2><h3 id="什么是Openwrt"><a href="#什么是Openwrt" class="headerlink" title="什么是Openwrt"></a>什么是Openwrt</h3><p>OpenWrt是一个嵌入式系统，为不同的嵌入式设备（通常是无线路由器）开发的可扩展的GNU&#x2F;Linux发行版。Openwrt最早是由Linksys公司的WRT-54G系统开源而来，后有DD-WRT，HyperWRT等发行版。Openwrt基于Linux内核，可以轻松的扩展所需要的功能。</p><h3 id="为什么使用Openwrt"><a href="#为什么使用Openwrt" class="headerlink" title="为什么使用Openwrt"></a>为什么使用Openwrt</h3><p>传统家用无线路由器自带的官方固件一般比较封闭，功能固定；OpenWrt系统相比之下比较开放，支持大量的Openwrt官方和非官方的软件包，也可自行开发功能。你甚至可以在OpenWrt上运行docker，极大地提升网络的可玩性和访问体验。另外，OpenWrt是开源的嵌入式Linux系统，支持多种设备和平台，如各式无线路由器、x86、ARM等。你可以自行定义OpenWrt运行的设备的平台和配置，而无需受限于传统路由器固有硬件。</p><h3 id="旁路网关简介"><a href="#旁路网关简介" class="headerlink" title="旁路网关简介"></a>旁路网关简介</h3><h4 id="什么是旁路网关"><a href="#什么是旁路网关" class="headerlink" title="什么是旁路网关"></a>什么是旁路网关</h4><p>旁路网关，俗称旁路由。顾名思义，旁路网关是在主路网关旁边的路由设备，起到辅助的路由和包处理的一些功能，通常旁路网关本身不具备直接访问Internet的能力。正常情况下，局域网内的终端通过主路由器访问Internet，主路由器的LAN口也是属于这个局域网的接口。当局域网中出现另一台路由器（比如OpenWrt）时，可以将其看作是旁路网关。在不对主路网关、旁路网关和终端设备做特殊操作的情况下，终端并不知道旁路网关的存在，流量还是正常走主路网关。可以通过配置让全部&#x2F;部分终端设备的全部&#x2F;部分流量经过旁路由。</p><p><img src="/2023/01/14/openwrt-ply/ply1.png" alt="OPWRT PLY1"></p><h4 id="为什么使用旁路网关"><a href="#为什么使用旁路网关" class="headerlink" title="为什么使用旁路网关"></a>为什么使用旁路网关</h4><p>旁路网关的本质是让终端设备的网络流量在转发到主路网关前经过自己，同时可以对这些流量进行一些特殊的处理。旁路网关的存在是为了弥补主路网关缺失的一些功能，同时又不想对网络拓扑结构做大的改动，或者根本无法改动。下面列举两个使用旁路网关的常见场景：</p><ul><li><p>我想在路由器上部署一些特殊的转发策略，只想让自己的终端设备可以按照这些策略转发，不想影响其它的终端设备</p></li><li><p>我想使用一些开源的服务，但有不想中断现有的网络而影响其他人</p></li></ul><h2 id="使用VirtualBox部署OpenWrt充当旁路网关"><a href="#使用VirtualBox部署OpenWrt充当旁路网关" class="headerlink" title="使用VirtualBox部署OpenWrt充当旁路网关"></a>使用VirtualBox部署OpenWrt充当旁路网关</h2><p>本次部署的目的是使用VBox虚拟机部署OpenWrt充当旁路由，然后再局域网内使用手机可以通过旁路由上网。网络拓扑如下：</p><p><img src="/2023/01/14/openwrt-ply/topo.png" alt="OPWRT TOPO"></p><h3 id="获取OpenWrt官方镜像"><a href="#获取OpenWrt官方镜像" class="headerlink" title="获取OpenWrt官方镜像"></a>获取OpenWrt官方镜像</h3><p>由于采用的是VBox虚拟机，我们需要x86架构64位的镜像文件。可以从官网下载<a href="https://downloads.openwrt.org/releases/22.03.3/targets/x86/64/">Index of &#x2F;releases&#x2F;22.03.3&#x2F;targets&#x2F;x86&#x2F;64&#x2F;</a></p><p>这里有很多包，其中包含squashfs字样的是可以通过命令恢复成初始配置的镜像，适合于不喜欢折腾的童鞋。这里我选择了generic-ext4-combined.img.gz这个镜像，版本为22.03.3，解压后获得openwrt22.03.3-x86-64-generic-ext4-combined.img这个文件。</p><h3 id="将img转换为VirtualBox支持的虚拟硬盘格式"><a href="#将img转换为VirtualBox支持的虚拟硬盘格式" class="headerlink" title="将img转换为VirtualBox支持的虚拟硬盘格式"></a>将img转换为VirtualBox支持的虚拟硬盘格式</h3><p>如果你想要安装在硬件软路由上，你需要用img文件通过启动盘制作工具制作启动U盘；这里由于是虚拟机运行，只需转换为VBox支持的虚拟硬盘格式。可以使用VBox自带工具，在cmd控制台VBox安装目录中，使用如下命令转换：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VBoxManage convertdd openwrt22.03.3-x86-64-generic-ext4-combined.img openwrt.vdi</span><br></pre></td></tr></table></figure><h3 id="创建VirtualBox虚拟机"><a href="#创建VirtualBox虚拟机" class="headerlink" title="创建VirtualBox虚拟机"></a>创建VirtualBox虚拟机</h3><p>在VBox中创建虚拟机。</p><p><img src="/2023/01/14/openwrt-ply/vm1.png" alt="OPWRT VM1"></p><p><img src="/2023/01/14/openwrt-ply/vm2.png" alt="OPWRT VM2"></p><p>其中，</p><p>操作系统可以选择Linux，Other Linux 64bits</p><p>CPU和内存分配为1C 1G即可</p><p>硬盘需要选择我们刚刚转换好的vdi格式的虚拟硬盘</p><h3 id="配置VirtualBox虚拟机网络"><a href="#配置VirtualBox虚拟机网络" class="headerlink" title="配置VirtualBox虚拟机网络"></a>配置VirtualBox虚拟机网络</h3><p>由于我们将OpenWrt用作旁路由，我们只需要一个接口即可。在刚生成的虚拟机中选择设置网络，网络模式选择桥接，<strong>并且必须桥接到有线网卡，宿主机（电脑）也必须有线连接路由器</strong>（因为VBox的桥接机制问题），开启混杂模式。开启混杂模式的原因是让宿主机（电脑）的网卡接受目的地址不为宿主机（而是虚拟机）的数据包。</p><p><img src="/2023/01/14/openwrt-ply/vm3.png" alt="OPWRT VM3"></p><h3 id="配置OpenWrt"><a href="#配置OpenWrt" class="headerlink" title="配置OpenWrt"></a>配置OpenWrt</h3><p>配置完网络之后，我们可以开启虚拟机了。但开启虚拟机之前最好在虚拟机网络设置中去掉“接入网线”选项，勾掉这个选项虚拟机暂时不会连接到任何网路，这样的目的是为了阻止OpenWrt回应终端的DHCP请求而分配了192.168.1.0的地址。</p><h4 id="修改OpenWrt管理地址"><a href="#修改OpenWrt管理地址" class="headerlink" title="修改OpenWrt管理地址"></a>修改OpenWrt管理地址</h4><p>开机后，在虚拟机控制按下回车就可以输入命令了。Openwrt默认lan口是192.168.1.1&#x2F;24的地址，默认网卡名为br-lan我们先把lan口地址改为当前局域网的空地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig br-lan 192.168.3.100</span><br></pre></td></tr></table></figure><p>不需要输入掩码，掩码默认24位</p><p>修改ip地址后就可以通过192.168.3.100来访问web界面了（如果取消了接入网线，需要把哪个勾勾起来）</p><h4 id="关闭OpenWrt的DHCP功能"><a href="#关闭OpenWrt的DHCP功能" class="headerlink" title="关闭OpenWrt的DHCP功能"></a>关闭OpenWrt的DHCP功能</h4><p>进入web界面后第一步先把LAN口的dhcp关了，我们不需要旁路网关分配ip地址。</p><p>在Network-Interface下找到br-lan这个网卡，在edit-DHCP server里面选择ignore this interface。记得点save &amp; apply生效。</p><p><img src="/2023/01/14/openwrt-ply/op1.png" alt="OPWRT OP1"></p><p>然后可以修改个root密码，新版本OpenWrt不改默认密码会有提示。</p><h4 id="配置新接口"><a href="#配置新接口" class="headerlink" title="配置新接口"></a>配置新接口</h4><p>由于OpenWrt默认接口时桥接接口，我们不需要桥接（当然使用桥接也可以）。删除原有br-lan接口，然后新建接口add new interface，协议为static address，物理接口选择eth0。</p><p><img src="/2023/01/14/openwrt-ply/op2.png" alt="OPWRT OP2"></p><p>然后配置IP和子网掩码配置为和原来一样192.168.3.100，网关配置为主路由器地址，比如192.168.3.1</p><h4 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h4><p>新街口配置完成后，此时OpenWrt和一般的终端一样应该可以访问Internet了。在System-Software中更新lists。更新后可以在filter搜索官方软件包们这里可以安装中文包luci-i18n-base-zh-cn 和tcpdump抓包。其它官方包都可以在这个界面安装，非官方包需要下载ipk文件手动opkg install来安装</p><h4 id="配置OpenWrt防火墙"><a href="#配置OpenWrt防火墙" class="headerlink" title="配置OpenWrt防火墙"></a>配置OpenWrt防火墙</h4><p>防火墙的策略应该是仅有的LAN口出、入、转发应当全部放通，最好使用IP地址动态装（MASQUERADING）</p><p>首先删除其它区域的策略，只留下Lan区域，然后修改Lan区域配置如下，</p><p><img src="/2023/01/14/openwrt-ply/op3.png" alt="OPWRT OP3"></p><p>注意需要绑定接口eth0，另外上面默认的FORWARD策略是reject，无需修改。</p><p>然后将Lan的出、入、转发全部放通，勾选MASQUERADING</p><p><img src="/2023/01/14/openwrt-ply/op4.png" alt="OPWRT OP4"></p><p>其中，</p><p>需要勾选FOWARD策略</p><p>勾选MASQUERADING后，旁路网关会将终端的IP以PAT的形式转换为旁路网关的IP，这样可以保证上下行路径一致，避免未知问题。如果不勾选，旁路网关只做转发不做PAT，那么终端流量上行走的是旁路网关，下行主路由直接回复。</p><h3 id="修改终端设备网关"><a href="#修改终端设备网关" class="headerlink" title="修改终端设备网关"></a>修改终端设备网关</h3><p>将手机的网关和DNS设置为OpenWrt地址，即可通过OpenWrt上网。如果想要所有终端都可以通过旁路网关上网，可以修改主路由器的DHCP设置，令dhcp下发默认网关改为OpenWrt的IP地址。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景知识简介&quot;&gt;&lt;a href=&quot;#背景知识简介&quot; class=&quot;headerlink&quot; title=&quot;背景知识简介&quot;&gt;&lt;/a&gt;背景知识简介&lt;/h1&gt;&lt;h2 id=&quot;Openwrt简介&quot;&gt;&lt;a href=&quot;#Openwrt简介&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="疑难杂症" scheme="https://arclogicr.github.io/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    
    
    <category term="network" scheme="https://arclogicr.github.io/tags/network/"/>
    
    <category term="openwrt" scheme="https://arclogicr.github.io/tags/openwrt/"/>
    
    <category term="virtualbox" scheme="https://arclogicr.github.io/tags/virtualbox/"/>
    
  </entry>
  
  <entry>
    <title>OpenWrt防火墙翻译</title>
    <link href="https://arclogicr.github.io/2023/01/12/openwrt-fw1/"/>
    <id>https://arclogicr.github.io/2023/01/12/openwrt-fw1/</id>
    <published>2023-01-12T10:34:55.000Z</published>
    <updated>2023-01-20T03:25:31.879Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Firewall-and-network-interfaces"><a href="#Firewall-and-network-interfaces" class="headerlink" title="Firewall and network interfaces"></a>Firewall and network interfaces</h4><p>The goal of a router is to forward packet streams from incoming network interfaces to outgoing network interfaces. Firewall rules add another layer of granularity to what is allowed to be forwarded across interfaces - and additionally which packets are allowed to be inputted to, and outputted from, the router itself. This section discusses the relationships between the firewall code and the network interfaces.</p><p>At the heart of all routers is a hardware switch with a number of interface ports. When a packet enters one of the switch ports, the hardware switch matches a fixed field in the packet and forwards the packet to an output port which transmits it.</p><h4 id="防火墙和网络接口"><a href="#防火墙和网络接口" class="headerlink" title="防火墙和网络接口"></a>防火墙和网络接口</h4><p>路由器的目标是从入向网络接口到出向网络接口转发分组流。防火墙规则增加了另一个层面的粒度；即，什么分组可以跨接口转发，还有哪些分组可以被允许进入和离开该路由器。本章讨论防火墙代码和网络接口之间的关系。</p><p>所有路由器的核心就是一个带有一些端口硬件交换机。当一个分组进入其中一个交换端口，硬件交换机匹配该分组内固定的字段并转发到一个可传输它的出接口。</p><p>The switch generally uses the layer-2 destination MAC address in the packet to switch on. Each port has a cache of MAC addresses for stations reachable by (attached to) that port. Entries in the MAC cache gradually out, so must be re-discovered if used again. Layer-2 frames with a known destination MAC are switched to the desired LAN port. If the MAC is not present anywhere in the switch cache, a broadcast packet (e.g. ARP) is flooded to all LAN ports to discover which has access to the destination MAC.</p><p>交换机通常使用分组中的二层目的MAC地址进行分组交换。每个端口都有一个MAC地址缓存表记录与它可达的（直连的）站点。MAC缓存条目会逐渐消失，所以必须重新发现，如果要被使用的话。已知目的MAC的二层帧被交换到期待的LAN口。如果MAC在交换机缓存中不存在，则一个广播包（如ARP）会被泛洪到所有的LAN口用来发现哪个口接着该目的MAC。</p><p>OpenWrt routers have two types of LAN interface: wired Ethernet (IEEE802.3 or RFC894 Ethernet II, Ethernet II being the most common) and wireless Ethernet (IEEE802.11.)</p><p>The wired LAN ports each map directly to a single switch port. Generally there is one 802.11 Wi-Fi port attached to a Wi-Fi radio chip (2.4Ghz, 5Ghz). Each handles one or more IEEE802.11 standard protocols (e.g. 802.11a, 802.11n) and ancillary support for wireless networks (e.g. 802.11s mesh networking). The Wi-Fi chips convert the 802.11 signal into a canonical ethernet frame injected into the switch port for routing. All Wi-Fi stations connected to the 802.11 Access Point use the same radio(s) and the same switch port.</p><p>OpenWrt路由器有两种LAN接口：有线以太网（IEEE802.3 或RFC894 EthernetII，EthernetII是最常见的）和无线以太网（IEEE802.11）。</p><p>每个有线LAN端口直接对应一个单独的交换口。通常有一个802.11Wi-Fi口附在一个Wi-Fi无线电芯片（2.4Ghz，5Ghz）。每个处理一个或多个IEEE802.11标准协议（如802.11a，802.11n）和对无线网络的附加支持（如802.11s mesh网络）。WiFi芯片将802.11信号转换到一个添加到交换端口来进行路由的典型以太网帧。所有连接到802.11无线接入点的Wi-Fi站点使用相同的无线电接收器在相同的交换端口。</p><h4 id="LAN-bridge"><a href="#LAN-bridge" class="headerlink" title="LAN bridge"></a>LAN bridge</h4><p>The LAN bridge combines the WLAN interface(s) with the wired LAN ports to create a single logical network. In the interface configuration set option type bridge or in LuCI Network→Interfaces→LAN Bridge interfaces box and select the physical interfaces to bridge together. All switch ports in the bridge will act as a single network.</p><p>The new pseudo-interface has a br- prepended to the interface name, generally br-lan.<br>Use bridging when combining WLAN and wired Ethernet ports. Otherwise partition the ports into VLANs.</p><h4 id="局域网网桥"><a href="#局域网网桥" class="headerlink" title="局域网网桥"></a>局域网网桥</h4><p>LAN网桥组合WLAN接口和有线LAN接口用来创建一个单独的逻辑网络。在‘interface’配置中设置‘option type bridge’或LuCI中’Network’-‘Interfaces’-‘LAN网桥接口’选项并选择需要桥接在一起的物理接口。所有网桥中的交换端口将成为一个单独的网络。</p><p>新的伪端口有一个’br-‘在接口名字前，通常为’br-lan’。</p><p>当组合WLAN和有线以太网时使用桥接。否则应使用VLAN分割端口。</p><h4 id="Firewall-Zones"><a href="#Firewall-Zones" class="headerlink" title="Firewall Zones"></a>Firewall Zones</h4><p>The firewall of an OpenWrt router is able to collect interfaces into zones to more logically filter traffic. A zone can be configured to any set of interfaces but generally there are at least two zones: lan for the collection of LAN interfaces and wan for the WAN interfaces.</p><p>This simplifies the firewall rule logic somewhat by conceptually grouping the interfaces:</p><p>A rule for a packet originating in a zone must be entering the router on one of the zone’s interfaces,<br>A rule for a packet being forwarded to a zone must be exiting the router on one of the zone’s interfaces.<br>recognize the zone concept does not significantly simplify a simple SOHO router with a single br-lan interface and a single wan interface. Each interface has a one-to-one mapping with a zone.</p><h4 id="防火墙区域"><a href="#防火墙区域" class="headerlink" title="防火墙区域"></a>防火墙区域</h4><p>OpenWrt路由器上的防火墙能够帮接口集中在区域中用来更逻辑化地过滤流量。一个区域可以被配置到任何一个接口组但通常至少有两个区域：lan用来集中LAN接口，wan用来集中WAN接口。</p><p>通过概念上给接口分组某种程度上简化了防火墙的规则逻辑：</p><p>源于一个区域的数据包的规则是必须在路由器该区域的一个接口进入</p><p>被转发到一个区域的分组的规则是必须在路由器该区域的一个接口离开</p><p>注意区域的概念不能显著简化一个简单的SOHO路由器通过单独的br-lan接口和单独的wan接口。每个接口都有一个1对1映射的区域。</p><h3 id="Firewall-components"><a href="#Firewall-components" class="headerlink" title="Firewall components"></a>Firewall components</h3><p>The OpenWrt firewall implementation is the mechanism by which network traffic is filtered coming through the router. At a high level, one of three outcomes will occur: either the packet is discarded (dropped) without any further action, rejected (with an appropriate response to the source), or accepted (routed to the destination). Note that the router itself is a destination for management and monitoring.</p><p>The OpenWrt firewall revolves around the Linux netfilter project. There are the following main components to the OpenWrt firewall:</p><p>the firewall3 application<br>a set of netfilter hooks in the kernel networking stacks<br>a set of linux kernel modules that handle the inspection of network packets<br>a set of kernel tuning parameters to configure the network stacks and firewall modules<br>This documentation is based on OpenWrt 18.06.0. Many of the configurations have been tested against this release using the test network</p><h4 id="Firewall3-fw3"><a href="#Firewall3-fw3" class="headerlink" title="Firewall3 (fw3)"></a>Firewall3 (fw3)</h4><p>The fw3 application package is the main application used to provision the firewall. It was developed by the OpenWrt team specifically for the project.</p><h3 id="防火墙组成"><a href="#防火墙组成" class="headerlink" title="防火墙组成"></a>防火墙组成</h3><p>OpenWrt防火墙的运行机制就是过滤通过路由器的网络流量。在更高的层面上，三个当中的一个结果将会发生：分组要么被丢弃而没有任何进一步操作，要么被拒绝（对源有适当的响应），要么被接受（路由到目的地）。注意路由器本身是一个管理和监控的目的地。</p><h4 id="fw3"><a href="#fw3" class="headerlink" title="fw3"></a>fw3</h4><p>fw3应用包是主要的用来置备（prov团ision）防火墙的应用。它由OpenWrt团队为这个项目特别开发。</p><h4 id="Kernel-netfilter-hooks"><a href="#Kernel-netfilter-hooks" class="headerlink" title="Kernel netfilter hooks"></a>Kernel netfilter hooks</h4><p>Each of the network stacks have netfilter functions call hooks embedded at specific places in the code. As a network packet moves through the stack, each hook is called to check the packet against possible netfilter rules bound to the hook.</p><p>The netfilter hook code uses the NF_HOOK set of macros. Each hook takes the following arguments:</p><ul><li><p>network protocol: unspec (all), ipv4, ipv6, arp, bridge, decnet</p></li><li><p>hook num: PRE_ROUTING, LOCAL_IN, FORWARD, LOCAL_OUT, POST_ROUTING</p></li><li><p>net structure: context for the network stack</p></li><li><p>socket: BSD socket used for packet</p></li><li><p>network packet: a socket buffer containing the network packet</p></li><li><p>incoming device (interface): the source of the packet</p></li><li><p>outgoing device (interface): the destination of the packet after routing</p></li><li><p>a function callback if the packet passes the filter</p></li></ul><h3 id="内核netfilter-hooks"><a href="#内核netfilter-hooks" class="headerlink" title="内核netfilter hooks"></a>内核netfilter hooks</h3><p>每个网络栈都有一个netfilter功能嵌入在代码中的某个特殊地方。当一个网络分组在堆栈中移动时，每个hook会被调用来根据绑定到狗子的可能的netfilter规则检查分组。</p><p>Netfilter hook代码使用NF_HOOK宏组。每个hook采用以下参数：</p><ul><li><p>network protocol: unspec (all), ipv4, ipv6, arp, bridge, decnet</p></li><li><p>hook num: PRE_ROUTING, LOCAL_IN, FORWARD, LOCAL_OUT, POST_ROUTING</p></li><li><p>net structure: 网络栈的环境</p></li><li><p>socket: 为分组使用的BSD套接字</p></li><li><p>network packet: 一个包含分组的套接字缓存</p></li><li><p>incoming device (interface): 分组源</p></li><li><p>outgoing device (interface): 分组路由后的目的r</p></li><li><p>回调函数，如果分组通过过滤器</p></li></ul><h4 id="Kernel-netfilter-modules"><a href="#Kernel-netfilter-modules" class="headerlink" title="Kernel netfilter modules"></a>Kernel netfilter modules</h4><p>The netfilter kernel modules are loaded at boot depend on the configured. There are roughly 35 kernel modules to support the standard netfilter capabilities but there are many more depending on the requirements of the router. For example, many routers use the ipset feature. This adds ~16 additional kernel modules.</p><p>Most of the netfilter modules are small, providing a single specific capability. For example:</p><ul><li><p>ipt_REJECT performs REJECT (target),</p></li><li><p>xt_multiport performs match of the IP port (match)</p></li><li><p>xt_TCPMSS performs Maximum Segment Size adjustment in the TCP header (target in mangle table)</p><p>Several of the netfilter modules are larger. For example:</p></li><li><p>nf_conntrack performs connection tracking for masquerading (NAT) and packet de-fragmentation.</p></li></ul><h4 id="Kernel-tuning-via-sysctl"><a href="#Kernel-tuning-via-sysctl" class="headerlink" title="Kernel tuning via sysctl"></a>Kernel tuning via sysctl</h4><p>&#x2F;etc&#x2F;init.d&#x2F;sysctl is executed at boot time. This is a shell script that loads &#x2F;etc&#x2F;sysctl.conf and all files under &#x2F;etc&#x2F;sysctl.d&#x2F;. These set&#x2F;tune kernel parameters to provide OpenWrt features. See sysctl.conf.</p><p>All are parameters documented under the Documentation&#x2F;networking directory of kernel source tree so the specifics will not be repeated here. See ip-sysctl.txt and nf_conntrack-sysctl.txt for reference.</p><p>Since the OpenWrt feature set is fairly static, the kernel parameters almost certainly do not need to tuned beyond the defaults provided in the build.</p><p>Notice that netfilter bridging support in the kernel is disabled! See ip-sysctl.txt:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bridge-nf-call-iptables - BOOLEAN</span><br><span class="line"> 1 : pass bridged IPv4 traffic to iptables&#x27; chains.</span><br><span class="line"> 0 : disable this.</span><br><span class="line"> Default: 1</span><br></pre></td></tr></table></figure><h4 id="内核netfilter模块"><a href="#内核netfilter模块" class="headerlink" title="内核netfilter模块"></a>内核netfilter模块</h4><p>netfilter内核模块按照配置在启动时被加载。有大概35个内核模块支持标准网络过滤能力，但是有很多更取决于路由器的条件。比如，很多路由器使用ipset功能。这增加了~16个额外内核模块。</p><p>大多数的netfilter模块比较小，提供一个单独而特殊的能力。例如：</p><ul><li><p>ipt_REJECT — REJECT (target),</p></li><li><p>xt_multiport — match of the IP port (match)</p></li><li><p>xt_TCPMSS — Maximum Segment Size adjustment in the TCP header (target in mangle table)</p></li></ul><p>有几个netfilter模块很大。例如：</p><ul><li>nf_conntrack — connection tracking for masquerading (NAT) and packet de-fragmentation.</li></ul><h4 id="内核调节通过sysctl"><a href="#内核调节通过sysctl" class="headerlink" title="内核调节通过sysctl"></a>内核调节通过sysctl</h4><p>&#x2F;etc&#x2F;init.d&#x2F;sysctl在启动时执行。这是一个shell脚本来载入&#x2F;etc&#x2F;sysctl.conf和在&#x2F;etc&#x2F;sysctl.d&#x2F;下的所有文件。这些设置&#x2F;调整内核参数提供了OpenWrt的功能。参见sysctl.conf。</p><p>所有都是在内核源码树的Documentation&#x2F;networking目录下记录的参数，这里不再赘述。 请参阅 ip-sysctl.txt 和 nf_conntrack-sysctl.txt 以供参考。</p><p>既然OpenWrt功能集合是比较静态的，内核参数几乎不需要调整到超出构建时的默认值。</p><p>注意netfilter桥接支持在内核中是关闭的！参见ip-sysctl.txt：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bridge-nf-call-iptables - BOOLEAN</span><br><span class="line"> 1 : pass bridged IPv4 traffic to iptables&#x27; chains.</span><br><span class="line"> 0 : disable this.</span><br><span class="line"> Default: 1</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;Firewall-and-network-interfaces&quot;&gt;&lt;a href=&quot;#Firewall-and-network-interfaces&quot; class=&quot;headerlink&quot; title=&quot;Firewall and network interface</summary>
      
    
    
    
    <category term="文档翻译" scheme="https://arclogicr.github.io/categories/%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    
    
    <category term="network" scheme="https://arclogicr.github.io/tags/network/"/>
    
    <category term="firewall" scheme="https://arclogicr.github.io/tags/firewall/"/>
    
    <category term="openwrt" scheme="https://arclogicr.github.io/tags/openwrt/"/>
    
    <category term="translation" scheme="https://arclogicr.github.io/tags/translation/"/>
    
  </entry>
  
  <entry>
    <title>kvm如何禁止虚拟机之间通信</title>
    <link href="https://arclogicr.github.io/2023/01/04/kvmq1/"/>
    <id>https://arclogicr.github.io/2023/01/04/kvmq1/</id>
    <published>2023-01-04T07:37:05.000Z</published>
    <updated>2023-01-12T10:34:27.808Z</updated>
    
    <content type="html"><![CDATA[<p>一般来说，使用KVM创建虚拟机，都会有虚拟机之间通信的需求，KVM的四种网络模式也都默认允许同一网段的虚拟机之间互通。如果有特殊需求，需要禁止虚拟机之间的通信，该如何配置？</p><h3 id="KVM四种网络模式"><a href="#KVM四种网络模式" class="headerlink" title="KVM四种网络模式"></a>KVM四种网络模式</h3><ul><li><p>首先隔离模式，相当于Vmware&#x2F;Vbox 仅主机模式，VM之间可通信，VM与宿主可通信，VM与外部不可通信</p></li><li><p>NAT模式，VM之间可通信，VM与宿主可通信，VM可访问外部，外部访问VM需要做端口转发</p></li><li><p>桥接模式，VM之间可通信，VM与宿主可通信，VM可访问外部，外部可访问VM。一般桥接模式下VM网段与宿主机同段。</p></li><li><p>路由模式，VM之间可通信，VM与宿主可通信，VM可访问外部，外部可访问VM。路由模式下VM网段可以与宿主机不同端，外部需要配置路由才能访问VM</p></li></ul><h3 id="iptables解决方案"><a href="#iptables解决方案" class="headerlink" title="iptables解决方案"></a>iptables解决方案</h3><p>搜了资料，有人说可以用iptables实现，原理如下</p><p>NAT模式下，宿主机有一块网卡virbr0。针对virbr0，在iptables中FORWARD链限制同网段互访</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A FORWARD -i virbr0 -s 192.168.1.0/24 -d 192.168.1.0/24 -j DROP</span><br></pre></td></tr></table></figure><p>我尝试了下，不知为何不生效，也许因为虚拟机互访实际流量并不经过virbr0？尝试将FORWARD链改为INPUT链也是不生效。后来放弃iptables，改用nwfilter。</p><h3 id="nwfilter解决方案"><a href="#nwfilter解决方案" class="headerlink" title="nwfilter解决方案"></a>nwfilter解决方案</h3><p>nwfilter是kvm自带的网络流量工具，可以精确控制每一块vm网卡。上面iptables的方案是在宿主机上做策略，而nwfilter是对每一个vm做策略，nwfilter的策略可以应用在多个vm上。</p><p>总的来说nwfilter的用法就是，定义nwfilter策略，生效策略，应用策略。下面以NAT模式下禁止虚拟机之间互通为例介绍nwfilter解决方案</p><h4 id="定义策略"><a href="#定义策略" class="headerlink" title="定义策略"></a>定义策略</h4><p>在&#x2F;etc&#x2F;libvirt&#x2F;nwfilter下建立xml文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/libvir/nwfilter/deny-inter.xml</span><br></pre></td></tr></table></figure><p>写入规则</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter name=&#x27;deny-inter&#x27; chain=&#x27;ipv4&#x27; priority=&#x27;-700&#x27;&gt;</span><br><span class="line">  &lt;uuid&gt;ab4b9613-3442-41af-a4b3-0a3bdaae7111&lt;/uuid&gt;</span><br><span class="line">  &lt;rule action=&#x27;accept&#x27; direction=&#x27;in&#x27; priority=&#x27;200&#x27;&gt;</span><br><span class="line">    &lt;ip srcipaddr=&#x27;192.168.122.1&#x27; srcipmask=&#x27;32&#x27;/&gt;</span><br><span class="line">  &lt;/rule&gt;</span><br><span class="line">  &lt;rule action=&#x27;drop&#x27; direction=&#x27;in&#x27; priority=&#x27;201&#x27;&gt;</span><br><span class="line">    &lt;ip srcipaddr=&#x27;192.168.122.0&#x27; srcipmask=&#x27;24&#x27;/&gt;</span><br><span class="line">  &lt;/rule&gt;</span><br><span class="line">&lt;/filter&gt;</span><br></pre></td></tr></table></figure><p>其中，</p><p>这里只采用了ipv4的链，只需要对ip包进行过滤</p><p>注意uuid不要与现有的相同</p><p>每条规则后的优先级越小越优，如果优先级相同优先匹配前面的规则</p><p>这里的规则将来是应用在虚拟机上，所以in&#x2F;out是针对虚拟机网卡的</p><p>第一条规则是为了保证dhcp正常工作，这里用in方向策略会方便一点，因为dhcp discover包发出去是广播，dhcp offer包回来是单播，in方向只需要允许宿主机的单播包就可以了</p><p>更多nwfilter的详细用法可以参考<a href="https://wiki.libvirt.org/page/VirtualNetworking">VirtualNetworking - Libvirt Wiki</a></p><h4 id="生效策略"><a href="#生效策略" class="headerlink" title="生效策略"></a>生效策略</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">virsh nwfilter-define deny-inter.xml #生效策略</span><br><span class="line">virsh nwfilter-list #查看是否生效</span><br></pre></td></tr></table></figure><h4 id="应用策略"><a href="#应用策略" class="headerlink" title="应用策略"></a>应用策略</h4><p>编辑虚拟机配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virsh edit vm01</span><br></pre></td></tr></table></figure><p>找到<interface type>添加定义过的策略</interface></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;interface type=&#x27;network&#x27;&gt;</span><br><span class="line">  &lt;mac address=&#x27;52:54:00:ec:f5:4e&#x27;/&gt;</span><br><span class="line">  &lt;source network=&#x27;default&#x27;/&gt;</span><br><span class="line">  &lt;model type=&#x27;e1000&#x27;/&gt;</span><br><span class="line">  &lt;filterref filter=&#x27;deny-inter&#x27;/&gt; #ADD POLICY</span><br><span class="line">  &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x03&#x27; function=&#x27;0x0&#x27;/&gt;</span><br></pre></td></tr></table></figure><p>最后重启虚拟机，VM之间无法ping通，VM与宿主机可通，VM ping 外面可通。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一般来说，使用KVM创建虚拟机，都会有虚拟机之间通信的需求，KVM的四种网络模式也都默认允许同一网段的虚拟机之间互通。如果有特殊需求，需要禁止虚拟机之间的通信，该如何配置？&lt;/p&gt;
&lt;h3 id=&quot;KVM四种网络模式&quot;&gt;&lt;a href=&quot;#KVM四种网络模式&quot; class=</summary>
      
    
    
    
    <category term="疑难杂症" scheme="https://arclogicr.github.io/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    
    
    <category term="network" scheme="https://arclogicr.github.io/tags/network/"/>
    
    <category term="kvm" scheme="https://arclogicr.github.io/tags/kvm/"/>
    
  </entry>
  
  <entry>
    <title>IPv6地址</title>
    <link href="https://arclogicr.github.io/2022/04/17/ipv6/"/>
    <id>https://arclogicr.github.io/2022/04/17/ipv6/</id>
    <published>2022-04-17T12:54:13.000Z</published>
    <updated>2023-01-26T01:43:13.834Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IPv6简介"><a href="#IPv6简介" class="headerlink" title="IPv6简介"></a>IPv6简介</h2><h3 id="什么是IPv6"><a href="#什么是IPv6" class="headerlink" title="什么是IPv6"></a>什么是IPv6</h3><p>IPv6，Internet Protocol version 6（网际协议第六版），IPv4的升级版本。和IPv4类似，IPv6是一种逻辑编址方案，用于网络层主机到主机的通信。</p><h3 id="为什么使用IPv6"><a href="#为什么使用IPv6" class="headerlink" title="为什么使用IPv6"></a>为什么使用IPv6</h3><p>IPv4初期由于其协议简单、易于物理实现等优势，被广泛使用。随着互联网技术迅速发展，IPv4在很多方面已经无法满足现有需求，IPv6的问世解决了IPv4的很多弊端。</p><h4 id="IPv4的局限性-x2F-IPv6的优势"><a href="#IPv4的局限性-x2F-IPv6的优势" class="headerlink" title="IPv4的局限性&#x2F;IPv6的优势"></a>IPv4的局限性&#x2F;IPv6的优势</h4><ul><li>地址空间</li></ul><p>IPv4的理论可用地址数为2的32次方约43亿个，已经无法满足巨量终端的入网需求，只能依靠NAT等技术减少公网IP的使用。实际上在2019年11月25日欧洲RIPE NCC宣布IPv4地址正式耗尽。</p><p>IPv6地址采用128bit标识，理论上可用地址数是2的128次方，为全部IPv4地址的2的96次方倍，拥有近乎无限的地址空间。</p><ul><li>安全</li></ul><p>IPv4在设计上并没有考虑网络层的安全问题，当时认为安全是上层才需要负责的。</p><p>IPv6集成了IPSec，支持IPSec的认证和加密。由于充足的地址空间，使得层次化地址分配成为可能，容易溯源。对于攻击者，在有限的时间内，无法遍历巨量的IPv6地址。</p><ul><li>通信模型</li></ul><p>由于NAT的大量使用，破坏了端到端的模型，由此衍生了一些列繁琐的配置（如端口映射）</p><p>IPv6地址充足，无需使用NAT。</p><ul><li>路由聚合</li></ul><p>互联网在世界各地发展并不均衡，所以IPv4在分配时各地区所获得的地址并不连续。这会导致每个地区的公网路由无法被聚合，路由表会相当庞大，对路由设备性能要求极高。</p><p>IPv6可以很方便的进行层次化网络部署，方便路由聚合，提高转发效率。</p><ul><li>配置</li></ul><p>IPv4没有重编功能，网卡原则上职能配置一个IPv4地址，而一个网卡可以配置多个并重的IPv6问题，简化重编值的复杂性。</p><p>IPv6内置自动配置，可使得主机自动发现网络并获取IPv6地址，提高管理效率。</p><ul><li>处理效率</li></ul><p>IPv4包头字段相对较多，对网络设备有一定性能要求</p><p>IPv6去除了标志位、段偏移、头部校验和、选项等字段，只增加流标签域方便做QoS，因此IPv6报头更为简化，提高处理效率。</p><h2 id="IPv6地址"><a href="#IPv6地址" class="headerlink" title="IPv6地址"></a>IPv6地址</h2><h3 id="IPv6地址结构"><a href="#IPv6地址结构" class="headerlink" title="IPv6地址结构"></a>IPv6地址结构</h3><p>一个IPv6地址由128个bit组成。一个十六进制数可以表示4个bit，通常用32个16进制数四个一组表示IPv6地址。如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2001:0db8:02de:0000:0000:0000:0000:0e13/64</span><br></pre></td></tr></table></figure><p>在一个IPv6地址中分为前缀和接口号两个部分。前缀和IPv4中网络号类似，用于标识一个网络；接口号和IPv4中主机号类似，用于标识终端。上述IPv6地址所在的网络是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2001:0db8:02de:0000:0000:0000:0000:0000/64</span><br></pre></td></tr></table></figure><h3 id="IPv6地址表示"><a href="#IPv6地址表示" class="headerlink" title="IPv6地址表示"></a>IPv6地址表示</h3><h4 id="IPv6地址的简化表示"><a href="#IPv6地址的简化表示" class="headerlink" title="IPv6地址的简化表示"></a>IPv6地址的简化表示</h4><p>IPv6地址采用冒号分十六进制的方式表示。128bit长的IPv6地址可以表示8组4个十六进制数，用冒号隔开（如上述IPv6地址）。</p><p>其中，</p><ul><li><p>每一组的前导0可以省略</p></li><li><p>连续的0可以用::来省略</p></li><li><p>一个IPv6地址中只能使用一次::来省略连续的0（不然无法唯一确定连续0的个数）。</p></li></ul><p>如上述IPv6地址可简写为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2001:db8:2de::e13/64</span><br></pre></td></tr></table></figure><h4 id="URL的IPv6表示"><a href="#URL的IPv6表示" class="headerlink" title="URL的IPv6表示"></a>URL的IPv6表示</h4><p>在URL中，需要使用[]来确定IPv6地址，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://[2001:ab:123::cdef]:8080/index.html</span><br></pre></td></tr></table></figure><h4 id="IEEE-EUI-64规范"><a href="#IEEE-EUI-64规范" class="headerlink" title="IEEE EUI-64规范"></a>IEEE EUI-64规范</h4><p>IEEE EUI-64规范定义了如何将网络接口的MAC地址转换为IPv6接口标识。网卡物理地址由48bit组成，使用十六进制可表示为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0050:A1AB:CDEF</span><br></pre></td></tr></table></figure><p>MAC地址的前24位（0050A1）为厂商标识，后24位（ABCDEF）为扩展标识符。从高位数，第7位是0表示了MAC地址本地唯一。</p><p>MAC转换位IPv6接口方法：</p><p>将48位的MAC地址从中间分开，插入一个固定数值FFFE</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0050:A1AB:CDEF--&gt;0050:A1FF:FEAB:CDEF</span><br></pre></td></tr></table></figure><p>然后将第7个比特位反转，如果原来是0，就变为1,如果原来是1，就变为0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0050:A1FF:FEAB:CDEF--&gt;0250:A1FF:FEAB:CDEF</span><br></pre></td></tr></table></figure><p>这种由MAC地址产生IPv6地址接口标识的方法可以减少配置的工作量，尤其是当采用无状态地址自动配置时，只需要获取一个IPv6前缀就可以与接口标识形成IPv6地址。但是使用这种方式最大的缺点是任何人都可以通过二层MAC地址推算出三层IPv6地址。</p><h3 id="IPv6地址分类"><a href="#IPv6地址分类" class="headerlink" title="IPv6地址分类"></a>IPv6地址分类</h3><p>IPv6没有广播的概念，所以没有ARP包，也没有广播地址。IPv6地址分为单播、组播和任意播。</p><h4 id="单播"><a href="#单播" class="headerlink" title="单播"></a>单播</h4><p>单播地址用于一对一的连接，主要有以下几种类型</p><h5 id="可聚合全球单播地址（Aggregate-Global-Unicast-Address）"><a href="#可聚合全球单播地址（Aggregate-Global-Unicast-Address）" class="headerlink" title="可聚合全球单播地址（Aggregate Global Unicast Address）"></a>可聚合全球单播地址（Aggregate Global Unicast Address）</h5><p>可聚合全球单播地址类似于IPv4的公网地址，可在全球路由。目前前三位为001的IPv6地址被用作可聚合全球单播地址，即2000:&#x2F;3，占了12.5%的IPv6地址空间</p><p><strong>IPv6全球可路由地址的分配</strong></p><p>由于IPv6采用分级编址，IPv6全球可路由地址前缀由地址分配机构逐级向下分配：</p><table><thead><tr><th>前缀长度</th><th>适用场景</th></tr></thead><tbody><tr><td>32</td><td>RIR&#x2F;NIR（区域&#x2F;国家互联网注册机构）分配给有 ASN 的运营商、互联网公司、大型企业。是地址最小分配单元（再小就不给了）。</td></tr><tr><td>40</td><td>运营商向有多个（256个以内）站点和数据中心的大型企业分配的前缀</td></tr><tr><td>44</td><td>运营商向有多个（16个以内）站点和数据中心的中型企业分配的前缀</td></tr><tr><td>48</td><td>运营商向中小客户分配的常见前缀长度。或大中企业内一个站点的前缀</td></tr><tr><td>56</td><td>宽带运营商给家庭用户和小微企业分配的最小前缀长度（最大子网大小）</td></tr><tr><td>64</td><td>末端设备子网，&#x2F;64 是很多协议硬性要求的（IPv6 无广播风暴风险）</td></tr><tr><td>127</td><td>路由器点对点链路，此处不是为了节约地址而是防止一种资源耗尽型攻击</td></tr></tbody></table><h5 id="链路本地地址（Link-Local-Address）"><a href="#链路本地地址（Link-Local-Address）" class="headerlink" title="链路本地地址（Link-Local Address）"></a>链路本地地址（Link-Local Address）</h5><p>链路本地地址是一个<strong>只在本链路有效</strong>的IPv6地址。在一个节点启用IPv6后，每个接口都会生成以一个链路本地地址。链路本地地址前10bit固定，为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fe80::/10</span><br></pre></td></tr></table></figure><p>其后64位通常根据EUI-64格式来构造，但也有的终端是根据一定算法生成（出于安全原因），如：windows。</p><p>链路本地地址唯一标识一个节点，在本地链路看到下一跳都是对端的Link Local地址，在网络重新编址过程中，节点和路由器的Link Local地址不会发生变化，可以很容易地做一个修改，不用担心中断。</p><h5 id="唯一本地地址-（Unique-Local-Address）"><a href="#唯一本地地址-（Unique-Local-Address）" class="headerlink" title="唯一本地地址 （Unique Local Address）"></a>唯一本地地址 （Unique Local Address）</h5><p>唯一本地地址类似于IPv4私网地址，今能在站点本地使用。由于站点本地地址被废除，唯一本地地址用来代替站点本地地址。</p><p>固定前缀为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FC00::/7</span><br></pre></td></tr></table></figure><p><img src="/2022/04/17/ipv6/ulc.png" alt="IPV6"></p><p>其中，</p><p>L为标志位，值为1表示该地址为在本地网络范围内使用的地址；为0被保留，相当于只有FD00::&#x2F;8被使用</p><p>Global ID为全球唯一前缀；随机产生</p><p>Subnet ID为子网ID；用于划分子网</p><p>Interface ID；接口标识</p><p>唯一本地地址拥有全球唯一前缀，可以在私有网络之间通信。</p><h5 id="站点本地地址-（Site-Local-Address）已弃用"><a href="#站点本地地址-（Site-Local-Address）已弃用" class="headerlink" title="*站点本地地址 （Site-Local Address）已弃用"></a>*站点本地地址 （Site-Local Address）已弃用</h5><p>IPv6的保留地址，类似于IPv4的私网地址，<strong>只能在站点本地使用，无法在公网路由</strong>。站点本地地址占整个地址空间0.1%。</p><p>站点本地地址前10bit固定，为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FEC0::/10</span><br></pre></td></tr></table></figure><p>后54为左右子网标识，最后64为用于接口标识。</p><h5 id="未指定地址-（Unspecified-Address）"><a href="#未指定地址-（Unspecified-Address）" class="headerlink" title="未指定地址 （Unspecified Address）"></a>未指定地址 （Unspecified Address）</h5><p>未指定地址表示地址未被指定，或者表示默认路由（所有路由），形式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0:0:0:0:0:0:0:0 或 ::</span><br></pre></td></tr></table></figure><h5 id="环回地址-（Loopback-Address）"><a href="#环回地址-（Loopback-Address）" class="headerlink" title="环回地址 （Loopback Address）"></a>环回地址 （Loopback Address）</h5><p>换回地址表示节点自己，在本节点有效，和IPv4类似，形式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0:0:0:0:0:0:0:1 或::1</span><br></pre></td></tr></table></figure><h5 id="IPv4映射的IPv6地址-（IPv4-Mapped-IPv6-Address）"><a href="#IPv4映射的IPv6地址-（IPv4-Mapped-IPv6-Address）" class="headerlink" title="IPv4映射的IPv6地址 （IPv4-Mapped IPv6 Address）"></a>IPv4映射的IPv6地址 （IPv4-Mapped IPv6 Address）</h5><p>IPv4映射的IPv6地址是包含IPv4的IPv6地址，用于双栈的本地范围</p><p>其中高80bit为0，后跟16bit的1，在跟IPv4地址，如：</p><p>IPv4地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100.100.100.100</span><br></pre></td></tr></table></figure><p>的IPv4映射的IPv6地址为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::ffff:6464:6464</span><br></pre></td></tr></table></figure><h5 id="IPv4兼容地址-（IPv4-Compatible-IPv6-Address）-已弃用"><a href="#IPv4兼容地址-（IPv4-Compatible-IPv6-Address）-已弃用" class="headerlink" title="*IPv4兼容地址 （IPv4-Compatible IPv6 Address） 已弃用"></a>*IPv4兼容地址 （IPv4-Compatible IPv6 Address） 已弃用</h5><p> IPv4兼容的IPv6地址是包含IPv4的IPv6地址，用于在IPv4网络上建立自动隧道，传输IPv6包</p><p>其中高96比特设置为0，后面设置为32bit的IPv4地址，如：</p><p>IPv4地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100.100.100.100</span><br></pre></td></tr></table></figure><p>的IPv4兼容的IPv6地址为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::6464:6464</span><br></pre></td></tr></table></figure><p>这种机制不太完善，后被弃用</p><h4 id="组播"><a href="#组播" class="headerlink" title="组播"></a>组播</h4><p>组播用于一对多的通信、</p><p>组播前缀固定FF00::&#x2F;8，占用约0.38%的IPv6地址空间</p><p><img src="/2022/04/17/ipv6/multi.png" alt="IPV6 MULTI"></p><p>其中，</p><p>FF为前8位固定值</p><p>Flag标志位0000永久保留</p><p>Scope传播范围</p><p>Scope定义了组播地址的范围，取值与范围如下：</p><table><thead><tr><th>十六进制</th><th>范围</th></tr></thead><tbody><tr><td>1</td><td>本地接口</td></tr><tr><td>2</td><td>本地链路</td></tr><tr><td>3</td><td>本地子网</td></tr><tr><td>4</td><td>本地管理</td></tr><tr><td>5</td><td>本地站点</td></tr><tr><td>8</td><td>组织机构</td></tr><tr><td>E</td><td>全球</td></tr></tbody></table><p>RFC2373建议将后112的前80为置0，后32位为组播的组ID</p><h5 id="被请求节点组播地址-（Solicited-Node-Multicast-Address）"><a href="#被请求节点组播地址-（Solicited-Node-Multicast-Address）" class="headerlink" title="被请求节点组播地址 （Solicited-Node Multicast Address）"></a>被请求节点组播地址 （Solicited-Node Multicast Address）</h5><p>被请求节点组播地址根据每一个单播和任意播地址生成一个对应的组播地址，并加入该组播组。被请求节点组播地址只在本地有效。被请求节点组播地址用于邻居发现和DAD地址重复检测。</p><p>被请求节点组播地址固定前缀为FF02::1:FF00:0000&#x2F;104，将IPv6地址的后24位填充到被请求节点组播地址的接口标识就组成了改IPv6地址的被请求节点组播地址。如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2001::ABCD:ABCD/64</span><br></pre></td></tr></table></figure><p>对应的被请求节点组播地址为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FF02::1:FFCD:ABCD/104</span><br></pre></td></tr></table></figure><p>如图，在路由器的一个接口上开启IPv6功能，然后查看该接口的ipv6的状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int e0/0</span><br><span class="line"> ipv6 enable</span><br><span class="line">end</span><br><span class="line">show ipv6 int e0/0</span><br></pre></td></tr></table></figure><p>显示结果如下：</p><p><img src="/2022/04/17/ipv6/addr.png" alt="IPV6 ADDR"></p><p>其中可以看到IPv6使能后，接口生成了链路本地地址，为FE80::A8BB:CCFF:FE00:200，并为它生成了被请求节点组播地址FF02::1:FF00:200</p><p>由于被请求节点组播地址是可以根据IPv6地址容易计算出来的，当需要解析链路上IPv6的二层地址时，可以通过NS报文发送至改IPv6的被请求节点组播地址，实现了类似IPv4中的ARP解析功能。</p><h4 id="任意播"><a href="#任意播" class="headerlink" title="任意播"></a>任意播</h4><p>任意播本质是单播。任意播标识一组设备，需在网络设备如路由器上定义一个单播IPv6地址为任意播地址，当路由器收到目的地址为任意播地址时，会将其转发到最近的任意播地址。这种机制在网络层面上起到了类似于CDN的作用，就近分配任务。</p><p>IPv6没有为任意播单独定义地址空间，任意播和单播使用相同地址空间，任意播不可以作为源IPv6地址。</p><h4 id="IPv6报文格式"><a href="#IPv6报文格式" class="headerlink" title="IPv6报文格式"></a>IPv6报文格式</h4><p>IPv6报文由IPv6基本报头、IPv6扩展报头和上层协议数据三部分组成</p><h5 id="IPv6基本报头"><a href="#IPv6基本报头" class="headerlink" title="IPv6基本报头"></a>IPv6基本报头</h5><p>IPv6报头格式如下</p><p><img src="/2022/04/17/ipv6/header.png" alt="IPV6 HEADER"></p><p>其中</p><p>Version，为版本号，固定为6</p><p>Traffic Class，为流类别，与IPv4中TOS类似，定义流的类别</p><p>Flow Label，为流标签，新增字段，区分实时流量，网络设备可根据这个字段更高效的转发</p><p>Payload Length，为有效载荷长度，16bit，表示出基本头以外的载荷（拓展头和上层数据）长度，超过65535会置0</p><p>Next Header，为下一个报头，即紧跟在基本报头后的协议类型（可以是拓展报头也可以是上层协议）</p><p>Hop Limit，为跳数限制，类似于IPv4中的TTL，定义了IPv6数据包可以经过的最大跳数</p><p>Source Address，为源IPv6地址</p><p>Destination Address，为目的IPv6地址</p><h5 id="IPv6拓展报头"><a href="#IPv6拓展报头" class="headerlink" title="IPv6拓展报头"></a>IPv6拓展报头</h5><p>IPv4中，IPv4报头包含可选字段Options，这些选项会增加IPv4报头长度，校验和也会改变，在实际中很少使用。</p><p>IPv6不使用Options字段，改用拓展报头。IPv6拓展报头位于IPv6基本报头与上层数据之间，根据需要可任意添加0个或多个拓展报头。下一级拓展报头通过上一级报头的Next Header字段指明协议类型。拓展报头格式如下：</p><p><img src="/2022/04/17/ipv6/ext_header.png" alt="IPV6 EXTHEADER"></p><p>RFC2460中定义了6钟IPv6拓展头</p><table><thead><tr><th>IPv6拓展头</th><th>Next Header</th><th>作用</th></tr></thead><tbody><tr><td>逐跳选项</td><td>0</td><td>巨型载荷；设备提示；RSVP</td></tr><tr><td>目的选项</td><td>60</td><td>携带目的节点才会处理的信息</td></tr><tr><td>路由</td><td>43</td><td>携带IPv6路由信息，强制指定数据包经过特点设备</td></tr><tr><td>分段</td><td>44</td><td>IPv6也受MTU限制，通过分段拓展报头进行分段</td></tr><tr><td>认证</td><td>51</td><td>由IPsec使用，提供认证、完整性和重放等保护</td></tr><tr><td>封装安全净载</td><td>50</td><td>由IPsec使用，类似于AH</td></tr></tbody></table><p>IPv6大包ping分段拓展头抓包结果如下：</p><p><img src="/2022/04/17/ipv6/frag.png" alt="IPV6 FRAG"></p><p>可以看到，IPv6基本头中的Next Header为分段拓展头协议号44，IPv6拓展报头中的Next Header指向ICMPv6协议号58</p><p>当超过一种扩展报头被用在同一个IPv6报文里时，不是所有的拓展报头都需要被处理，但报头必须按照下列顺序出现：</p><ul><li>IPv6基本报头</li><li>逐跳选项扩展报头</li><li>目的选项扩展报头</li><li>路由扩展报头</li><li>分段扩展报头</li><li>认证扩展报头</li><li>封装安全有效载荷扩展报头</li><li>目的选项扩展报头</li><li>上层协议数据报文</li></ul><p>目的选项拓展报头可能出现1或2次，其它拓展报头只能出现一次。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;IPv6简介&quot;&gt;&lt;a href=&quot;#IPv6简介&quot; class=&quot;headerlink&quot; title=&quot;IPv6简介&quot;&gt;&lt;/a&gt;IPv6简介&lt;/h2&gt;&lt;h3 id=&quot;什么是IPv6&quot;&gt;&lt;a href=&quot;#什么是IPv6&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="网络基础" scheme="https://arclogicr.github.io/categories/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="network" scheme="https://arclogicr.github.io/tags/network/"/>
    
    <category term="tcp/ip" scheme="https://arclogicr.github.io/tags/tcp-ip/"/>
    
  </entry>
  
  <entry>
    <title>BGP学习笔记</title>
    <link href="https://arclogicr.github.io/2022/04/02/bgp-notes/"/>
    <id>https://arclogicr.github.io/2022/04/02/bgp-notes/</id>
    <published>2022-04-02T11:18:05.000Z</published>
    <updated>2023-01-17T08:34:25.717Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>BGP全称边界网关协议（<strong>Boarder Gateway Protocol</strong>）,是运行在自治系统（AS）之间传递路由信息的协议</p><p>AS定义（rfc1930）</p><p>The classic definition of an Autonomous System is a set of routers under a single technical administration, using an interior gateway<br>protocol and common metrics to route packets within the AS, and using an exterior gateway protocol to route packets to other ASes.</p><p>AS的经典定义是一组被单一技术管理的路由器，使用IGP和统一的metric在AS内路由分组，并使用EGP与其它AS路由分组。</p><h3 id="基本特点"><a href="#基本特点" class="headerlink" title="基本特点"></a>基本特点</h3><ul><li><p>路径矢量路由协议，基于TCP 179端口</p></li><li><p>首次建立连接做完整路由信息更新，以后就只做增量更新、触发更新</p></li><li><p>有丰富的属性可以灵活选路</p></li><li><p>被设计用于特大网络，例如Internet</p></li></ul><h3 id="三张表"><a href="#三张表" class="headerlink" title="三张表"></a>三张表</h3><h4 id="邻居表"><a href="#邻居表" class="headerlink" title="邻居表"></a>邻居表</h4><p>用于记录BGP对等体的邻居信息，包括状态信息，AS号等等，邻居不需要直连</p><h4 id="BGP表"><a href="#BGP表" class="headerlink" title="BGP表"></a>BGP表</h4><p>用于记录学习到的路由详细信息，包括BGP的路由属性，最优路由等</p><h4 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h4><p>BGP提交最优路由到路由表</p><h3 id="BGP报文"><a href="#BGP报文" class="headerlink" title="BGP报文"></a>BGP报文</h3><h4 id="OPEN"><a href="#OPEN" class="headerlink" title="OPEN"></a>OPEN</h4><p>用于建立一个BGP连接，包括holdtime，RID，AS等</p><p><img src="/2022/04/02/bgp-notes/open.jpg" alt="BGP OPEN"></p><h4 id="KEEPALIVE"><a href="#KEEPALIVE" class="headerlink" title="KEEPALIVE"></a>KEEPALIVE</h4><p>用于维护邻居，默认60s一次，holdtime180s</p><p><img src="/2022/04/02/bgp-notes/keepalive.jpg" alt="BGP KEEPALIVE"></p><h4 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h4><p>用于更新路径信息，一次可以通告一条路由和它的多个属性；也可以一次通告多个路由但它们的所有属性必须相同；一次可撤销多个路由</p><p><img src="/2022/04/02/bgp-notes/update.jpg" alt="BGP UPDATE"></p><h4 id="NOTIFICATION"><a href="#NOTIFICATION" class="headerlink" title="NOTIFICATION"></a>NOTIFICATION</h4><p>用于传递错误信息</p><p><img src="/2022/04/02/bgp-notes/notification.jpg" alt="BGP NOTIFICATION"></p><h4 id="REFRESH"><a href="#REFRESH" class="headerlink" title="REFRESH"></a>REFRESH</h4><p>路由刷新请求</p><p><img src="/2022/04/02/bgp-notes/refresh.jpg" alt="BGP REFRESH"></p><h3 id="BGP邻居"><a href="#BGP邻居" class="headerlink" title="BGP邻居"></a>BGP邻居</h3><h4 id="BGP邻居关系状态机"><a href="#BGP邻居关系状态机" class="headerlink" title="BGP邻居关系状态机"></a>BGP邻居关系状态机</h4><p>初始阶段，双方都是 idle 状态，等待连接重试时间到期后，双方进入 active 状态，并且双方各自回退一个 随机 delay 时间，delay 小的路由器，delay到期后，将主动发起 TCP 连接，delay 大的路由器在收到 TCP 连接请求后，将回到 idle 状态后进入到 connect 状态。若TCP连接失败，则进入active状态重传，建立成功进入opensent，不成功回退到Connet状态。TCP 连接建立完后，双方进入 OpenSent 状态，在这状态 中，双发互相发送 open 消息，并且侦听来自邻居的 open 消息，如果接收到的 open 消息没有差错，则发送 keepalive 消息并设置 keepalive 定时器，协商保持时间，根据对方的 AS 号，确定连接是内部的还是外部的，并 且迁移到OpenConfirm 状态，在 OpenConfirm 状态下，一旦收到 keepalive 消息，则进入到 establish 状态， establish 状态后，即双方已经建立 BGP 邻居，随即双方交换 update包。</p><p><img src="/2022/04/02/bgp-notes/state.jpg" alt="BGP STATE"> </p><p>其中，</p><ul><li><p>默认路由无法主动发起TCP连接，但可以回应主动发起TCP连接请求的一方必须用对方neighbor所指定的IP地址作为源发出TCP连接请求</p></li><li><p>建邻居的两端，先协商 Hold 时间，Hold 时间保持一致，Hold 时间为两端的最小值。</p></li><li><p>keepalive 时间 &gt; 三分之一的 Hold 时间，取三分之一的 Hold 时间作为 keepalive 时间。</p></li><li><p>keepalive 时间 &lt;&#x3D; 三分之一的 Hold 时间，keepalive 时间不变。</p></li><li><p>BGP只有当连接处于建立状态时，才能交换更新、存活和通知消息</p></li><li><p>EBGP建立邻居默认TTL是1</p><ul><li><p>关闭直连检测TTL还是1</p></li><li><p>改eBGP多跳设置，TTL可设置其他值</p></li></ul></li></ul><p>如果一直停在idle状态，则可能：</p><ul><li><p>没有去往邻居的路由</p></li><li><p>neighbor命令指错了邻居的地址</p></li></ul><p>如果一直停在active状态，则可能：</p><ul><li><p>邻居没有过来的路由</p></li><li><p>邻居没有指neighbor命令</p></li><li><p>邻居neighbor中指的地址错误</p></li><li><p>两端的AS号不匹配</p></li></ul><h4 id="BGP邻居类型"><a href="#BGP邻居类型" class="headerlink" title="BGP邻居类型"></a>BGP邻居类型</h4><h5 id="eBGP"><a href="#eBGP" class="headerlink" title="eBGP"></a>eBGP</h5><ul><li><p>eBGP是不同AS之间建立的BGP邻居</p></li><li><p>通常要求直连，建议使用直连接口建立邻居</p></li><li><p>AD默认20（Cisco）</p></li></ul><h5 id="iBGP"><a href="#iBGP" class="headerlink" title="iBGP"></a>iBGP</h5><ul><li><p>iBGP是AS内建立的BGP邻居</p></li><li><p>无需直连，只需传输层可达</p></li><li><p>AD默认200（Cisco）</p></li></ul><h4 id="BGP更新源"><a href="#BGP更新源" class="headerlink" title="BGP更新源"></a>BGP更新源</h4><p>BGP默认开启直连监测和源监测</p><ul><li><p>直连监测：需要根据neighbor中的指定的具体IP来进行判断，是不是直连IP，如果不是，连TCP三次握手都不成功，更不可能建立完整的BGP邻接了</p></li><li><p>源检测：监测过来访问自己179端口的IP是否是nei后面的ip</p></li></ul><p>路由器用来和邻居建立邻居关系的IP地址叫BGP更新源地址。BGP建立邻居过程中，由于默认开启源检测，来自邻居的邻居建立源IP必须是本地neibor指定的邻居IP，否则无法建立邻居关系。</p><p>“show ip bgp summary中的Neighbor” &#x2F; “show ip bgp中的Next Hop ”都是指Update-Source</p><h4 id="查看BGP邻居"><a href="#查看BGP邻居" class="headerlink" title="查看BGP邻居"></a>查看BGP邻居</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show ip bgp summary</span><br></pre></td></tr></table></figure><p>显示结果</p><p><img src="/2022/04/02/bgp-notes/nei.png" alt="BGP NEIGHBOR"></p><p>其中，</p><p>Neighbor为邻居更新源IP</p><p>AS为对方AS号</p><p>MsgRcvd&#x2F;Sent为BGP消息接受&#x2F;发送数量</p><p>State&#x2F;PfxRcd为BGP邻居建立状态，当显示为数字时，表示状态为Established并且收到该数量的路由前缀</p><h4 id="清除BGP会话"><a href="#清除BGP会话" class="headerlink" title="清除BGP会话"></a>清除BGP会话</h4><p>bgp不会周期更新，是增量更新</p><p>以下命令为BGP会话硬件清除，<strong>重新建立邻居；慎用！！！</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clear ip bgp *</span><br><span class="line">clear ip bgp 3.3.3.3</span><br></pre></td></tr></table></figure><p>以下命令为出入向软件清除，不会改变状态机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clear ip bgp * soft  [out/in/-]</span><br></pre></td></tr></table></figure><p>出向软清，发送UPDATE，不发送刷新消息</p><p>入向软清，不发送UPDATE，发送刷新消息，对方回复UPDATE</p><p>双向软清，发送UPDATE，发送刷新消息，对方恢复UPDATE</p><p>可以使用以下命令缓存被拒绝的路由</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bgp 100</span><br><span class="line">nei 3.3.3.3 soft-reconfiguation inbound</span><br></pre></td></tr></table></figure><h4 id="BGP防环机制"><a href="#BGP防环机制" class="headerlink" title="BGP防环机制"></a>BGP防环机制</h4><ul><li><p>从iBGP邻居收到的路由不再传给其它iBGP邻居（iBGP水平分割）</p></li><li><p>拒绝从EBGP邻居收到的AS-PATH属性含有自身AS号的路由</p></li></ul><p>iBGP水平分割可以通过Fullmesh、RR或联邦来解决</p><h5 id="neighbor-a-a-a-a-remote-as-AS含义"><a href="#neighbor-a-a-a-a-remote-as-AS含义" class="headerlink" title="neighbor a.a.a.a remote-as AS含义"></a>neighbor a.a.a.a remote-as AS含义</h5><p>指定对方属于哪个AS，所指a.a.a.a地址，必须在IGP可达（双方不能都是默认路由）</p><p>1、我将会向nei后面地址的179端口发起TCP连接，建立BGP邻居</p><p>2、只允许nei后面地址作为源来访问我的179端口（TCP请求源检测 ）</p><h4 id="对等体组"><a href="#对等体组" class="headerlink" title="对等体组"></a>对等体组</h4><p>有时可能对多个邻居进行相同的BGP配置，可以定义对等体组将其统一配置（neighbor XX peer-group）</p><h3 id="BGP路由操作"><a href="#BGP路由操作" class="headerlink" title="BGP路由操作"></a>BGP路由操作</h3><h4 id="BGP路由发布"><a href="#BGP路由发布" class="headerlink" title="BGP路由发布"></a>BGP路由发布</h4><h5 id="network宣告特点"><a href="#network宣告特点" class="headerlink" title="network宣告特点"></a>network宣告特点</h5><ul><li><p>够通告路由表中的所有非BGP路由</p></li><li><p>默认情况下必须精确宣告网络和掩码</p></li><li><p>只起到宣告作用，不建邻居</p></li><li><p>可宣告IGP学到的路由，并携带Metric和Next-hop</p></li></ul><h5 id="no-autosummary"><a href="#no-autosummary" class="headerlink" title="no-autosummary"></a>no-autosummary</h5><p>network含义–network后面的网段和掩码必须和路由表中条目精确匹配才能宣告进BGP表</p><p>redistribute–重分布明细进BGP</p><h5 id="autosummary"><a href="#autosummary" class="headerlink" title="autosummary"></a>autosummary</h5><p>network含义–network后面的网段和掩码必须和路由表中明细路由的主类路由匹配才能宣告进BGP表</p><p>redistribute–重分布主类路由进BGP</p><p>ibgp重分布需要在bgp进程下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bgp redistribute-internal</span><br></pre></td></tr></table></figure><h4 id="BGP路由传递规则"><a href="#BGP路由传递规则" class="headerlink" title="BGP路由传递规则"></a>BGP路由传递规则</h4><ul><li><p>iBGP之间传递路由，下一跳不变</p></li><li><p>联邦iBGP&#x2F;eBGP传递路由，下一跳不变</p></li><li><p>eBGP之间传递路由，下一跳改变</p></li><li><p>iBGP水平分割：从iBGP邻居收到的路由不会传给iBGP邻居</p></li></ul><h4 id="BGP同步"><a href="#BGP同步" class="headerlink" title="BGP同步"></a>BGP同步</h4><p>BGP同步是针对iBGP水平分割的一个早起解决方案。</p><p>开启同步后，AS内的一个路由器从iBGP邻居处学到一条路由，不用也不传，除非是从IGP学到同样一条路由。（网络号和掩码都必须完全一样）</p><p>BGP同步配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">router bgp 64512</span><br><span class="line">synchronization</span><br></pre></td></tr></table></figure><h4 id="BGP路由优化"><a href="#BGP路由优化" class="headerlink" title="BGP路由优化"></a>BGP路由优化</h4><p>BGP收到路由后会优化路由，被优化的路由才能被使用，被传递。一般根据以下条件判断该路由是否可以被优化：</p><ul><li><p>是否满足同步条件</p></li><li><p>下一跳是否可达（本地优化）</p></li><li><p>入向策略允许的路由、</p></li><li><p>路径选择（路径优化），若有多条路径去往相同的网段，选择一条最优的路由</p></li></ul><p>BGP表中的路由优化后的2个动作：</p><ul><li>向路由表提交这条最优的BGP路由</li><li>向BGP的peer邻居发送包含这条BGP最优路由的更新</li></ul><h4 id="第三方下一跳"><a href="#第三方下一跳" class="headerlink" title="第三方下一跳"></a>第三方下一跳</h4><p>收到BGP路由的下一跳（递归完的下一跳）与建邻居nei地址在同一网段，保持下一跳不变；不在同一网段，改变下一跳。（RIP与EIGRP也存在第三方下一跳，EIGRP默认关闭）</p><h4 id="BGP路由重分发"><a href="#BGP路由重分发" class="headerlink" title="BGP路由重分发"></a>BGP路由重分发</h4><p>将OSPF重分发进BGP时，默认只将internal充分发。可使用以下令充分发其它OSPF路由</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">router bgp 64512</span><br><span class="line">     redistribute ospf 1 match [internal | external | nssa external] </span><br></pre></td></tr></table></figure><p>将BGP重分发进IGP默认只重分发eBGP，可使用以下命令充分发iBGP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">router bgp 64512</span><br><span class="line">     bgp redistribute-internal</span><br></pre></td></tr></table></figure><h4 id="BGP注入默认路由的3种方法"><a href="#BGP注入默认路由的3种方法" class="headerlink" title="BGP注入默认路由的3种方法"></a>BGP注入默认路由的3种方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip route 0.0.0.0 0.0.0.0 null0</span><br><span class="line">router bgp 64512</span><br><span class="line">   network 0.0.0.0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ip route  0.0.0.0 0.0.0.0 null 0                       </span><br><span class="line">router bgp 64512</span><br><span class="line">   redistribute static</span><br><span class="line">   default-information originate </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">router bgp 64512                                      </span><br><span class="line">    neighbor x.x.x.x default-originate </span><br><span class="line"></span><br><span class="line">router bgp 64512                                     </span><br><span class="line">    neighbor x.x.x.x default-originate route-map xx  </span><br></pre></td></tr></table></figure><h4 id="BGP路由聚合"><a href="#BGP路由聚合" class="headerlink" title="BGP路由聚合"></a>BGP路由聚合</h4><h5 id="network方式汇总"><a href="#network方式汇总" class="headerlink" title="network方式汇总"></a>network方式汇总</h5><p>先配置一条指向null0的汇总静态路由，然后在bgp宣告此静态路由</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip route 192.168.0.0 255.255.252.0 Null0</span><br><span class="line">router bgp 64512</span><br><span class="line">  network 192.168.0.0 mask 255.255.252.0</span><br></pre></td></tr></table></figure><h5 id="Aggregate聚合"><a href="#Aggregate聚合" class="headerlink" title="Aggregate聚合"></a>Aggregate聚合</h5><p>先使用network宣告明细路由，然后使用aggregate进行聚合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">router bgp 123</span><br><span class="line">  network 192.168.0.0 mask 255.255.255.128</span><br><span class="line">  network 192.168.0.128 mask 255.255.255.128</span><br><span class="line">  aggregate-address 192.168.0.0 255.255.255.0 summary-only</span><br></pre></td></tr></table></figure><h5 id="Aggregate聚合常见参数"><a href="#Aggregate聚合常见参数" class="headerlink" title="Aggregate聚合常见参数"></a>Aggregate聚合常见参数</h5><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>advertise-map</td><td>只对该map匹配的路由进行聚合</td></tr><tr><td>as-set</td><td>让聚合路由继承明细路由属性</td></tr><tr><td>attribute-map</td><td>清除&#x2F;添加需要的属性</td></tr><tr><td>summary-only</td><td>抑制明细路由，只发布聚合路由</td></tr><tr><td>suppress-map</td><td>抑制该map匹配的路由</td></tr></tbody></table><h3 id="BGP路由属性"><a href="#BGP路由属性" class="headerlink" title="BGP路由属性"></a>BGP路由属性</h3><h4 id="BGP路由属性分类"><a href="#BGP路由属性分类" class="headerlink" title="BGP路由属性分类"></a>BGP路由属性分类</h4><ul><li><p>公认强制的–所有的BGP的updata消息都要包含该属性</p></li><li><p>公认自由决定的–该属性是可选可不选的，但是所有的BGP进程都能识别</p></li><li><p>可选传递的–即使BGP进程不能识别该属性，也会继续传递下去</p></li><li><p>可选非传递的–如果BGP进程不能识别该属性，可以忽略这条updata,并且不传递下去</p></li></ul><p>1、公认强制属性</p><p>    –AS路径(AS-path)</p><p>    –下一跳（next-hop）</p><p>    –源头(origin)</p><p>2、公认自由决定的</p><p>    –本地优先级（local preferent）</p><p>3、可选传递的</p><p>    –团体属性（community）</p><p>4、可选非传递属性</p><p>    –MED</p><h4 id="BGP路由常见属性"><a href="#BGP路由常见属性" class="headerlink" title="BGP路由常见属性"></a>BGP路由常见属性</h4><h5 id="weight-路由权重"><a href="#weight-路由权重" class="headerlink" title="weight-路由权重"></a>weight-路由权重</h5><p>只能入向做,cisco私有，本地产生路由weight 32768，越大越优</p><h5 id="local-preference-本地优先级"><a href="#local-preference-本地优先级" class="headerlink" title="local preference-本地优先级"></a>local preference-本地优先级</h5><p>LP属性在同一AS内有效，发送给AS内其它路由器，告知离开AS的最佳路由。</p><ul><li><p>EBGP邻居传路由，不携带LP，默认100</p></li><li><p>IBGP邻居传递路由，携带LP</p></li></ul><p>修改LP的操作可以在IBGP邻居的入向或出向，或者EBGP邻居之间的入向执行</p><p>bgp default local-preference 101 针对自己始发的路由和EBGP传给我的路由有效</p><h5 id="AS-PATH-AS路径"><a href="#AS-PATH-AS路径" class="headerlink" title="AS-PATH-AS路径"></a>AS-PATH-AS路径</h5><p>AS-PATH表示一条路由经过的AS。</p><p>AS-PATH的优先级按个数算，经过越少的AS越优。</p><p>其中，</p><ul><li><p>联邦内as不计入总数，路由聚合后的as-set算一个AS；</p></li><li><p>在使用route-map添加AS时，添加后的AS在出向策略靠右显示，在入向策略靠左显示</p></li><li><p>可以增加多个自己的as号来加长as-path属性</p></li><li><p>bgp best-path ignore 可忽略这条选路原则</p></li></ul><h5 id="origin-起源类型"><a href="#origin-起源类型" class="headerlink" title="origin-起源类型"></a>origin-起源类型</h5><p>起源类型三种igp，egp，未知（?）</p><p>其中优先级如下</p><p>igp&gt;egp&gt;imcomplete（i&gt;e&gt;?）</p><h5 id="MED-多出口鉴别"><a href="#MED-多出口鉴别" class="headerlink" title="MED-多出口鉴别"></a>MED-多出口鉴别</h5><p>MED用于发送给其它AS，告知进入本AS的最佳路径。</p><ul><li><p>在两个AS之间存在多条路径时使用</p></li><li><p>用来影响ebgp邻居，告诉自己的ebgp邻居如何选最优路由</p></li><li><p>MED默认值0，越小越优</p></li></ul><p>MED传递特殊规则</p><ul><li><p>metric传递不能传出AS。例：始发路由器可以将metric传给任何邻居，可以是IBGP&#x2F;EBGP，但邻居收到后，不能传出邻居所在的AS。</p></li><li><p>默认相同AS传来的MED才会比较，如果比较不同AS传来的MED需要命令bgp always-compare-med</p></li></ul><h5 id="团体属性（标准）"><a href="#团体属性（标准）" class="headerlink" title="团体属性（标准）"></a>团体属性（标准）</h5><p>标准BGP团体属性作用于多条路由，让经过的路由器知道这些路由的传递范围。团体属性默认不被发送，可用以下命令向指定邻居发送团体属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">neighbor 192.168.23.2 send-community [-/standard/both]</span><br></pre></td></tr></table></figure><p>这里的团体属性是标准团体属性，而拓展团体属性本质是MPLS中的Route-Target（rt），这里暂不讨论</p><p>标准团体属性分公有团体属性和私有团体属性。公有团体属性是所有路由器都认识的属性，而私有团体属性需要预先在路由器上针对改属性做定义才可被路由器执行。</p><p><strong>公有团体属性</strong></p><p>公有团体属性的值表明了具有该属性的路由可被通告的范围</p><table><thead><tr><th>属性</th><th>路由传递范围</th></tr></thead><tbody><tr><td>internet</td><td>收到后传递给任何peer</td></tr><tr><td>no-advertise</td><td>收到后不传递给任何peer</td></tr><tr><td>local-as</td><td>只在AS内传递，只在联邦iBGP之间传递</td></tr><tr><td>no-export</td><td>只在AS内传递，可在联邦iBGP和eBGP之间传递</td></tr></tbody></table><p><strong>私有团体属性</strong></p><p>私有团体属性（32bits）有两种定义方式</p><ul><li><p>十进制数，如123</p></li><li><p>XX:XX形式</p></li></ul><p>路由器在收到私有团体属性后不做任何操作，除非有预先定义的策略。如，AWS DX-Gateway根据BGP私有团体属性（XX:XX形式）来进行云网络至IDC网络方向的选路，7224:7100，7224:7200，7224:7300分别表示携带该属性路由的优先级为低中高。</p><p><strong>标准团体属性配置</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">router bgp 64512</span><br><span class="line"> neighbor 192.168.12.2 route-map community_std out</span><br><span class="line">route-map community_std permit 10</span><br><span class="line"> set community local-AS #公有团体属性</span><br><span class="line"> set community 7224:7100 #私有团体属性</span><br></pre></td></tr></table></figure><h3 id="BGP选路原则"><a href="#BGP选路原则" class="headerlink" title="BGP选路原则"></a>BGP选路原则</h3><p>以下情况忽略路由</p><ul><li>不同步</li><li>下一跳不可达</li><li>ebgp学到路由AS包含自己</li><li>bgp enforce-first-as但收到不是第一个as</li><li>receive only</li></ul><p>11+2条选路原则，标准BGP选路11条，带*的两条是补充：</p><p>1、最高weight值优先（思科私有默认32768，本地有效）</p><p>2、最高LP优先</p><p>3、加入方式，local&gt;network&gt;REDISTRIBUTE&gt;aggreate；local 最优</p><p>4、最短AS</p><p>5、起源类型origin  IGP&lt;EGP&lt;IMCOMPLETE</p><p>6、最小MED</p><p>7、 EBGP&gt;IBGP</p><p>8 、优选去往下一跳 IGP metric小的</p><p>*9、负载（满足前8条和以下条件则负载）</p><ul><li> 配置maximum-path</li><li>多条等价路由的下一跳要不同</li><li><strong>EBGP如果穿越了不同AS，也不会负载！！</strong></li><li>如果穿越了联邦，穿越了不通联邦的两条路由不负载</li><li>除非在BGP中加一条bgp bestpath<br> as-path multipath-relax</li><li>负载仅仅是路由表，BGP表会继续向下比较知道选出一条best路径</li><li>隐藏命令bgp bestpath<br> as-path multipath-relax</li></ul><p>10、如果都是ebgp，优先选择先学到的</p><p>11、rid 小的优先，有RR的话，用originater地址代替rid比较</p><p>  *12、最小的RR中cluster长度</p><p>13、最小的建立邻居的neighbor地址</p><h3 id="路由反射器RR"><a href="#路由反射器RR" class="headerlink" title="路由反射器RR"></a>路由反射器RR</h3><p>路由反射器是一台BGP路由器，可以将它的iBGP邻居指定为自己的客户端。路由反射器是为了解决iBGP的水平分割问题。为了使得iBGP路由全通，如果采用full mesh的方法则需要建立非常多的邻居关系，而路由反射器打破iBGP水平分割的原则，解决iBGP的路由传递问题。</p><p>路由反射器和其客户的集合被称为集群（cluster）,每一个集群都有一个cluster-id，默认情况下路由反射器的router-id会被用做cluster-id，也可以手工指定。路由反射器所传递的每一条客户端路由都会带上这个cluster-id。</p><h4 id="RR路由传递规则"><a href="#RR路由传递规则" class="headerlink" title="RR路由传递规则"></a>RR路由传递规则</h4><p>从RR的一个客户端传递过来的一条路由：</p><ul><li>RR会传递给我的另外一个反射族的客户端</li><li>RR会传递给我的另外一个非客户端</li><li>RR会传递给我的另一个EBGP邻居</li></ul><p>从RR的一个非客户端传递过来的一条路由：</p><ul><li>RR会传递给我的另外一个反射族的客户端</li><li><strong>RR不会传递给我的另外一个非客户端</strong></li><li>RR会传递给我的另一个EBGP邻居</li></ul><p>从RR的一个EBGP传递过来的一条路由：</p><ul><li>RR会传递给我的另外一个反射族的客户端</li><li>RR会传递给我的另外一个非客户端</li><li>RR会传递给我的另一个EBGP邻居</li></ul><p><strong>总结：非非不能传，其它都能传</strong></p><h4 id="RR防环"><a href="#RR防环" class="headerlink" title="RR防环"></a>RR防环</h4><p>R4上的路由经过 R3 路由反射后，路由中就会带有Originator，即为 AS234 中始发此路由的 router-id，Cluster list：3.3.3.3，表明此路由已经经过路由反射器R3，就将路由反射器的 router-id 存放在Cluster list里 面。此时路由再传递至 R2 或 R3 上的时候，包含自己的<br>router-id，将拒绝接收这条路由，这样设计的目的在于防止路由反射器FULL-MESH 时产生的环路</p><p><img src="/2022/04/02/bgp-notes/rr.png" alt="BGP RR"></p><h4 id="RR配置"><a href="#RR配置" class="headerlink" title="RR配置"></a>RR配置</h4><p>定义本路由器为路由反射器，指定邻居1.1.1.1为客户端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">router bgp 64512</span><br><span class="line">  neighbor 1.1.1.1 route-reflector-client </span><br></pre></td></tr></table></figure><h3 id="BGP联邦"><a href="#BGP联邦" class="headerlink" title="BGP联邦"></a>BGP联邦</h3><p>BGP联邦是指将一个大的AS分成若干个小AS，小AS之间是EBGP关系。联邦也是为了解决iBGP水平分割问题。</p><h4 id="联邦的定义"><a href="#联邦的定义" class="headerlink" title="联邦的定义"></a>联邦的定义</h4><ul><li><p>联邦中的所有路由器需要使用子AS的AS号</p></li><li><p>联邦中所有路由器需要声明主AS的AS号</p></li><li><p>子AS边界路由器需要互指联邦peers</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">R1</span><br><span class="line">router bgp 64512</span><br><span class="line"> bgp confederation identifier 100</span><br><span class="line"> neighbor 192.168.12.2 remote-as 64512</span><br><span class="line"> neighbor 192.168.12.2 next-hop-self</span><br><span class="line"></span><br><span class="line">R2</span><br><span class="line">router bgp 64512</span><br><span class="line"> bgp confederation identifier 100</span><br><span class="line"> bgp confederation peers 64513 </span><br><span class="line"> neighbor 192.168.12.1 remote-as 64512</span><br><span class="line"> neighbor 192.168.23.3 remote-as 64513</span><br><span class="line"></span><br><span class="line">R3</span><br><span class="line">router bgp 64513</span><br><span class="line"> bgp confederation identifier 100</span><br><span class="line"> bgp confederation peers 64512 </span><br><span class="line"> neighbor 192.168.23.2 remote-as 64512</span><br></pre></td></tr></table></figure><p><img src="/2022/04/02/bgp-notes/confederation.png" alt="BGP CONFEDERATION"></p><h4 id="联邦的AS号"><a href="#联邦的AS号" class="headerlink" title="联邦的AS号"></a>联邦的AS号</h4><ul><li><p>联邦外路由器和联邦的边界路由器建立邻居关系时，neighbor大AS号。</p></li><li><p>联邦中的小AS号（64512）不算作AS-Path属性比较，只算作一个</p></li><li><p>在BGP表中，小AS号会用括号括住，并且不算做一个进行路径比较的AS号</p></li></ul><h3 id="路由惩罚（Dampening）"><a href="#路由惩罚（Dampening）" class="headerlink" title="路由惩罚（Dampening）"></a>路由惩罚（Dampening）</h3><p>由于BGP是运行再AS间的路由协议，通常没有办法直接管理对方AS的设备，为了防止因设备或者专线故障引起的路由频繁抖动，BGP可采用Dampening添加条件抑制抖动，予以抖动的邻居惩罚（主动抑制）。</p><h4 id="Dampening相关参数"><a href="#Dampening相关参数" class="headerlink" title="Dampening相关参数"></a>Dampening相关参数</h4><p>惩罚值penalty：路由每翻动一次，这个惩罚值就会增加。惩罚值1000，不可修改</p><p>半衰期half life：默认15min，一个半衰期惩罚值降为原来一半。路由的惩罚值每5秒钟减少一次。</p><p>惩罚状态damp state：路由出于惩罚状态时，改路由不会被在BGP表中被优化，也不会传播</p><p>抑制门限suppress limit：默认2000，若一条路由的惩罚值超过抑制门限，则状态由history改为damp</p><p>重用门限reuse limit：默认750，惩罚值降到重用门限后，该路由将不被抑制</p><p>最大抑制时间、最大抑制门限：默认值60min&#x2F;12000，如果路由在短时间内表现出极端的不稳定性，然后又稳定下来，那么累计的惩罚值可能会导致这条路由在过长的时间里一直处于惩罚状态。这就是设置最大抑制门限的基本目的。如果路由表现出连续的不稳定性，那么惩罚值就停留在它的上限上，使得路由保持在惩罚状态。最大抑制门限是用公式计算出来的。最大抑制时间为一条路由停留在惩罚状态的最长时间。默认为60分钟（半衰期的4倍）可以配置。</p><p>针对某条路由的Dampening配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ip prefix-list 1 permit 1.1.1.0/24</span><br><span class="line"></span><br><span class="line">route-map DAMP  </span><br><span class="line">  match ip address prefix-list 1</span><br><span class="line">  set dampening 15 750 2000 60</span><br><span class="line"></span><br><span class="line">router bgp 64512</span><br><span class="line">  bgp dampening route-map DAMP    </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;BGP全称边界网关协议（&lt;strong&gt;Boarder Gateway Protocol&lt;/strong&gt;）,是运行在自治系统（AS）之间传</summary>
      
    
    
    
    <category term="路由交换RS" scheme="https://arclogicr.github.io/categories/%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2RS/"/>
    
    
    <category term="network" scheme="https://arclogicr.github.io/tags/network/"/>
    
    <category term="routing" scheme="https://arclogicr.github.io/tags/routing/"/>
    
    <category term="bgp" scheme="https://arclogicr.github.io/tags/bgp/"/>
    
  </entry>
  
  <entry>
    <title>OSPF经典问题汇总</title>
    <link href="https://arclogicr.github.io/2022/03/28/OSPF-QA/"/>
    <id>https://arclogicr.github.io/2022/03/28/OSPF-QA/</id>
    <published>2022-03-28T08:13:52.000Z</published>
    <updated>2023-01-17T07:30:20.667Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OSPF采用分区域设计有什么好处？"><a href="#OSPF采用分区域设计有什么好处？" class="headerlink" title="OSPF采用分区域设计有什么好处？"></a>OSPF采用分区域设计有什么好处？</h2><ul><li>可以在ABR做路由汇总，减少其它区域路由表条目，减轻路由器压力</li><li>减少1，2类LSA泛洪</li><li>减少路由收敛的范围，一个区域的问题不会影响其它区域</li></ul><h2 id="影响OSPF邻接的原因有哪些？"><a href="#影响OSPF邻接的原因有哪些？" class="headerlink" title="影响OSPF邻接的原因有哪些？"></a>影响OSPF邻接的原因有哪些？</h2><p>1、ROUTER ID不能相同；<br>2、HELLO时间必须一致；<br>3、DEAD时间必须一致；<br>4、区域ID必须相同；<br>5、认证必须相同；<br>6、STUB标志位必须相同（hello包中域外路由重分布能力位）；<br>7、MTU不匹配无法形成邻接关系<br>8、OSPF版本号不同（目前版本为2）；<br>9、当OSPF网络类型是MA时，要求掩码一定一致（两个邻居）。因为会出现DR和LSA-2，无法描述网段</p><h2 id="如果OSPF双方路由器MTU不一致，会发生什么情况"><a href="#如果OSPF双方路由器MTU不一致，会发生什么情况" class="headerlink" title="如果OSPF双方路由器MTU不一致，会发生什么情况"></a>如果OSPF双方路由器MTU不一致，会发生什么情况</h2><p><strong>无法建立邻接关系</strong></p><p>假设<strong>R1 MTU &lt; R2 MTU</strong></p><p>首先，双方都可以进入exstart状态。然后双方开始单播发送第一个DBD，<br>此时<br>若R2的RID&gt;R1的RID</p><p>对于R1：收到R2第一个DBD发现MTU比自己大，无法接受；所以维持发送第一个DBD的状态，即维持exstart状态</p><p>对于R2: 正常收到R1的第一个DBD然后可以计算出自己是master，然后等待对方发送LSA摘要；但是发现R1只会发第一个DBD不发LSA摘要，（猜测：可能以为通讯有问题），于是维持发送第一个DBD，即维持exstart状态</p><p>若R2的RID&lt;RI的RID</p><p>对于R1：收到R2第一个DBD发现MTU比自己大，无法接受；所以维持发送第一个DBD的状态，即维持exstart状态</p><p>对于R2: 正常收到R1的第一个DBD然后可以计算出对方是master而自己是slave，然后会发送LSA摘要，即进入exchange状态，但对方没有回复LSA摘要，所以会支持卡在exchange这个状态</p><p>总结：<br>当双方mtu不一致时<br><strong>若DBD从的mtu小，则双方都卡在exstart</strong><br><strong>若DBD从的mtu大，则mtu大的进入exchange，mtu小的维持exstart</strong></p><p><strong>总之，mtu小的一定卡在exstart，mtu大的有可能进入exchange（取决于是否是DBD从角色）</strong></p><h2 id="OSPF何时用组播，何时用单播？"><a href="#OSPF何时用组播，何时用单播？" class="headerlink" title="OSPF何时用组播，何时用单播？"></a>OSPF何时用组播，何时用单播？</h2><ul><li>HELLO包，不手动指定邻居的话都是发送到组播224.0.0.5</li><li>DBD，只是两个路由器之间建邻居互传DB摘要，采用单播</li><li>LSR，请求LSA，直接向DR请求，单播</li><li>LSU<ul><li>回复LSR时是单播</li><li>触发更新时是组播<ul><li>DR-Other 采用组播224.0.0.6告知DR&#x2F;BDR，由DR发送224.0.0.5告知其它所有路由器</li><li>p2p类型网络都是发送到组播224.0.0.5</li></ul></li></ul></li><li>LSAck，组播224.0.05</li></ul><h2 id="OSPF邻居表发现2-way是否正常"><a href="#OSPF邻居表发现2-way是否正常" class="headerlink" title="OSPF邻居表发现2-way是否正常"></a>OSPF邻居表发现2-way是否正常</h2><p><strong>MA网络中正常</strong><br>在MA网络中，DR和BDR分别与DROther建立full邻接关系，DROther之间只是2-way关系</p><h2 id="如何判断一条LSA的新旧"><a href="#如何判断一条LSA的新旧" class="headerlink" title="如何判断一条LSA的新旧"></a>如何判断一条LSA的新旧</h2><p>当一台路由器收到相同的LSA的多个实例时，将通过以下算法决定将哪一条放入数据库：</p><p>1、比较LSA实例的序列号，大的优先<br>2、序列号相同，再比校验和，大的优先<br>3、校验和也相同，再比老化时间，如果有一条LSA拥有大小为最大生存时间（3600S）的老化时间，则最优<br>4、如果LSA的老化时间之间的差别多于15分钟，则老化时间小的优先<br>5、如果以上条件都比不出来，则认为这些LSA相同</p><h2 id="如果不相邻的两台OSPF路由器RID相同会发生什么"><a href="#如果不相邻的两台OSPF路由器RID相同会发生什么" class="headerlink" title="如果不相邻的两台OSPF路由器RID相同会发生什么"></a>如果不相邻的两台OSPF路由器RID相同会发生什么</h2><p><strong>若这些路由器在同一区域</strong><br><img src="/2022/03/28/OSPF-QA/RID1.png" alt="OSPF RID1"><br>R1-R2-R3连接，且都属于同一区域<br>假设R2-R3先正常建立邻居后，R1配置R3的RID接入。此时R1与R2可以建立full邻接关系，R1会收到R2发来的较新的1类LSA，这里的1类LSA应该有两条<br>第一条ADV Router是R3<br>第二条ADV Router是R1</p><p>这里R1会接受R2独有的路由（即ADV Router为R2且R3 没通告的路由，如lo 0的路由），收到R3路由发现和自己RID一样，会报RID dup的错，同时也会发送自己的最新的LSA。R3同理。<br><strong>最后结果就是R1,R3可以学到R2的loopback 路由但R1,R3互相的路由不稳定会翻动</strong></p><p><strong>若这些路由器在不通区域</strong><br><img src="/2022/03/28/OSPF-QA/RID2.png" alt="OSPF RID2"><br>R1-R2-R3连接，R1-R2属于区域1，R2-R3属于区域0<br>假设R2-R3先正常建立邻居后，R1配置R3的RID接入。此时R1与R2可以建立full邻接关系。这里R2是ABR，R2会吧R3通告的1类LSA转为3类，在发给区域1的时候ADV Router字段会变为自己（即R2的RID），但不会重新处理5类LSA。所以对区域1的内部路由器R1来说，收到的R3路由会当做普通的三类LSA处理，并不知道这些OIA路由来自哪里；同理，R3也能学到R1的域内路由。<br><strong>最后结果就是R1,R3可以互相学到域内路由</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;OSPF采用分区域设计有什么好处？&quot;&gt;&lt;a href=&quot;#OSPF采用分区域设计有什么好处？&quot; class=&quot;headerlink&quot; title=&quot;OSPF采用分区域设计有什么好处？&quot;&gt;&lt;/a&gt;OSPF采用分区域设计有什么好处？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;可以在A</summary>
      
    
    
    
    <category term="路由交换RS" scheme="https://arclogicr.github.io/categories/%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2RS/"/>
    
    
    <category term="network" scheme="https://arclogicr.github.io/tags/network/"/>
    
    <category term="routing" scheme="https://arclogicr.github.io/tags/routing/"/>
    
    <category term="ospf" scheme="https://arclogicr.github.io/tags/ospf/"/>
    
  </entry>
  
  <entry>
    <title>OSPF学习笔记</title>
    <link href="https://arclogicr.github.io/2022/03/27/ospf-notes/"/>
    <id>https://arclogicr.github.io/2022/03/27/ospf-notes/</id>
    <published>2022-03-27T10:12:04.000Z</published>
    <updated>2023-01-17T07:29:36.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>OSPF全称<strong>开放最短路径优先</strong>（Open Shortest Path First）是一种<strong>链路状态</strong>路由协议。v2版本的OSPF基于IPv4，v3版本的OSPF基于IPv6。在IPv4网络中OSPF应该是被使用最广泛的IGP了。</p><h2 id="基本特点"><a href="#基本特点" class="headerlink" title="基本特点"></a>基本特点</h2><ul><li>OSPF属于IGP，是链路状态协议，基于IP协议号89</li><li>采用分区域的设计，所有区域需要和骨干区域ar0相连</li><li>区域内采用SPF(Dijkstra算法)计算最佳路径</li><li>可以快速响应网络拓扑变化（触发更新）</li><li>支持等价路径负载</li></ul><h2 id="三张表"><a href="#三张表" class="headerlink" title="三张表"></a>三张表</h2><p>OSPF的运行涉及三张表</p><ul><li>邻居表<br>用于记录与opsf邻居之间的状态、参数等；</li><li>拓扑表<br>本质是LSDB,通过LSA来更新数据。用于记录接收的LSA信息，在区域内和ma网络中保持一致</li><li>路由表<br>通过DJ算法将最佳路由提交到路由表</li></ul><h2 id="OSPF路由器类型"><a href="#OSPF路由器类型" class="headerlink" title="OSPF路由器类型"></a>OSPF路由器类型</h2><table><thead><tr><th>路由器类型</th><th>功能</th></tr></thead><tbody><tr><td>内部路由器</td><td>在一个普通区域内部的路由器</td></tr><tr><td>骨干路由器</td><td>在区域0的内部路由器</td></tr><tr><td>ABR</td><td>区域边界路由器，连接两个不通区域的路由器</td></tr><tr><td>ASBR</td><td>自治系统边界路由器，连接OSPF到另一个自治系统的路由器</td></tr></tbody></table><h2 id="OSPF报文类型"><a href="#OSPF报文类型" class="headerlink" title="OSPF报文类型"></a>OSPF报文类型</h2><table><thead><tr><th>类型</th><th>内容</th></tr></thead><tbody><tr><td>HELLO</td><td>hello包，用于建立&#x2F;维护邻居</td></tr><tr><td>DBD</td><td>数据库描述，用于同步自身LSDB摘要</td></tr><tr><td>LSR</td><td>链路状态请求，用于请求LSA</td></tr><tr><td>LSU</td><td>链路状态更新，用于传播LSA详细，可单播可组播</td></tr><tr><td>LSAck</td><td>用于确认收到LSU</td></tr></tbody></table><h2 id="OSPF邻居"><a href="#OSPF邻居" class="headerlink" title="OSPF邻居"></a>OSPF邻居</h2><p>OSPF通过hello报文来建立和维护邻居</p><p><img src="/2022/03/27/ospf-notes/HELLO.png" alt="OSPF HELLO"></p><p>ospf邻居建立过程<br>down：周期性发送hello包；收到不带自己RID的hello包时进入init<br>init：继续正常周期性发送hello包；收到带自己RID的hello包进入2way<br>2way：通过hello包携带的DR&#x2F;BDR信息（如有）选举DR&#x2F;BDR;然后进入exstart<br>exstart: 双法开始单播发送第一个DBD；根据对方的第一个DBD选取主从；然后进入exchange<br>exchange: 开始交换DBD，以master序列号为基准，slave先发DBD，通过序列号隐式确认；发送完毕后进入Loading<br>loading: 双方开始根据DBD的LSA摘要，单播发送LSR请求详细的LSU，同步完成后进入full<br>full: 邻接完成</p><h2 id="OSPF-LSA内容"><a href="#OSPF-LSA内容" class="headerlink" title="OSPF LSA内容"></a>OSPF LSA内容</h2><p>一个LSA可由{Type,LS ID,ADV Router}唯一描述</p><ul><li>Type，LSA类型，常见有1，2，3，4，5，7</li><li>LS ID，链路状态ID，可理解为一个LSA的名称，每类LSA的该字段有不通含义</li><li>ADV Router，通告路由器</li><li>Age，老化时间，一般为3600s，每1800s会无触发更新</li><li>Seq，序列号，0x80000001开始计数，越大表示LSA越新</li><li>Checksum，校验和</li><li>Do Not Age Flag，不老化标识，虚链路LSA该位为1</li></ul><p><img src="/2022/03/27/ospf-notes/LSU.png" alt="OSPF LSU"></p><h2 id="OSPF-LSA类型"><a href="#OSPF-LSA类型" class="headerlink" title="OSPF LSA类型"></a>OSPF LSA类型</h2><table><thead><tr><th>类型</th><th>传播范围</th><th>产生与功能</th><th>LS ID字段</th><th>ADV字段</th></tr></thead><tbody><tr><td>1类Router</td><td>区域内</td><td>每台路由器都会产生，传输本地链路状态</td><td>Router ID</td><td>Router ID</td></tr><tr><td>2类Network</td><td>区域内，广播域内</td><td>DR产生，标识本MA网络中掩码和路由器</td><td>DR接口IP</td><td>DR RouterID</td></tr><tr><td>3类Router Summary</td><td>泛洪整个AS（除totally stub区域）</td><td>由ABR重新产生（根据1、2类或其它3类），用于传递区域间路由</td><td>域间路由（网络号）</td><td>ABR的Router ID，经过一个ABR就会变为该ABR的RID</td></tr><tr><td>4类ASBR Summary</td><td>除ASBR外的非stub区域</td><td>由ASBR所在区域的ABR产生并发出，用于告知ASBR的位置</td><td>ASBR的Router ID</td><td>ABR的Router ID，经过一个ABR就会变为该ABR的RID</td></tr><tr><td>5类AS-External</td><td>全域泛洪，stub区域除外</td><td>ASBR产生，保持ADV不变，传递域外路由</td><td>域外路由（网络号）</td><td>ASBR的Router ID</td></tr><tr><td>7类NSSA-External</td><td>只存在于NSSA区域内,NSSA的ABR会做7转5</td><td>由NSSA区域内ASBR产生，传递域外路由</td><td>域外路由（网络号）</td><td>ASBR的Router ID</td></tr></tbody></table><h2 id="OSPF区域类型"><a href="#OSPF区域类型" class="headerlink" title="OSPF区域类型"></a>OSPF区域类型</h2><p>ospf采用层次设计，用区域分割路由器；区域中路由器保存该区域中所有链路和路由器详细信息，但只保存其它区域路由器和链路的摘要信息</p><ul><li><p>骨干区域主要为高速快速传递数据，通常不接用户</p></li><li><p>常规区域主要连接用户。所有数据需经过骨干区域中转。</p><p>非骨干区域主要包含以下几种类型</p></li></ul><table><thead><tr><th>区域</th><th>特点</th></tr></thead><tbody><tr><td>普通区域</td><td>区域内泛洪1、2类LSA，也会传递3，4，5类LSA</td></tr><tr><td>Stub</td><td>不能配置外部重分发，阻止4，5类路由，ABR自动下发OIA默认路由</td></tr><tr><td>Totally Stub</td><td>不能外部重分发，不会传3，4，5类LSA，会传递1，2类和3类默认LSA，ABR自动下发OIA默认</td></tr><tr><td>NSSA</td><td>可以重分发外部路由作为7类LSA在ABR转成5类。允许1，2，3，7类LSA，ABR不会自动下发OIA默认</td></tr><tr><td>Totally NSSA</td><td>阻止3，4，5类LSA，允许1，2，7和3类默认LSA，ABR自动下发OIA默认</td></tr></tbody></table><h2 id="OSPF路由类型"><a href="#OSPF路由类型" class="headerlink" title="OSPF路由类型"></a>OSPF路由类型</h2><p>OSPF的LSA类型较多，不同LSA传递的路由类型也不一样，共有一下几种类型</p><ul><li>O路由<br>区域内路由，由1类LSA和2类LSA通过DJ算法计算得出</li><li>O IA路由<br>区域间路由，由3类LSA习得</li><li>O E1&#x2F;N1路由<br>1类外部路由&#x2F;1类NSSA外部路由，由4&#x2F;5&#x2F;7类LSA习得；</li><li>O E2&#x2F;N2路由<br>2类外部路由&#x2F;1类NSSA外部路由，由4&#x2F;5&#x2F;7类LSA习得；</li></ul><h2 id="OSPF选路"><a href="#OSPF选路" class="headerlink" title="OSPF选路"></a>OSPF选路</h2><h3 id="度量"><a href="#度量" class="headerlink" title="度量"></a>度量</h3><p>OSPF路由管理距离（AD）默认是110 （CISCO）， 度量单位是cost</p><p><strong>cost&#x3D;reference&#x2F;interface bandwidth</strong></p><p>reference默认是100000000 （10^8），其中每台路由器可以配置不一样，但建议全局一致。另外cost是分方向的，因为ospf区域内收敛算法（dj）需要画有向权重图，cost即为单向权重。</p><h3 id="外部路由度量-x2F-Forward-Address"><a href="#外部路由度量-x2F-Forward-Address" class="headerlink" title="外部路由度量 &#x2F;Forward Address"></a>外部路由度量 &#x2F;Forward Address</h3><p>Forward Address 字段用于优化外部MA网络路由下一跳的问题。在ASBR产生LSA5时填充FA，若该外部路由下一跳接口是MA、且是有效ospf接口则FA填充为改路由实际下一跳地址。</p><p>Forward Metric 是本地到Forward Address 的cost，当forward<br>address&#x3D;0.0.0.0时，forward metric是本路由器到ASBR的metric</p><p>OSPF外部路由type2（默认），默认种子metric为20，且metric不变<br>OSPF外部路由type1，metric是种子metric+forward metric</p><p>另外，在 NSSA 区域，协议规定不能发送为0的FA；<br>当把直连重分布进来，Forward Address：<br>1、加入 ospf 最新的回环口作为 Forward Address；<br>2、如果没有回环口，那么加入 ospf 最新的激活的接口地址；</p><p>如果把外部路由重分布进来，Forward Address：<br>1、外部接口没有运行 ospf，Forward Address 同上；<br>2、外部接口运行了 ospf，Forward Address 是外部路由的下一跳地址。</p><h3 id="O-路由选路"><a href="#O-路由选路" class="headerlink" title="O 路由选路"></a>O 路由选路</h3><ul><li>依次比较AD Metric 小的优先</li><li>当收到来自不同的AR的1 2类LSA，计算的O路由，AD与Metric，先到的优先，不会负载</li><li>当收到来自相同AR的LSA1 2类，计算的O路由，AD与Metric相同，负载</li></ul><h3 id="O-IA-路由选路"><a href="#O-IA-路由选路" class="headerlink" title="O IA 路由选路"></a>O IA 路由选路</h3><ul><li>O&gt;OIA，不考虑AD、Metric</li><li>当收到来自Area 0的3类LSA时，不考虑其它区域的3类LSA，优选Area 0的，不考虑AD、Metric。若均来自Area0，一次比较AD、Metric，若相同，则负载；</li><li>当收到来自非Area0的3类LSA时，依次比较AD、Metric，小的有限，若相同，则负载</li></ul><h3 id="O-E-选路"><a href="#O-E-选路" class="headerlink" title="O E 选路"></a>O E 选路</h3><ul><li>OIA&gt;OE，不考虑AD、metric</li><li>OE1&gt;OE2，不考虑AD、meitric</li><li>OE1路由，比较AD与Metric，相同则负载</li></ul><h2 id="OSPF路由汇总"><a href="#OSPF路由汇总" class="headerlink" title="OSPF路由汇总"></a>OSPF路由汇总</h2><h3 id="3类LSA汇总"><a href="#3类LSA汇总" class="headerlink" title="3类LSA汇总"></a>3类LSA汇总</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">area 2 range 100.1.0.0 255.255.252.0</span><br></pre></td></tr></table></figure><ul><li>含义：把区域2的1,2类转为3类时做汇总，即area 后面跟的区域。不能把本来就是OIA的路由做汇总；</li></ul><h3 id="5类LSA汇总"><a href="#5类LSA汇总" class="headerlink" title="5类LSA汇总"></a>5类LSA汇总</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Summary-address 100.1.0.0 255.255.252.0</span><br></pre></td></tr></table></figure><ul><li>含义：5类LSA的汇总，只能在ASBR上做，即对自己产生的5类路由汇总，对于别的路由器产生的5类路由，没有汇总能力</li></ul><h2 id="OSPF网络类型"><a href="#OSPF网络类型" class="headerlink" title="OSPF网络类型"></a>OSPF网络类型</h2><p>网络物理连接可分为三种</p><ul><li>POINT_TO_POINT</li><li>BROADCAST</li><li>NBMA</li></ul><p>根据物理网络连接类型，OSPF网络类型分为以下几种：</p><table><thead><tr><th>类型</th><th>二层</th><th>Hello&#x2F;Dead</th><th>DR&#x2F;BDR</th><th>手动邻居</th><th>&#x2F;32路由</th></tr></thead><tbody><tr><td>P2P</td><td>HDLC\PPP\FRp2p</td><td>10&#x2F;40</td><td>NO</td><td>NO</td><td>NO</td></tr><tr><td>BROADCAST</td><td>Eth、令牌环、FDDI</td><td>10&#x2F;40</td><td>YES</td><td>NO</td><td>NO</td></tr><tr><td>NBMA</td><td>FR&#x2F;X.25&#x2F;ATM</td><td>30&#x2F;120</td><td>YES</td><td>YES</td><td>NO</td></tr><tr><td>P2MP(Multi)</td><td>HUB-SPOKE</td><td>30&#x2F;120</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>P2MP(NB)</td><td>CISCO私有</td><td>30&#x2F;120</td><td>NO</td><td>YES</td><td>YES</td></tr><tr><td>Loopback</td><td>loopback</td><td>当作host处理</td><td></td><td></td><td></td></tr></tbody></table><p>OSPF建立邻接关系与网络类型无关，与hello&#x2F;dead有关，但不同的网络类型建立邻居后有可能学不到路由。</p><p>如果参与建邻的路由器都需要选举或都不需要选举DR&#x2F;BDR，则可以学习到路由，否则学不到，具体关系如下：</p><table><thead><tr><th></th><th>p2p</th><th>broadcast</th><th>NBMA</th><th>p2mp</th><th>p2mp  NB</th></tr></thead><tbody><tr><td>p2p</td><td></td><td>NO</td><td>NO</td><td>YES</td><td>YES</td></tr><tr><td>broadcast</td><td></td><td></td><td>YES</td><td>NO</td><td>NO</td></tr><tr><td>NBMA</td><td></td><td></td><td></td><td>NO</td><td>NO</td></tr><tr><td>p2mp</td><td></td><td></td><td></td><td></td><td>YES</td></tr><tr><td>p2mp  NB</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="OSPF虚链路"><a href="#OSPF虚链路" class="headerlink" title="OSPF虚链路"></a>OSPF虚链路</h2><p>OSPF虚链路用于解决OSPF区域设计上的问题。</p><p>假设R0-R1-R2-R3互联，R0-R1之间，R1-R2之间，R2-R2之间区域分别为0，1，2。R3由于现实原因无法与R0互联，那么可以采用虚链路。在ABR R1和中转区域R2上配置虚链路，相当于R2与区域0相连。</p><p><img src="/2022/03/27/ospf-notes/OSPF1.png" alt="OSPF Virtual Link"></p><p>虚链路在使用上有一些限制：</p><ul><li>虚链路只在建立邻居的时候发送hello包，邻居建立后不再发送</li><li>虚链路的LSA只会触发更新，并且不会老化</li><li>虚拟链路cost继承物理链路</li><li>虚链路不能跨区域建立（只能在‘被分割的’中转区域建立）</li><li>不能建立再STUB区域</li></ul><h2 id="OSPF认证"><a href="#OSPF认证" class="headerlink" title="OSPF认证"></a>OSPF认证</h2><p>OSPF认证是指在发送hello包时添加认证字段达到认证邻居的效果，可以保护自己的路由传给通过认证的邻居。</p><p>OSPF认证分接口认证和区域认证，区域认证本质就是所有属于该区域的接口都参与认证。同时配置接口认证和区域认证，以接口认证配置优先。</p><h3 id="接口认证"><a href="#接口认证" class="headerlink" title="接口认证"></a>接口认证</h3><h4 id="接口明文认证"><a href="#接口明文认证" class="headerlink" title="接口明文认证"></a>接口明文认证</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int s1/1</span><br><span class="line">ip ospf authentication</span><br><span class="line">ip ospf authentication-key cisco</span><br></pre></td></tr></table></figure><h4 id="接口md5认证"><a href="#接口md5认证" class="headerlink" title="接口md5认证"></a>接口md5认证</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int s1/1</span><br><span class="line">ip ospf authentication message-digest</span><br><span class="line">ip ospf message-digest-key **1** md5 **cisco**</span><br></pre></td></tr></table></figure><p>其中1是key-id，cisco是md5原文</p><h3 id="区域认证"><a href="#区域认证" class="headerlink" title="区域认证"></a>区域认证</h3><h4 id="区域明文"><a href="#区域明文" class="headerlink" title="区域明文"></a>区域明文</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">router ospf 1</span><br><span class="line">ar 0 authentication</span><br></pre></td></tr></table></figure><h4 id="区域md5"><a href="#区域md5" class="headerlink" title="区域md5"></a>区域md5</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">router ospf 1</span><br><span class="line">ar 0 authentication message-digest</span><br></pre></td></tr></table></figure><h3 id="多-key-md5-认证规则："><a href="#多-key-md5-认证规则：" class="headerlink" title="多 key md5 认证规则："></a>多 key md5 认证规则：</h3><p>当配置了最新的 key，将最新 key 与旧 key 都发送到对端：</p><ul><li>若最新的 key，到对端没有找到对应的 key-id，则两端采用旧 key 完成认证。</li><li>若最新的 key，到对端找到相同的key-id，比较密钥，密钥不一致，认证失败；密钥一致，则认证通</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;OSPF全称&lt;strong&gt;开放最短路径优先&lt;/strong&gt;（Open Shortest Path First）是一种&lt;strong&gt;链路</summary>
      
    
    
    
    <category term="路由交换RS" scheme="https://arclogicr.github.io/categories/%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2RS/"/>
    
    
    <category term="network" scheme="https://arclogicr.github.io/tags/network/"/>
    
    <category term="routing" scheme="https://arclogicr.github.io/tags/routing/"/>
    
    <category term="ospf" scheme="https://arclogicr.github.io/tags/ospf/"/>
    
  </entry>
  
  <entry>
    <title>IPv4地址</title>
    <link href="https://arclogicr.github.io/2022/03/17/ipv4/"/>
    <id>https://arclogicr.github.io/2022/03/17/ipv4/</id>
    <published>2022-03-17T10:16:23.000Z</published>
    <updated>2022-10-28T09:47:39.067Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>IPv4，全称Internet Protocol version 4，网际互联协议第四版。“the Internet”专指的互联网，而这里感觉internet翻译成“网络之间”、“网际”比较好，而不是“互联网”。</p><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>IP地址是IP协议中重要的一个逻辑概念，它用来去定位、寻找网络的组成部分中的一个（单播）或一些（多播、组播）</p><h3 id="IP地址的组成"><a href="#IP地址的组成" class="headerlink" title="IP地址的组成"></a>IP地址的组成</h3><p>一个IP地址由4组8位的二进制数组成，中间用“.”分隔，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11000000.10101000.00000001.00000010</span><br></pre></td></tr></table></figure><p>二进制位数太多，为了记忆、表达方便，一般采用十进制方式表达，每一段取值区间为[0,255]，上述IP地址可表示为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.2</span><br></pre></td></tr></table></figure><h3 id="掩码（Mask）"><a href="#掩码（Mask）" class="headerlink" title="掩码（Mask）"></a>掩码（Mask）</h3><p>一个IP地址共有4×8&#x3D;32位组成，按照位来划分，可人为定义主机号和网络号，比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.2</span><br></pre></td></tr></table></figure><p>我们定义前24位是网络位，后面8位是主机位。如此一来，我们可以很方便地根据前24位IP来定位一个网络，后8位来定位一台主机。其中192.168.1.0表示一个<strong>网络号</strong>，192.168.1.2表示192.168.1.0这个网络中的一台主机，24是192.168.1.0这个网络的<strong>掩码长度</strong>。</p><p>很容易发现192.168.1.0这个网络可用前24位唯一标识，而后8位主机位不能影响我们识别一个网络。那么我们将192.168.1.2化为二进制11000000.10101000.00000001.00000010，将它和由24个1和8个0组成的“IP”地址11111111.11111111.11111111.00000000进行’与’操作，得到的恰好就是它的网络号11000000.10101000.00000001.00000000(192.168.1.0)。把这个特殊的“IP”化为二进制得到255.255.255.0，这就是<strong>子网掩码</strong>。</p><h3 id="IP地址分类、私有地址"><a href="#IP地址分类、私有地址" class="headerlink" title="IP地址分类、私有地址"></a>IP地址分类、私有地址</h3><h4 id="有类划分"><a href="#有类划分" class="headerlink" title="有类划分"></a>有类划分</h4><p>早期IP地址有一套有类划分方式，即根据一定则将IP地址根据子网掩码&#x2F;8，&#x2F;16，&#x2F;24分为不同类。但是这种分类方案显然并不十分合理，浪费IP资源。比如一个固定20台终端的部门被分配了&#x2F;24掩码的网段，那么有230多个地址没有被使用。</p><h4 id="无类划分"><a href="#无类划分" class="headerlink" title="无类划分"></a>无类划分</h4><p>后来有了VLSM（可变长子网掩码）的概念，即可任意指定子网掩码。早期的路由协议如ripv1，igrp等都是只支持有类路由的；而CIDR(无类域间路由)，是基于VLSM的。</p><h4 id="私有IP地址"><a href="#私有IP地址" class="headerlink" title="私有IP地址"></a>私有IP地址</h4><p>IP地址是一个逻辑概念，用于定位互联的网络中一台终端。理论上一个网络中所有IP地址不能有重复，但是由于IPv4地址耗尽，必须复用一些IP地址。一些不接入互联网的组织、单位、机构等，只需内部网络IP地址保持唯一即可。私有IP就是为这种场景设计的，在IP地址的有类划分中，每一类都有一个私有地址段。当然这种场景下，如果有访问互联网的需求，在公网地址有限的情况下，可以通过NAT技术实现私有网络与互联网互通。</p><h4 id="IPv4地址有类划分"><a href="#IPv4地址有类划分" class="headerlink" title="IPv4地址有类划分"></a>IPv4地址有类划分</h4><h5 id="A类地址"><a href="#A类地址" class="headerlink" title="A类地址"></a>A类地址</h5><p>IP地址第一段首位固定为0，即</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0xxxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx</span><br></pre></td></tr></table></figure><p>由于第一位固定是0，第一段取值范围为0-127</p><p>A类私有地址为10.0.0.0&#x2F;8<br>A类地址占总地址1&#x2F;2</p><h5 id="B类地址"><a href="#B类地址" class="headerlink" title="B类地址"></a>B类地址</h5><p>首位固定10，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10xxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx</span><br></pre></td></tr></table></figure><p>第一段取值范围是128-191</p><p>私有地址172.16.16.0&#x2F;12 (16-31) 16个B</p><h5 id="C类地址"><a href="#C类地址" class="headerlink" title="C类地址"></a>C类地址</h5><p>首位固定110</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">110xxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx</span><br></pre></td></tr></table></figure><p>第一段取值范围192-223</p><p>私有地址192.168.0.0&#x2F;16 256个C</p><p>C类地址占总地址1&#x2F;8</p><h5 id="D类地址（组播，没有网络号和主机号）"><a href="#D类地址（组播，没有网络号和主机号）" class="headerlink" title="D类地址（组播，没有网络号和主机号）"></a>D类地址（组播，没有网络号和主机号）</h5><p>首位固定1110</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1110xxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx</span><br></pre></td></tr></table></figure><p>首段取值224-239</p><p>私有地址239.0.0.0&#x2F;8</p><p>D类地址占总地址1&#x2F;16</p><h5 id="E类地址为实验地址，为除ABCD类之外的地址"><a href="#E类地址为实验地址，为除ABCD类之外的地址" class="headerlink" title="E类地址为实验地址，为除ABCD类之外的地址"></a>E类地址为实验地址，为除ABCD类之外的地址</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;IPv4，全称Internet Protocol version 4，网际互联协议第四版。“the Internet”专指的互联网，而这里感</summary>
      
    
    
    
    <category term="网络基础" scheme="https://arclogicr.github.io/categories/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="network" scheme="https://arclogicr.github.io/tags/network/"/>
    
    <category term="tcp/ip" scheme="https://arclogicr.github.io/tags/tcp-ip/"/>
    
  </entry>
  
</feed>
