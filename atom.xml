<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Arclogic&#39;s Blog</title>
  
  <subtitle>subtitleA</subtitle>
  <link href="https://arclogicr.github.io/atom.xml" rel="self"/>
  
  <link href="https://arclogicr.github.io/"/>
  <updated>2022-10-28T09:48:55.079Z</updated>
  <id>https://arclogicr.github.io/</id>
  
  <author>
    <name>Arclogic</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OSPF经典问题汇总</title>
    <link href="https://arclogicr.github.io/2022/03/28/OSPF-QA/"/>
    <id>https://arclogicr.github.io/2022/03/28/OSPF-QA/</id>
    <published>2022-03-28T08:13:52.000Z</published>
    <updated>2022-10-28T09:48:55.079Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OSPF采用分区域设计有什么好处？"><a href="#OSPF采用分区域设计有什么好处？" class="headerlink" title="OSPF采用分区域设计有什么好处？"></a>OSPF采用分区域设计有什么好处？</h2><ul><li>可以在ABR做路由汇总，减少其它区域路由表条目，减轻路由器压力</li><li>减少1，2类LSA泛洪</li><li>减少路由收敛的范围，一个区域的问题不会影响其它区域</li></ul><h2 id="影响OSPF邻接的原因有哪些？"><a href="#影响OSPF邻接的原因有哪些？" class="headerlink" title="影响OSPF邻接的原因有哪些？"></a>影响OSPF邻接的原因有哪些？</h2><p>1、ROUTER ID不能相同；<br>2、HELLO时间必须一致；<br>3、DEAD时间必须一致；<br>4、区域ID必须相同；<br>5、认证必须相同；<br>6、STUB标志位必须相同（hello包中域外路由重分布能力位）；<br>7、MTU不匹配无法形成邻接关系<br>8、OSPF版本号不同（目前版本为2）；<br>9、当OSPF网络类型是MA时，要求掩码一定一致（两个邻居）。因为会出现DR和LSA-2，无法描述网段</p><h2 id="如果OSPF双方路由器MTU不一致，会发生什么情况"><a href="#如果OSPF双方路由器MTU不一致，会发生什么情况" class="headerlink" title="如果OSPF双方路由器MTU不一致，会发生什么情况"></a>如果OSPF双方路由器MTU不一致，会发生什么情况</h2><p><strong>无法建立邻接关系</strong></p><p>假设<strong>R1 MTU &lt; R2 MTU</strong></p><p>首先，双方都可以进入exstart状态。然后双方开始单播发送第一个DBD，<br>此时<br>若R2的RID&gt;R1的RID</p><p>对于R1：收到R2第一个DBD发现MTU比自己大，无法接受；所以维持发送第一个DBD的状态，即维持exstart状态</p><p>对于R2: 正常收到R1的第一个DBD然后可以计算出自己是master，然后等待对方发送LSA摘要；但是发现R1只会发第一个DBD不发LSA摘要，（猜测：可能以为通讯有问题），于是维持发送第一个DBD，即维持exstart状态</p><p>若R2的RID&lt;RI的RID</p><p>对于R1：收到R2第一个DBD发现MTU比自己大，无法接受；所以维持发送第一个DBD的状态，即维持exstart状态</p><p>对于R2: 正常收到R1的第一个DBD然后可以计算出对方是master而自己是slave，然后会发送LSA摘要，即进入exchange状态，但对方没有回复LSA摘要，所以会支持卡在exchange这个状态</p><p>总结：<br>当双方mtu不一致时<br><strong>若DBD从的mtu小，则双方都卡在exstart</strong><br><strong>若DBD从的mtu大，则mtu大的进入exchange，mtu小的维持exstart</strong></p><p><strong>总之，mtu小的一定卡在exstart，mtu大的有可能进入exchange（取决于是否是DBD从角色）</strong></p><h2 id="OSPF何时用组播，何时用单播？"><a href="#OSPF何时用组播，何时用单播？" class="headerlink" title="OSPF何时用组播，何时用单播？"></a>OSPF何时用组播，何时用单播？</h2><ul><li>HELLO包，不手动指定邻居的话都是发送到组播224.0.0.5</li><li>DBD，只是两个路由器之间建邻居互传DB摘要，采用单播</li><li>LSR，请求LSA，直接向DR请求，单播</li><li>LSU<ul><li>回复LSR时是单播</li><li>触发更新时是组播<ul><li>DR-Other 采用组播224.0.0.6告知DR&#x2F;BDR，由DR发送224.0.0.5告知其它所有路由器</li><li>p2p类型网络都是发送到组播224.0.0.5</li></ul></li></ul></li><li>LSAck，组播224.0.05</li></ul><h2 id="OSPF邻居表发现2-way是否正常"><a href="#OSPF邻居表发现2-way是否正常" class="headerlink" title="OSPF邻居表发现2-way是否正常"></a>OSPF邻居表发现2-way是否正常</h2><p><strong>MA网络中正常</strong><br>在MA网络中，DR和BDR分别与DROther建立full邻接关系，DROther之间只是2-way关系</p><h2 id="如何判断一条LSA的新旧"><a href="#如何判断一条LSA的新旧" class="headerlink" title="如何判断一条LSA的新旧"></a>如何判断一条LSA的新旧</h2><p>当一台路由器收到相同的LSA的多个实例时，将通过以下算法决定将哪一条放入数据库：</p><p>1、比较LSA实例的序列号，大的优先<br>2、序列号相同，再比校验和，大的优先<br>3、校验和也相同，再比老化时间，如果有一条LSA拥有大小为最大生存时间（3600S）的老化时间，则最优<br>4、如果LSA的老化时间之间的差别多于15分钟，则老化时间小的优先<br>5、如果以上条件都比不出来，则认为这些LSA相同</p><h2 id="如果不相邻的两台OSPF路由器RID相同会发生什么"><a href="#如果不相邻的两台OSPF路由器RID相同会发生什么" class="headerlink" title="如果不相邻的两台OSPF路由器RID相同会发生什么"></a>如果不相邻的两台OSPF路由器RID相同会发生什么</h2><p><strong>若这些路由器在同一区域</strong><br><img src="/2022/03/28/OSPF-QA/RID1.png" alt="OSPF RID1"><br>R1-R2-R3连接，且都属于同一区域<br>假设R2-R3先正常建立邻居后，R1配置R3的RID接入。此时R1与R2可以建立full邻接关系，R1会收到R2发来的较新的1类LSA，这里的1类LSA应该有两条<br>第一条ADV Router是R3<br>第二条ADV Router是R1</p><p>这里R1会接受R2独有的路由（即ADV Router为R2且R3 没通告的路由，如lo 0的路由），收到R3路由发现和自己RID一样，会报RID dup的错，同时也会发送自己的最新的LSA。R3同理。<br><strong>最后结果就是R1,R3可以学到R2的loopback 路由但R1,R3互相的路由不稳定会翻动</strong></p><p><strong>若这些路由器在不通区域</strong><br><img src="/2022/03/28/OSPF-QA/RID2.png" alt="OSPF RID2"><br>R1-R2-R3连接，R1-R2属于区域1，R2-R3属于区域0<br>假设R2-R3先正常建立邻居后，R1配置R3的RID接入。此时R1与R2可以建立full邻接关系。这里R2是ABR，R2会吧R3通告的1类LSA转为3类，在发给区域1的时候ADV Router字段会变为自己（即R2的RID），但不会重新处理5类LSA。所以对区域1的内部路由器R1来说，收到的R3路由会当做普通的三类LSA处理，并不知道这些OIA路由来自哪里；同理，R3也能学到R1的域内路由。<br><strong>最后结果就是R1,R3可以互相学到域内路由</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;OSPF采用分区域设计有什么好处？&quot;&gt;&lt;a href=&quot;#OSPF采用分区域设计有什么好处？&quot; class=&quot;headerlink&quot; title=&quot;OSPF采用分区域设计有什么好处？&quot;&gt;&lt;/a&gt;OSPF采用分区域设计有什么好处？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;可以在A</summary>
      
    
    
    
    <category term="网络基础" scheme="https://arclogicr.github.io/categories/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="network" scheme="https://arclogicr.github.io/tags/network/"/>
    
    <category term="routing" scheme="https://arclogicr.github.io/tags/routing/"/>
    
    <category term="ospf" scheme="https://arclogicr.github.io/tags/ospf/"/>
    
  </entry>
  
  <entry>
    <title>OSPF学习笔记</title>
    <link href="https://arclogicr.github.io/2022/03/27/ospf-notes/"/>
    <id>https://arclogicr.github.io/2022/03/27/ospf-notes/</id>
    <published>2022-03-27T10:12:04.000Z</published>
    <updated>2022-10-28T09:49:21.030Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>OSPF全称<strong>开放最短路径优先</strong>（Open Shortest Path First）是一种<strong>链路状态</strong>路由协议。v2版本的OSPF基于IPv4，v3版本的OSPF基于IPv6。在IPv4网络中OSPF应该是被使用最广泛的IGP了。</p><h2 id="基本特点"><a href="#基本特点" class="headerlink" title="基本特点"></a>基本特点</h2><ul><li>OSPF属于IGP，是链路状态协议，基于IP协议号89</li><li>采用分区域的设计，所有区域需要和骨干区域ar0相连</li><li>区域内采用SPF(Dijkstra算法)计算最佳路径</li><li>可以快速响应网络拓扑变化（触发更新）</li><li>支持等价路径负载</li></ul><h2 id="三张表"><a href="#三张表" class="headerlink" title="三张表"></a>三张表</h2><p>OSPF的运行涉及三张表</p><ul><li>邻居表<br>用于记录与opsf邻居之间的状态、参数等；</li><li>拓扑表<br>本质是LSDB,通过LSA来更新数据。用于记录接收的LSA信息，在区域内和ma网络中保持一致</li><li>路由表<br>通过DJ算法将最佳路由提交到路由表</li></ul><h2 id="OSPF路由器类型"><a href="#OSPF路由器类型" class="headerlink" title="OSPF路由器类型"></a>OSPF路由器类型</h2><table><thead><tr><th>路由器类型</th><th>功能</th></tr></thead><tbody><tr><td>内部路由器</td><td>在一个普通区域内部的路由器</td></tr><tr><td>骨干路由器</td><td>在区域0的内部路由器</td></tr><tr><td>ABR</td><td>区域边界路由器，连接两个不通区域的路由器</td></tr><tr><td>ASBR</td><td>自治系统边界路由器，连接OSPF到另一个自治系统的路由器</td></tr></tbody></table><h2 id="OSPF报文类型"><a href="#OSPF报文类型" class="headerlink" title="OSPF报文类型"></a>OSPF报文类型</h2><table><thead><tr><th>类型</th><th>内容</th></tr></thead><tbody><tr><td>HELLO</td><td>hello包，用于建立&#x2F;维护邻居</td></tr><tr><td>DBD</td><td>数据库描述，用于同步自身LSDB摘要</td></tr><tr><td>LSR</td><td>链路状态请求，用于请求LSA</td></tr><tr><td>LSU</td><td>链路状态更新，用于传播LSA详细，可单播可组播</td></tr><tr><td>LSAck</td><td>用于确认收到LSU</td></tr></tbody></table><h2 id="OSPF邻居"><a href="#OSPF邻居" class="headerlink" title="OSPF邻居"></a>OSPF邻居</h2><p>OSPF通过hello报文来建立和维护邻居</p><p><img src="/2022/03/27/ospf-notes/HELLO.png" alt="OSPF HELLO"></p><p>ospf邻居建立过程<br>down：周期性发送hello包；收到不带自己RID的hello包时进入init<br>init：继续正常周期性发送hello包；收到带自己RID的hello包进入2way<br>2way：通过hello包携带的DR&#x2F;BDR信息（如有）选举DR&#x2F;BDR;然后进入exstart<br>exstart: 双法开始单播发送第一个DBD；根据对方的第一个DBD选取主从；然后进入exchange<br>exchange: 开始交换DBD，以master序列号为基准，slave先发DBD，通过序列号隐式确认；发送完毕后进入Loading<br>loading: 双方开始根据DBD的LSA摘要，单播发送LSR请求详细的LSU，同步完成后进入full<br>full: 邻接完成</p><h2 id="OSPF-LSA内容"><a href="#OSPF-LSA内容" class="headerlink" title="OSPF LSA内容"></a>OSPF LSA内容</h2><p>一个LSA可由{Type,LS ID,ADV Router}唯一描述</p><ul><li>Type，LSA类型，常见有1，2，3，4，5，7</li><li>LS ID，链路状态ID，可理解为一个LSA的名称，每类LSA的该字段有不通含义</li><li>ADV Router，通告路由器</li><li>Age，老化时间，一般为3600s，每1800s会无触发更新</li><li>Seq，序列号，0x80000001开始计数，越大表示LSA越新</li><li>Checksum，校验和</li><li>Do Not Age Flag，不老化标识，虚链路LSA该位为1</li></ul><p><img src="/2022/03/27/ospf-notes/LSU.png" alt="OSPF LSU"></p><h2 id="OSPF-LSA类型"><a href="#OSPF-LSA类型" class="headerlink" title="OSPF LSA类型"></a>OSPF LSA类型</h2><table><thead><tr><th>类型</th><th>传播范围</th><th>产生与功能</th><th>LS ID字段</th><th>ADV字段</th></tr></thead><tbody><tr><td>1类Router</td><td>区域内</td><td>每台路由器都会产生，传输本地链路状态</td><td>Router ID</td><td>Router ID</td></tr><tr><td>2类Network</td><td>区域内，广播域内</td><td>DR产生，标识本MA网络中掩码和路由器</td><td>DR接口IP</td><td>DR RouterID</td></tr><tr><td>3类Router Summary</td><td>泛洪整个AS（除totally stub区域）</td><td>由ABR重新产生（根据1、2类或其它3类），用于传递区域间路由</td><td>域间路由（网络号）</td><td>ABR的Router ID，经过一个ABR就会变为该ABR的RID</td></tr><tr><td>4类ASBR Summary</td><td>除ASBR外的非stub区域</td><td>由ASBR所在区域的ABR产生并发出，用于告知ASBR的位置</td><td>ASBR的Router ID</td><td>ABR的Router ID，经过一个ABR就会变为该ABR的RID</td></tr><tr><td>5类AS-External</td><td>全域泛洪，stub区域除外</td><td>ASBR产生，保持ADV不变，传递域外路由</td><td>域外路由（网络号）</td><td>ASBR的Router ID</td></tr><tr><td>7类NSSA-External</td><td>只存在于NSSA区域内,NSSA的ABR会做7转5</td><td>由NSSA区域内ASBR产生，传递域外路由</td><td>域外路由（网络号）</td><td>ASBR的Router ID</td></tr></tbody></table><h2 id="OSPF区域类型"><a href="#OSPF区域类型" class="headerlink" title="OSPF区域类型"></a>OSPF区域类型</h2><p>ospf采用层次设计，用区域分割路由器；区域中路由器保存该区域中所有链路和路由器详细信息，但只保存其它区域路由器和链路的摘要信息</p><ul><li><p>骨干区域主要为高速快速传递数据，通常不接用户</p></li><li><p>常规区域主要连接用户。所有数据需经过骨干区域中转。</p><p>非骨干区域主要包含以下几种类型</p></li></ul><table><thead><tr><th>区域</th><th>特点</th></tr></thead><tbody><tr><td>普通区域</td><td>区域内泛洪1、2类LSA，也会传递3，4，5类LSA</td></tr><tr><td>Stub</td><td>不能配置外部重分发，阻止4，5类路由，ABR自动下发OIA默认路由</td></tr><tr><td>Totally Stub</td><td>不能外部重分发，不会传3，4，5类LSA，会传递1，2类和3类默认LSA，ABR自动下发OIA默认</td></tr><tr><td>NSSA</td><td>可以重分发外部路由作为7类LSA在ABR转成5类。允许1，2，3，7类LSA，ABR不会自动下发OIA默认</td></tr><tr><td>Totally NSSA</td><td>阻止3，4，5类LSA，允许1，2，7和3类默认LSA，ABR自动下发OIA默认</td></tr></tbody></table><h2 id="OSPF路由类型"><a href="#OSPF路由类型" class="headerlink" title="OSPF路由类型"></a>OSPF路由类型</h2><p>OSPF的LSA类型较多，不同LSA传递的路由类型也不一样，共有一下几种类型</p><ul><li>O路由<br>区域内路由，由1类LSA和2类LSA通过DJ算法计算得出</li><li>O IA路由<br>区域间路由，由3类LSA习得</li><li>O E1&#x2F;N1路由<br>1类外部路由&#x2F;1类NSSA外部路由，由4&#x2F;5&#x2F;7类LSA习得；</li><li>O E2&#x2F;N2路由<br>2类外部路由&#x2F;1类NSSA外部路由，由4&#x2F;5&#x2F;7类LSA习得；</li></ul><h2 id="OSPF选路"><a href="#OSPF选路" class="headerlink" title="OSPF选路"></a>OSPF选路</h2><h3 id="度量"><a href="#度量" class="headerlink" title="度量"></a>度量</h3><p>OSPF路由管理距离（AD）默认是110 （CISCO）， 度量单位是cost</p><p><strong>cost&#x3D;reference&#x2F;interface bandwidth</strong></p><p>reference默认是100000000 （10^8），其中每台路由器可以配置不一样，但建议全局一致。另外cost是分方向的，因为ospf区域内收敛算法（dj）需要画有向权重图，cost即为单向权重。</p><h3 id="外部路由度量-x2F-Forward-Address"><a href="#外部路由度量-x2F-Forward-Address" class="headerlink" title="外部路由度量 &#x2F;Forward Address"></a>外部路由度量 &#x2F;Forward Address</h3><p>Forward Address 字段用于优化外部MA网络路由下一跳的问题。在ASBR产生LSA5时填充FA，若该外部路由下一跳接口是MA、且是有效ospf接口则FA填充为改路由实际下一跳地址。</p><p>Forward Metric 是本地到Forward Address 的cost，当forward<br>address&#x3D;0.0.0.0时，forward metric是本路由器到ASBR的metric</p><p>OSPF外部路由type2（默认），默认种子metric为20，且metric不变<br>OSPF外部路由type1，metric是种子metric+forward metric</p><p>另外，在 NSSA 区域，协议规定不能发送为0的FA；<br>当把直连重分布进来，Forward Address：<br>1、加入 ospf 最新的回环口作为 Forward Address；<br>2、如果没有回环口，那么加入 ospf 最新的激活的接口地址；</p><p>如果把外部路由重分布进来，Forward Address：<br>1、外部接口没有运行 ospf，Forward Address 同上；<br>2、外部接口运行了 ospf，Forward Address 是外部路由的下一跳地址。</p><h3 id="O-路由选路"><a href="#O-路由选路" class="headerlink" title="O 路由选路"></a>O 路由选路</h3><ul><li>依次比较AD Metric 小的优先</li><li>当收到来自不同的AR的1 2类LSA，计算的O路由，AD与Metric，先到的优先，不会负载</li><li>当收到来自相同AR的LSA1 2类，计算的O路由，AD与Metric相同，负载</li></ul><h3 id="O-IA-路由选路"><a href="#O-IA-路由选路" class="headerlink" title="O IA 路由选路"></a>O IA 路由选路</h3><ul><li>O&gt;OIA，不考虑AD、Metric</li><li>当收到来自Area 0的3类LSA时，不考虑其它区域的3类LSA，优选Area 0的，不考虑AD、Metric。若均来自Area0，一次比较AD、Metric，若相同，则负载；</li><li>当收到来自非Area0的3类LSA时，依次比较AD、Metric，小的有限，若相同，则负载</li></ul><h3 id="O-E-选路"><a href="#O-E-选路" class="headerlink" title="O E 选路"></a>O E 选路</h3><ul><li>OIA&gt;OE，不考虑AD、metric</li><li>OE1&gt;OE2，不考虑AD、meitric</li><li>OE1路由，比较AD与Metric，相同则负载</li></ul><h2 id="OSPF路由汇总"><a href="#OSPF路由汇总" class="headerlink" title="OSPF路由汇总"></a>OSPF路由汇总</h2><h3 id="3类LSA汇总"><a href="#3类LSA汇总" class="headerlink" title="3类LSA汇总"></a>3类LSA汇总</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">area 2 range 100.1.0.0 255.255.252.0</span><br></pre></td></tr></table></figure><ul><li>含义：把区域2的1,2类转为3类时做汇总，即area 后面跟的区域。不能把本来就是OIA的路由做汇总；</li></ul><h3 id="5类LSA汇总"><a href="#5类LSA汇总" class="headerlink" title="5类LSA汇总"></a>5类LSA汇总</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Summary-address 100.1.0.0 255.255.252.0</span><br></pre></td></tr></table></figure><ul><li>含义：5类LSA的汇总，只能在ASBR上做，即对自己产生的5类路由汇总，对于别的路由器产生的5类路由，没有汇总能力</li></ul><h2 id="OSPF网络类型"><a href="#OSPF网络类型" class="headerlink" title="OSPF网络类型"></a>OSPF网络类型</h2><p>网络物理连接可分为三种</p><ul><li>POINT_TO_POINT</li><li>BROADCAST</li><li>NBMA</li></ul><p>根据物理网络连接类型，OSPF网络类型分为以下几种：</p><table><thead><tr><th>类型</th><th>二层</th><th>Hello&#x2F;Dead</th><th>DR&#x2F;BDR</th><th>手动邻居</th><th>&#x2F;32路由</th></tr></thead><tbody><tr><td>P2P</td><td>HDLC\PPP\FRp2p</td><td>10&#x2F;40</td><td>NO</td><td>NO</td><td>NO</td></tr><tr><td>BROADCAST</td><td>Eth、令牌环、FDDI</td><td>10&#x2F;40</td><td>YES</td><td>NO</td><td>NO</td></tr><tr><td>NBMA</td><td>FR&#x2F;X.25&#x2F;ATM</td><td>30&#x2F;120</td><td>YES</td><td>YES</td><td>NO</td></tr><tr><td>P2MP(Multi)</td><td>HUB-SPOKE</td><td>30&#x2F;120</td><td>NO</td><td>NO</td><td>YES</td></tr><tr><td>P2MP(NB)</td><td>CISCO私有</td><td>30&#x2F;120</td><td>NO</td><td>YES</td><td>YES</td></tr><tr><td>Loopback</td><td>loopback</td><td>当作host处理</td><td></td><td></td><td></td></tr></tbody></table><p>OSPF建立邻接关系与网络类型无关，与hello&#x2F;dead有关，但不同的网络类型建立邻居后有可能学不到路由。</p><p>如果参与建邻的路由器都需要选举或都不需要选举DR&#x2F;BDR，则可以学习到路由，否则学不到，具体关系如下：</p><table><thead><tr><th></th><th>p2p</th><th>broadcast</th><th>NBMA</th><th>p2mp</th><th>p2mp  NB</th></tr></thead><tbody><tr><td>p2p</td><td></td><td>NO</td><td>NO</td><td>YES</td><td>YES</td></tr><tr><td>broadcast</td><td></td><td></td><td>YES</td><td>NO</td><td>NO</td></tr><tr><td>NBMA</td><td></td><td></td><td></td><td>NO</td><td>NO</td></tr><tr><td>p2mp</td><td></td><td></td><td></td><td></td><td>YES</td></tr><tr><td>p2mp  NB</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="OSPF虚链路"><a href="#OSPF虚链路" class="headerlink" title="OSPF虚链路"></a>OSPF虚链路</h2><p>OSPF虚链路用于解决OSPF区域设计上的问题。</p><p>假设R0-R1-R2-R3互联，R0-R1之间，R1-R2之间，R2-R2之间区域分别为0，1，2。R3由于现实原因无法与R0互联，那么可以采用虚链路。在ABR R1和中转区域R2上配置虚链路，相当于R2与区域0相连。</p><p><img src="/2022/03/27/ospf-notes/OSPF1.png" alt="OSPF Virtual Link"></p><p>虚链路在使用上有一些限制：</p><ul><li>虚链路只在建立邻居的时候发送hello包，邻居建立后不再发送</li><li>虚链路的LSA只会触发更新，并且不会老化</li><li>虚拟链路cost继承物理链路</li><li>虚链路不能跨区域建立（只能在‘被分割的’中转区域建立）</li><li>不能建立再STUB区域</li></ul><h2 id="OSPF认证"><a href="#OSPF认证" class="headerlink" title="OSPF认证"></a>OSPF认证</h2><p>OSPF认证是指在发送hello包时添加认证字段达到认证邻居的效果，可以保护自己的路由传给通过认证的邻居。</p><p>OSPF认证分接口认证和区域认证，区域认证本质就是所有属于该区域的接口都参与认证。同时配置接口认证和区域认证，以接口认证配置优先。</p><h3 id="接口认证"><a href="#接口认证" class="headerlink" title="接口认证"></a>接口认证</h3><h4 id="接口明文认证"><a href="#接口明文认证" class="headerlink" title="接口明文认证"></a>接口明文认证</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int s1/1</span><br><span class="line">ip ospf authentication</span><br><span class="line">ip ospf authentication-key cisco</span><br></pre></td></tr></table></figure><h4 id="接口md5认证"><a href="#接口md5认证" class="headerlink" title="接口md5认证"></a>接口md5认证</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int s1/1</span><br><span class="line">ip ospf authentication message-digest</span><br><span class="line">ip ospf message-digest-key **1** md5 **cisco**</span><br></pre></td></tr></table></figure><p>其中1是key-id，cisco是md5原文</p><h3 id="区域认证"><a href="#区域认证" class="headerlink" title="区域认证"></a>区域认证</h3><h4 id="区域明文"><a href="#区域明文" class="headerlink" title="区域明文"></a>区域明文</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">router ospf 1</span><br><span class="line">ar 0 authentication</span><br></pre></td></tr></table></figure><h4 id="区域md5"><a href="#区域md5" class="headerlink" title="区域md5"></a>区域md5</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">router ospf 1</span><br><span class="line">ar 0 authentication message-digest</span><br></pre></td></tr></table></figure><h3 id="多-key-md5-认证规则："><a href="#多-key-md5-认证规则：" class="headerlink" title="多 key md5 认证规则："></a>多 key md5 认证规则：</h3><p>当配置了最新的 key，将最新 key 与旧 key 都发送到对端：</p><ul><li>若最新的 key，到对端没有找到对应的 key-id，则两端采用旧 key 完成认证。</li><li>若最新的 key，到对端找到相同的key-id，比较密钥，密钥不一致，认证失败；密钥一致，则认证通</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;OSPF全称&lt;strong&gt;开放最短路径优先&lt;/strong&gt;（Open Shortest Path First）是一种&lt;strong&gt;链路</summary>
      
    
    
    
    <category term="网络基础" scheme="https://arclogicr.github.io/categories/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="network" scheme="https://arclogicr.github.io/tags/network/"/>
    
    <category term="routing" scheme="https://arclogicr.github.io/tags/routing/"/>
    
    <category term="ospf" scheme="https://arclogicr.github.io/tags/ospf/"/>
    
  </entry>
  
  <entry>
    <title>IPv4地址</title>
    <link href="https://arclogicr.github.io/2022/03/17/ipv4/"/>
    <id>https://arclogicr.github.io/2022/03/17/ipv4/</id>
    <published>2022-03-17T10:16:23.000Z</published>
    <updated>2022-10-28T09:47:39.067Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>IPv4，全称Internet Protocol version 4，网际互联协议第四版。“the Internet”专指的互联网，而这里感觉internet翻译成“网络之间”、“网际”比较好，而不是“互联网”。</p><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>IP地址是IP协议中重要的一个逻辑概念，它用来去定位、寻找网络的组成部分中的一个（单播）或一些（多播、组播）</p><h3 id="IP地址的组成"><a href="#IP地址的组成" class="headerlink" title="IP地址的组成"></a>IP地址的组成</h3><p>一个IP地址由4组8位的二进制数组成，中间用“.”分隔，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11000000.10101000.00000001.00000010</span><br></pre></td></tr></table></figure><p>二进制位数太多，为了记忆、表达方便，一般采用十进制方式表达，每一段取值区间为[0,255]，上述IP地址可表示为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.2</span><br></pre></td></tr></table></figure><h3 id="掩码（Mask）"><a href="#掩码（Mask）" class="headerlink" title="掩码（Mask）"></a>掩码（Mask）</h3><p>一个IP地址共有4×8&#x3D;32位组成，按照位来划分，可人为定义主机号和网络号，比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.2</span><br></pre></td></tr></table></figure><p>我们定义前24位是网络位，后面8位是主机位。如此一来，我们可以很方便地根据前24位IP来定位一个网络，后8位来定位一台主机。其中192.168.1.0表示一个<strong>网络号</strong>，192.168.1.2表示192.168.1.0这个网络中的一台主机，24是192.168.1.0这个网络的<strong>掩码长度</strong>。</p><p>很容易发现192.168.1.0这个网络可用前24位唯一标识，而后8位主机位不能影响我们识别一个网络。那么我们将192.168.1.2化为二进制11000000.10101000.00000001.00000010，将它和由24个1和8个0组成的“IP”地址11111111.11111111.11111111.00000000进行’与’操作，得到的恰好就是它的网络号11000000.10101000.00000001.00000000(192.168.1.0)。把这个特殊的“IP”化为二进制得到255.255.255.0，这就是<strong>子网掩码</strong>。</p><h3 id="IP地址分类、私有地址"><a href="#IP地址分类、私有地址" class="headerlink" title="IP地址分类、私有地址"></a>IP地址分类、私有地址</h3><h4 id="有类划分"><a href="#有类划分" class="headerlink" title="有类划分"></a>有类划分</h4><p>早期IP地址有一套有类划分方式，即根据一定则将IP地址根据子网掩码&#x2F;8，&#x2F;16，&#x2F;24分为不同类。但是这种分类方案显然并不十分合理，浪费IP资源。比如一个固定20台终端的部门被分配了&#x2F;24掩码的网段，那么有230多个地址没有被使用。</p><h4 id="无类划分"><a href="#无类划分" class="headerlink" title="无类划分"></a>无类划分</h4><p>后来有了VLSM（可变长子网掩码）的概念，即可任意指定子网掩码。早期的路由协议如ripv1，igrp等都是只支持有类路由的；而CIDR(无类域间路由)，是基于VLSM的。</p><h4 id="私有IP地址"><a href="#私有IP地址" class="headerlink" title="私有IP地址"></a>私有IP地址</h4><p>IP地址是一个逻辑概念，用于定位互联的网络中一台终端。理论上一个网络中所有IP地址不能有重复，但是由于IPv4地址耗尽，必须复用一些IP地址。一些不接入互联网的组织、单位、机构等，只需内部网络IP地址保持唯一即可。私有IP就是为这种场景设计的，在IP地址的有类划分中，每一类都有一个私有地址段。当然这种场景下，如果有访问互联网的需求，在公网地址有限的情况下，可以通过NAT技术实现私有网络与互联网互通。</p><h4 id="IPv4地址有类划分"><a href="#IPv4地址有类划分" class="headerlink" title="IPv4地址有类划分"></a>IPv4地址有类划分</h4><h5 id="A类地址"><a href="#A类地址" class="headerlink" title="A类地址"></a>A类地址</h5><p>IP地址第一段首位固定为0，即</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0xxxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx</span><br></pre></td></tr></table></figure><p>由于第一位固定是0，第一段取值范围为0-127</p><p>A类私有地址为10.0.0.0&#x2F;8<br>A类地址占总地址1&#x2F;2</p><h5 id="B类地址"><a href="#B类地址" class="headerlink" title="B类地址"></a>B类地址</h5><p>首位固定10，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10xxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx</span><br></pre></td></tr></table></figure><p>第一段取值范围是128-191</p><p>私有地址172.16.16.0&#x2F;12 (16-31) 16个B</p><h5 id="C类地址"><a href="#C类地址" class="headerlink" title="C类地址"></a>C类地址</h5><p>首位固定110</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">110xxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx</span><br></pre></td></tr></table></figure><p>第一段取值范围192-223</p><p>私有地址192.168.0.0&#x2F;16 256个C</p><p>C类地址占总地址1&#x2F;8</p><h5 id="D类地址（组播，没有网络号和主机号）"><a href="#D类地址（组播，没有网络号和主机号）" class="headerlink" title="D类地址（组播，没有网络号和主机号）"></a>D类地址（组播，没有网络号和主机号）</h5><p>首位固定1110</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1110xxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx</span><br></pre></td></tr></table></figure><p>首段取值224-239</p><p>私有地址239.0.0.0&#x2F;8</p><p>D类地址占总地址1&#x2F;16</p><h5 id="E类地址为实验地址，为除ABCD类之外的地址"><a href="#E类地址为实验地址，为除ABCD类之外的地址" class="headerlink" title="E类地址为实验地址，为除ABCD类之外的地址"></a>E类地址为实验地址，为除ABCD类之外的地址</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;IPv4，全称Internet Protocol version 4，网际互联协议第四版。“the Internet”专指的互联网，而这里感</summary>
      
    
    
    
    <category term="网络基础" scheme="https://arclogicr.github.io/categories/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="network" scheme="https://arclogicr.github.io/tags/network/"/>
    
    <category term="tcp/ip" scheme="https://arclogicr.github.io/tags/tcp-ip/"/>
    
  </entry>
  
</feed>
